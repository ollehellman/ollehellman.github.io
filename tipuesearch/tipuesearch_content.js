var tipuesearch = {"pages":[{"text":"What is this? The TDEP package is a collection of tools for finite temperature lattice dynamics. Features include, but are not limited to temperature dependent phonon frequencies, anharmonic free energy and lattice thermal conductivity. The package is released under the MIT license, available on github . What can you do with this code? The capabilites are growing constantly. A good place to start would be to read through the papers that have used TDEP in the past, the list can be found here . How to? If you are new, there is a getting started guide . There are example workflows, for simple and more complicated things. Interfaces This is not a stand-alone package. TDEP interfaces with atomistic codes, such as DFT codes or classical forcefields. The basic requirement is that must be able to calculate forces and energies from a given atomic configuration. So far, TDEP has successfully been used in combination with VASP Abinit FHI-AIMS Quantum Espresso LAMMPS Adding support for additional atomistic packages is straightforward, as long as the package can output energies, positions, and forces. Developers TDEP is developed by Olle Hellman and Nina Shulumba.","tags":"","loc":"index.html","title":" TDEP "},{"text":"Files Dependent On This One sourcefile~~dipole.f90~~AfferentGraph sourcefile~dipole.f90 dipole.f90 sourcefile~main.f90 main.f90 sourcefile~dipole.f90->sourcefile~main.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \nis dependent upon another if the latter must be compiled before the former\ncan be. Modules dipole Source Code dipole.f90 Source Code #include \"precompilerdefinitions\" module dipole use konstanter , only : flyt , lo_sqtol , lo_tol use helpers !, only: lo_frobnorm,walltime,lo_trueNtimes,lo_progressbar_init,lo_progressbar use type_crystalstructure , only : lo_crystalstructure use type_forceconstant_secondorder , only : lo_forceconstant_secondorder use type_forcemap , only : lo_forcemap use type_mdsim , only : lo_mdsim use quadratures_stencils implicit none private public :: subtract_longrange_interactions public :: histfit contains subroutine histfit ( sim ) !> force-displacement data type ( lo_mdsim ), intent ( inout ) :: sim integer , parameter :: nhist = 100 real ( flyt ), dimension (:), allocatable :: moments real ( flyt ), parameter :: sigmafactor = 0.05_flyt real ( flyt ), dimension ( nhist ) :: hx , hy , cdfy , cdfx ! First build the histogram. Not sure how to do it smoothly, but I'll figure it out. hist : block real ( flyt ) :: xmin , xmax , sigma , foursigma , stddev , invf real ( flyt ) :: invh integer :: i , j , k , l , ii , jj , u ! Grab all the moments lo_allocate ( moments ( sim % nt * sim % na )) moments = 0.0_flyt l = 0 do i = 1 , sim % nt do j = 1 , sim % na l = l + 1 moments ( l ) = norm2 ( sim % m (:, j , i )) enddo enddo ! Build the cumulative distribution function xmin = minval ( moments ) * 0.97_flyt xmax = maxval ( moments ) * 1.03_flyt call lo_linspace ( xmin , xmax , cdfx ) do i = 1 , nhist cdfy ( i ) = sum ( moments , moments < cdfx ( i )) enddo cdfy = cdfy / cdfy ( nhist ) ! Get the pdf from this. hx = cdfx hy = 0.0_flyt invh = 1.0_flyt / ( hx ( 2 ) - hx ( 1 )) ! get the edges first hy ( 1 ) = ( cdfy ( 2 ) - cdfy ( 1 )) * invh hy ( nhist ) = ( cdfy ( nhist ) - cdfy ( nhist - 1 ) ) * invh do i = 2 , nhist - 1 hy ( i ) = ( cdfy ( i + 1 ) - cdfy ( i - 1 )) * 0.5_flyt * invh enddo end block hist ! Now try to fit it to something fithist : block real ( flyt ) :: nrm0 , nrm1 real ( flyt ) :: f0 , beta1 , beta2 , alpha real ( flyt ) :: mu0 , sig0 , e0 , e1 , e2 real ( flyt ) :: step , a , b , c , d , par_tk , par_theta real ( flyt ), dimension ( 3 ) :: y real ( flyt ), dimension ( 2 ) :: par0 , par1 , grad0 , grad1 , dir , searchdir , bfgs_y , bfgs_s real ( flyt ), dimension ( 2 , 2 ) :: hessian , bfgs_B , bfgs_C , invhessian integer :: i , j , k , l , u integer :: iter , outer , ctr logical :: damped_update ! Starting guess for the mean mu0 = lo_trapezoid_integration ( hx , hx * hy ) ! Starting guess for sigma. Hmm. e1 = sqrt ( lo_trapezoid_integration ( hx , hy * ( hx - mu0 ) ** 2 )) e1 = e1 * 2 * Sqrt ( 2 * log ( 2.0_flyt )) sig0 =- 4 * Log ( 2.0_flyt ) / ( e1 ** 4 - 4 * e1 ** 2 * mu0 ** 2 ) ! Get the starting point par0 = [ mu0 , sig0 ] !call cdferr(cdfx,cdfy,par0,grad0,e0) e0 = lsqerr ( hx , hy , par0 ) call lo_identitymatrix ( hessian ) hessian = hessian * 1 E6_flyt par1 = par0 grad1 = grad0 ! First find decent sigma to start from step = 0.001_flyt e1 = lo_huge write ( * , * ) 0 , par0 , e0 do outer = 1 , 1 !200 !1 !20 grad0 =- lsqgrad ( hx , hy , par0 ) step = 1 E - 5_flyt ctr = 0 do iter = 1 , 1000 !00 grad0 =- lsqgrad ( hx , hy , par0 ) par0 = par0 + grad0 * step e1 = lsqerr ( hx , hy , par0 ) if ( e1 . lt . e0 ) then e0 = e1 step = step * 2_flyt ctr = 0 else par0 = par0 - grad0 * step step = step * 0.25_flyt ctr = ctr + 1 if ( ctr . gt . 5 ) exit endif write ( * , * ) iter , par0 , e1 , step enddo write ( * , * ) outer , par0 , e0 , norm2 ( grad0 ) enddo !        do iter=1,500 !-1 !200 !            !call cdferr(cdfx,cdfy,par1,grad1,e1 !            call lsqerr(hx,hy,par1,grad1,e1) !            if ( iter .gt. 1 ) then !                bfgs_y = grad1-grad0 !                bfgs_s = par1-par0 !                bfgs_B = hessian !                ! Slight damping in the Hessian update ... !                beta1=dot_product(bfgs_y,bfgs_s) !                beta2=dot_product(bfgs_s,matmul(bfgs_B,bfgs_s)) !                par_tk=1.2_flyt*beta2 !                if ( dot_product(bfgs_s,bfgs_y) .lt. par_tk ) then !                    par_theta=0.8_flyt*beta2/(beta2+dot_product(bfgs_s,bfgs_y)) !                    damped_update=.true. !                else !                    par_theta=1.0_flyt !                    damped_update=.false. !                endif ! !                bfgs_y=bfgs_y*par_theta+(1.0_flyt-par_theta)*matmul(bfgs_B,bfgs_s) !                beta1=dot_product(bfgs_y,bfgs_s) !                beta2=dot_product(bfgs_s,matmul(bfgs_B,bfgs_s)) !                bfgs_s=matmul(bfgs_B,bfgs_s) !                do i=1,2 !                do j=1,2 !                    bfgs_C(j,i)=bfgs_B(j,i)+bfgs_y(i)*bfgs_y(j)/beta1-bfgs_s(i)*bfgs_s(j)/beta2 !                enddo !                enddo !                hessian=bfgs_C*0.2_flyt+hessian*0.8_flyt ! !                ! Check eigenvalues of hessian !                a=hessian(1,1) !                b=hessian(2,1) !                c=hessian(1,2) !                d=hessian(2,2) !                beta1=(a + d - Sqrt(a**2 + 4*b*c - 2*a*d + d**2))*0.5_flyt !                beta2=(a + d + Sqrt(a**2 + 4*b*c - 2*a*d + d**2))*0.5_flyt !                a=min(beta1,beta2) !                if ( a .lt. lo_tol ) then !                    hessian(1,1)=hessian(1,1)+abs(a)+1.0_flyt !                    hessian(2,2)=hessian(2,2)+abs(a)+1.0_flyt !                endif !!write(*,*) 'bb',beta1,beta2 !            endif !            e0=e1 !            grad0=grad1 !            par0=par1 !            ! Invert the hessian !            a=hessian(1,1) !            b=hessian(2,1) !            c=hessian(1,2) !            d=hessian(2,2) !            invhessian(:,1)=[d,-b] !            invhessian(:,2)=[-c,-a] !            invhessian=invhessian/(a*d-b*c) !            ! New gradient ! !            if ( damped_update ) then !                searchdir=grad1/norm2(grad1) !            else !                searchdir=-matmul(invhessian,grad1) !                searchdir=searchdir/norm2(searchdir) !            endif !            ! How far? !!write(*,*) hessian ! !            beta1=dot_product(grad1,searchdir) !            beta2=dot_product(searchdir,matmul(hessian,searchdir)) ! !            if ( beta2 .gt. lo_sqtol ) then !                alpha=abs(beta1/beta2) !if ( abs(alpha) .lt. 1E-8_flyt ) exit !            else !                alpha=abs(beta1) !            endif !            par1=par1+alpha*searchdir*1.0_flyt !            ! !            write(*,*) iter,e0,alpha,norm2(grad1),damped_update !            ! !        enddo u = open_file ( 'out' , 'dumhist' ) e0 = normfactor ( par0 ) do i = 1 , nhist write ( u , * ) hx ( i ), hy ( i ), distr ( hx ( i ), par0 ( 1 ), par0 ( 2 )) * e0 enddo close ( u ) u = open_file ( 'out' , 'dumcdf' ) nrm0 = normfactor ( par0 ) do i = 1 , nhist y = cdffn ( par0 , nrm0 , cdfx ( i )) write ( u , * ) cdfx ( i ), cdfy ( i ), y ( 1 ) enddo close ( u ) !par0=[1.0_flyt,0.25_flyt] do i = 3 , 50 !        e0=1.0_flyt/normfactor(par0,20) !        e1=cdffn(par0,i,e0,2.5_flyt) !        write(*,*) i,e0,e1,e1-cdffn(par0,40,e0,2.5_flyt) enddo end block fithist stop contains function lsqgrad ( hx , hy , par ) result ( grad ) real ( flyt ), dimension (:), intent ( in ) :: hx , hy real ( flyt ), dimension ( 2 ), intent ( in ) :: par real ( flyt ), dimension ( 2 ) :: grad integer , parameter :: n = 6 , m = 2 * n + 1 real ( flyt ), dimension ( m , 4 ) :: sc real ( flyt ), dimension ( m ) :: fv integer :: i call lo_centraldifference ( n , par ( 1 ), 1 E - 5_flyt , sc ) do i = 1 , m fv ( i ) = lsqerr ( hx , hy ,[ sc ( i , 1 ), par ( 2 )]) enddo grad ( 1 ) = sum ( sc (:, 2 ) * fv ) call lo_centraldifference ( n , par ( 2 ), 1 E - 5_flyt , sc ) do i = 1 , m fv ( i ) = lsqerr ( hx , hy ,[ par ( 1 ), sc ( i , 1 )]) enddo grad ( 2 ) = sum ( sc (:, 2 ) * fv ) end function function lsqerr ( hx , hy , par ) result ( errorsq ) real ( flyt ), dimension (:), intent ( in ) :: hx , hy real ( flyt ), dimension ( 2 ), intent ( in ) :: par real ( flyt ) :: errorsq real ( flyt ) :: mu , sig , gmu , gsig , nrm real ( flyt ) :: f0 , f1 , f2 integer :: i nrm = normfactor ( par ) ! Squared error and gradient mu = par ( 1 ) sig = par ( 2 ) errorsq = 0.0_flyt do i = 1 , nhist f0 = distr ( hx ( i ), mu , sig ) * nrm errorsq = errorsq + ( hy ( i ) - f0 ) ** 2 enddo end function function distr ( x , mu , sig ) result ( y ) real ( flyt ) :: x , mu , sig real ( flyt ) :: y real ( flyt ) :: arg arg =- sig * ( x ** 2 - mu ** 2 ) ** 2 if ( arg . lt . - 4 0.0_flyt ) then y = 0.0_flyt else y = exp ( arg ) endif end function function energy ( x , mu , sig ) result ( e ) real ( flyt ) :: x , mu , sig real ( flyt ) :: e e = sig * ( x ** 2 - mu ** 2 ) ** 2 end function !> normalization factor for my distribution function normfactor ( par ) result ( nrm ) real ( flyt ), dimension ( 2 ), intent ( in ) :: par real ( flyt ) :: nrm integer , parameter :: nquad = 30 real ( flyt ), dimension ( 2 , nquad ) :: gq real ( flyt ) :: x0 , x1 , x2 , x3 , z1 , z2 , z3 , w1 , w2 , w3 integer :: i ! Get the quadrature weights call lo_gaussianquadrature ( nquad , 0.0_flyt , 1.0_flyt , gq ) x0 = 0.0_flyt z1 = sqrt ( log ( 2.0_flyt ) / par ( 2 )) if ( par ( 1 ) ** 2 . gt . z1 ) then x1 = sqrt ( par ( 1 ) ** 2 - z1 ) else x1 = par ( 1 ) * 0.5_flyt endif x2 = sqrt ( par ( 1 ) ** 2 + z1 ) x3 = sqrt ( par ( 1 ) ** 2 + sqrt ( log ( 1 E14_flyt ) / par ( 2 ))) nrm = 0.0_flyt do i = 1 , nquad z1 = gq ( 1 , i ) * ( x1 - x0 ) + x0 z2 = gq ( 1 , i ) * ( x2 - x1 ) + x1 z3 = gq ( 1 , i ) * ( x3 - x2 ) + x2 w1 = gq ( 2 , i ) * ( x1 - x0 ) w2 = gq ( 2 , i ) * ( x2 - x1 ) w3 = gq ( 2 , i ) * ( x3 - x2 ) nrm = nrm + distr ( z1 , par ( 1 ), par ( 2 ) ) * w1 nrm = nrm + distr ( z2 , par ( 1 ), par ( 2 ) ) * w2 nrm = nrm + distr ( z3 , par ( 1 ), par ( 2 ) ) * w3 enddo nrm = 1.0_flyt / nrm end function !> cumulative distribution function thing function cdffn ( par , normfactor , x ) result ( y ) !> parameters for the distribution real ( flyt ), dimension ( 2 ), intent ( in ) :: par !> normalization factor real ( flyt ), intent ( in ) :: x !> value, mu-derivative,sigma-derivative real ( flyt ), dimension ( 3 ) :: y integer , parameter :: nquad = 50 real ( flyt ), dimension ( 2 , nquad ) :: gq real ( flyt ) :: normfactor , f0 integer :: i ! Get the quadrature weights call lo_gaussianquadrature ( nquad , 0.0_flyt , x , gq ) y = 0.0_flyt do i = 1 , nquad f0 = distr ( gq ( 1 , i ), par ( 1 ), par ( 2 )) * gq ( 2 , i ) y ( 1 ) = y ( 1 ) + f0 y ( 2 ) = y ( 2 ) - f0 * 4 * par ( 1 ) * ( par ( 1 ) ** 2 - gq ( 1 , i ) ** 2 ) * par ( 2 ) y ( 3 ) = y ( 3 ) - f0 * ( par ( 1 ) ** 2 - gq ( 1 , i ) ** 2 ) ** 2 enddo y = y * normfactor end function end subroutine !> remove longrange interactions subroutine subtract_longrange_interactions ( sim , map , uc , ss ) !> force-displacement data type ( lo_mdsim ), intent ( inout ) :: sim !> forcemap type ( lo_forcemap ), intent ( in ) :: map !> unitcell type ( lo_crystalstructure ), intent ( inout ) :: uc !> supercell type ( lo_crystalstructure ), intent ( inout ) :: ss type ( lo_forceconstant_secondorder ) :: fc real ( flyt ), dimension (:,:,:,:), allocatable :: forceconstant real ( flyt ), dimension (:,:), allocatable :: f real ( flyt ), dimension ( 3 , 3 ) :: m0 , m1 real ( flyt ), dimension ( 3 ) :: v0 real ( flyt ) :: t0 , f0 integer :: a1 , a2 , t write ( * , * ) '' write ( * , * ) 'SUBTRACTING LONGRANGE ELECTROSTATIC INTERACTIONS' ! Get some forceconstant thingy call map % get_secondorder_forceconstant ( uc , fc ) lo_allocate ( forceconstant ( 3 , 3 , ss % na , ss % na )) call fc % supercell_longrange_dynamical_matrix_at_gamma ( ss , forceconstant , 1 E - 15_flyt ) ! small sanity-check, just in case f0 = 0.0_flyt do a1 = 1 , ss % na do a2 = a1 , ss % na m0 = forceconstant (:,:, a1 , a2 ) m1 = transpose ( forceconstant (:,:, a2 , a1 )) f0 = f0 + lo_frobnorm ( m0 - m1 ) enddo enddo f0 = f0 / ( ss % na ** 2 ) if ( f0 . gt . lo_tol ) then write ( * , * ) 'ERROR, non-Hermitian electrostatic forceconstant: ' , f0 write ( * , * ) 'If this keeps happening I should not hard-code the Ewald tolerance.' stop endif t0 = walltime () call lo_progressbar_init () ! Subtract forces lo_allocate ( f ( 3 , ss % na )) do t = 1 , sim % nt ! calculate the long-range forces f = 0.0_flyt do a1 = 1 , ss % na do a2 = 1 , ss % na v0 = matmul ( forceconstant (:,:, a1 , a2 ), sim % u (:, a2 , t )) f (:, a1 ) = f (:, a1 ) - v0 enddo enddo ! sanity check that they add up to zero if ( abs ( sum ( f )) . gt . lo_sqtol ) then write ( * , * ) '' write ( * , * ) 'ERROR: dipole-dipole forces do not add up to zero!' stop endif ! subtract them sim % f (:,:, t ) = sim % f (:,:, t ) - f if ( lo_trueNtimes ( t , 50 , sim % nt ) ) call lo_progressbar ( ' ... subtracting dipole-dipole forces' , t , sim % nt ) enddo call lo_progressbar ( ' ... subtracting dipole-dipole forces' , sim % nt , sim % nt , walltime () - t0 ) end subroutine end module","tags":"","loc":"sourcefile/dipole.f90.html","title":"dipole.f90 – TDEP"},{"text":"This File Depends On sourcefile~~main.f90~~EfferentGraph sourcefile~main.f90 main.f90 sourcefile~test_forceconstant_symmetry.f90 test_forceconstant_symmetry.f90 sourcefile~test_forceconstant_symmetry.f90->sourcefile~main.f90 sourcefile~dipole.f90 dipole.f90 sourcefile~dipole.f90->sourcefile~main.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \nis dependent upon another if the latter must be compiled before the former\ncan be. Programs extract_forceconstants Source Code main.f90 Source Code #include \"precompilerdefinitions\" program extract_forceconstants !!{!src/extract_forceconstants/manual.md!}! use konstanter , only : flyt , lo_tol , lo_bohr_to_A , lo_pressure_HartreeBohr_to_GPa , lo_Hartree_to_eV use helpers , only : lo_mpi_helper , tochar , walltime , open_file , lo_chop , lo_does_file_exist , lo_trueNtimes , lo_mean , lo_stddev use type_crystalstructure , only : lo_crystalstructure use type_forceconstant_firstorder , only : lo_forceconstant_firstorder use type_forceconstant_secondorder , only : lo_forceconstant_secondorder use type_forceconstant_thirdorder , only : lo_forceconstant_thirdorder use type_forceconstant_fourthorder , only : lo_forceconstant_fourthorder use type_jij_secondorder , only : lo_jij_secondorder use type_symmetrylist , only : lo_symlist use type_forcemap , only : lo_forcemap , lo_secondorder_rot_herm_huang use type_mdsim , only : lo_mdsim ! use options , only : lo_opts use test_forceconstant_symmetry , only : test_forceconstant_constraints use relax_structure , only : relax_internal_coordinates use dipole , only : subtract_longrange_interactions , histfit ! implicit none ! type ( lo_opts ) :: opts type ( lo_crystalstructure ) :: uc , ss type ( lo_mdsim ) :: sim type ( lo_forcemap ) :: map type ( lo_forceconstant_firstorder ) :: fc1 type ( lo_forceconstant_secondorder ) :: fc2 type ( lo_forceconstant_thirdorder ) :: fc3 type ( lo_forceconstant_fourthorder ) :: fc4 type ( lo_jij_secondorder ) :: jij type ( lo_mpi_helper ) :: mw real ( flyt ) :: t0 ! I should determine the general nature of the task here: it could be ! a) ! get forceconstants from force-displacement data ! b) ! get forceconstants from an input file, for interpolation purposes ! To start, I need at least the unitcell call mw % init () t0 = walltime () call opts % parse () write ( * , * ) '... reading unitcell' call uc % readfromfile ( 'infile.ucposcar' , verbosity = opts % verbosity ) call uc % classify ( 'wedge' , timereversal = . true .) ! We need a forcemap to continue. getfrcmap : block type ( lo_symlist ) :: sl integer :: i real ( flyt ) :: t0 ! Either read it from file or create it if ( opts % readforcemap ) then ! I might need the supercell anyway if ( opts % readirreducible . eqv . . false . ) then call ss % readfromfile ( 'infile.ssposcar' ) call ss % classify ( 'supercell' , uc ) endif call map % read_from_hdf5 ( uc , ss , 'infile.forcemap.hdf5' , opts % readirreducible , opts % verbosity ) ! Update constraints that depend on structure call lo_secondorder_rot_herm_huang ( map , uc , map % constraints % eq2 , map % constraints % neq2 ,& opts % rotationalconstraints , opts % huanginvariance , opts % hermitian ) else ! Now we have to calculate the whole thing. call uc % classify ( 'wedge' , timereversal = . true .) call ss % readfromfile ( 'infile.ssposcar' ) write ( * , * ) '... min cutoff: ' , tochar ( ss % mincutoff () * lo_bohr_to_A ) write ( * , * ) '... max cutoff: ' , tochar ( ss % maxcutoff () * lo_bohr_to_A ) ! Get all the symmetries call sl % generate ( uc , ss , opts % cutoff2 , opts % cutoff3 , opts % cutoff4 , opts % polar ,& transposition = opts % transposition , spacegroup = opts % spacegroup , verbosity = opts % verbosity + 1 ,& wzdim = opts % wzdimensions , nj2 = opts % njump2 , nj3 = opts % njump3 ,& nj4 = opts % njump4 , firstorder = opts % firstorder , magcutoff2 = opts % magcutoff2 , magsinglet = opts % magnetic_onsite ) ! And create the map call map % generate ( sl , uc , ss , polarcorrectiontype = opts % polarcorrectiontype , verbosity = opts % verbosity ) ! Create the constraints t0 = walltime () write ( * , * ) '... generating constraints' t0 = walltime () call map % forceconstant_constraints ( uc , opts % rotationalconstraints , opts % huanginvariance , opts % hermitian , opts % verbosity + 10 ) write ( * , * ) '... got constraints in ' , tochar ( walltime () - t0 ), 's' if ( opts % printforcemap ) then call map % write_to_hdf5 ( sl , uc , ss , 'outfile.forcemap.hdf5' , opts % verbosity ) endif endif ! Now that we have the map, create the linear constraints end block getfrcmap ! With the forcemap, we can get the irreducible representation getirr : block real ( flyt ) :: sz integer :: i , u ! Either read them from file, or calculate them if ( opts % readirreducible ) then if ( map % firstorder ) then u = open_file ( 'in' , 'infile.irrifc_firstorder' ) do i = 1 , map % nfc_singlet read ( u , * ) map % ifc_singlet ( i ) enddo close ( u ) endif if ( map % secondorder ) then u = open_file ( 'in' , 'infile.irrifc_secondorder' ) do i = 1 , map % nfc_pair read ( u , * ) map % ifc_pair ( i ) enddo close ( u ) endif if ( map % thirdorder ) then u = open_file ( 'in' , 'infile.irrifc_thirdorder' ) do i = 1 , map % nfc_triplet read ( u , * ) map % ifc_triplet ( i ) enddo close ( u ) endif if ( map % fourthorder ) then u = open_file ( 'in' , 'infile.irrifc_fourthorder' ) do i = 1 , map % nfc_quartet read ( u , * ) map % ifc_quartet ( i ) enddo close ( u ) endif if ( map % polar ) then u = open_file ( 'in' , 'infile.irrtheta_loto' ) do i = 1 , map % ntheta_eps read ( u , * ) map % theta_eps ( i ) enddo do i = 1 , map % ntheta_Z read ( u , * ) map % theta_Z ( i ) enddo close ( u ) endif if ( map % magnetic_pair_interactions ) then write ( * , * ) 'FIXME READ IRREDUCIBLE MAGNETIC PAIRS' stop endif write ( * , * ) '... enforce the constraints' call map % enforce_constraints () else ! Now we have to calculate the whole thing, first we need positions and forces. ! Get the force-displacement data if ( lo_does_file_exist ( 'infile.sim.hdf5' ) ) then call sim % read_from_hdf5 ( 'infile.sim.hdf5' , verbosity = 2 , stride = opts % stride ) else if ( map % magnetic_pair_interactions ) then call sim % read_from_file ( verbosity = 2 , stride = opts % stride , readmag = . true .) else call sim % read_from_file ( verbosity = 2 , stride = opts % stride , readmag = . false .) endif call sim % rms_displacement ( uc , ss ) endif ! Fix drift call sim % remove_force_and_center_of_mass_drift () !call histfit(sim) ! Solve for the born-charges and dielectric tensor first. if ( map % polar ) then ! get the raw Born charges and dielectric tensor call map % solve_for_borncharges ( filename = 'infile.lotosplitting' , verbosity = opts % verbosity + 1 ) endif ! Remove the dipole-dipole interactions if ( map % polarcorrectiontype . eq . 3 ) then call subtract_longrange_interactions ( sim , map , uc , ss ) endif ! Now I can figure out how much memory is needed for this, approximately. It's nice to ! warn the use here if it goes into TB range or something. sz = ( sim % na * 3 * sim % nt * map % nfc * 4 * 3 ) / 1024_flyt ** 2 if ( sz . gt . 1000 ) then write ( * , * ) '... will try to allocate at least ' , tochar ( ceiling ( sz )), 'Mb' endif ! Maybe relax? if ( opts % relax ) then call relax_internal_coordinates ( map , sim , uc , ss , opts % solver , opts % solveralpha ) ! Dump the relaxed structures call uc % writetofile ( 'outfile.relaxed_ucposcar' , 1 ) call ss % writetofile ( 'outfile.relaxed_ssposcar' , 1 ) write ( * , * ) 'Relaxation done, files written!' stop endif ! Solve for the irreducible representation call map % solve_equations ( sim , opts % solver , opts % solveralpha , opts % residualfit , verbosity = 2 ) ! Solve for magnetic Jij if ( map % magnetic_pair_interactions ) then call map % solve_for_jij ( sim , uc , ss , verbosity = 2 ) endif ! And store the irreducible representation if ( map % firstorder ) then u = open_file ( 'out' , 'outfile.irrifc_firstorder' ) do i = 1 , map % nfc_singlet write ( u , * ) map % ifc_singlet ( i ) enddo close ( u ) endif if ( map % secondorder ) then u = open_file ( 'out' , 'outfile.irrifc_secondorder' ) do i = 1 , map % nfc_pair write ( u , * ) map % ifc_pair ( i ) enddo close ( u ) endif if ( map % thirdorder ) then u = open_file ( 'out' , 'outfile.irrifc_thirdorder' ) do i = 1 , map % nfc_triplet write ( u , * ) map % ifc_triplet ( i ) enddo close ( u ) endif if ( map % fourthorder ) then u = open_file ( 'out' , 'outfile.irrifc_fourthorder' ) do i = 1 , map % nfc_quartet write ( u , * ) map % ifc_quartet ( i ) enddo close ( u ) endif if ( map % polar ) then u = open_file ( 'out' , 'outfile.irrtheta_loto' ) do i = 1 , map % ntheta_eps write ( u , * ) map % theta_eps ( i ) enddo do i = 1 , map % ntheta_Z write ( u , * ) map % theta_Z ( i ) enddo close ( u ) endif if ( map % magnetic_pair_interactions ) then u = open_file ( 'out' , 'outfile.irrtheta_magsecondorder' ) do i = 1 , map % ntheta_magpair_jij write ( u , * ) map % theta_magpair_jij ( i ) enddo do i = 1 , map % ntheta_magpair_tij write ( u , * ) map % theta_magpair_tij ( i ) enddo close ( u ) endif endif end block getirr ! Now we can get the actual forceconstants from the forcemap and the irreducible representation getfc : block integer :: i if ( map % firstorder ) then call map % get_firstorder_forceconstant ( uc , fc1 ) write ( * , * ) 'residual forces (eV/A):' do i = 1 , uc % na write ( * , * ) i , fc1 % atom ( i )% m enddo endif if ( map % secondorder ) then call map % get_secondorder_forceconstant ( uc , fc2 ) call fc2 % writetofile ( uc , 'outfile.forceconstant' ) call fc2 % get_elastic_constants ( uc ) write ( * , * ) 'elastic constants (GPa):' do i = 1 , 6 write ( * , \"(6(3X,F15.5))\" ) lo_chop ( fc2 % elastic_constants_voigt (:, i ) * lo_pressure_HartreeBohr_to_GPa , lo_tol ) enddo endif if ( map % thirdorder ) then call map % get_thirdorder_forceconstant ( uc , fc3 ) call fc3 % writetofile ( uc , 'outfile.forceconstant_thirdorder' ) endif if ( map % fourthorder ) then call map % get_fourthorder_forceconstant ( uc , fc4 ) call fc4 % writetofile ( uc , 'outfile.forceconstant_fourthorder' ) endif if ( map % magnetic_pair_interactions ) then call map % get_secondorder_jij ( uc , jij ) call jij % writetofile ( uc , 'outfile.jij' ) endif end block getfc ! And perhaps calculate U0 if ( opts % ediff ) then getU0 : block type ( lo_forceconstant_secondorder ) :: fc2_ss type ( lo_forceconstant_thirdorder ) :: fc3_ss type ( lo_forceconstant_fourthorder ) :: fc4_ss real ( flyt ), dimension (:,:,:,:), allocatable :: polarfc real ( flyt ), dimension (:,:), allocatable :: fp , f2 , f3 , f4 , de , dle real ( flyt ), dimension ( 3 , 3 , 3 , 3 ) :: m4 real ( flyt ), dimension ( 3 , 3 , 3 ) :: m3 real ( flyt ), dimension ( 3 , 3 ) :: m2 real ( flyt ), dimension ( 3 ) :: u1 , u2 , u3 , u4 , v0 real ( flyt ) :: energy integer :: t , i , a1 , a2 , a3 , a4 , i1 , i2 , i3 , i4 , u ! Make sure we have the supercell and MD data if ( ss % na . lt . 0 ) then call ss % readfromfile ( 'infile.ssposcar' ) call ss % classify ( 'supercell' , uc ) endif if ( sim % na . lt . 0 ) then call sim % read_from_file ( verbosity = 2 , stride = opts % stride ) call sim % remove_force_and_center_of_mass_drift () endif ! Get forceconstants for the supercell if ( map % secondorder ) call fc2 % remap ( uc , ss , fc2_ss ) if ( map % thirdorder ) call fc3 % remap ( uc , ss , fc3_ss ) if ( map % fourthorder ) call fc4 % remap ( uc , ss , fc4_ss ) if ( map % polar ) then lo_allocate ( polarfc ( 3 , 3 , ss % na , ss % na )) call fc2 % supercell_longrange_dynamical_matrix_at_gamma ( ss , polarfc , 1 E - 15_flyt ) endif ! Space for forces and stuff lo_allocate ( fp ( 3 , ss % na )) lo_allocate ( f2 ( 3 , ss % na )) lo_allocate ( f3 ( 3 , ss % na )) lo_allocate ( f4 ( 3 , ss % na )) lo_allocate ( de ( sim % nt , 5 )) lo_allocate ( dle ( sim % nt , 5 )) fp = 0.0_flyt f2 = 0.0_flyt f3 = 0.0_flyt f4 = 0.0_flyt de = 0.0_flyt dle = 0.0_flyt write ( * , * ) '' write ( * , * ) 'CALCULATING POTENTIAL ENERGIES (eV/atom)' write ( * , * ) '   conf        Epot                  Epolar                Epair                 Etriplet              Equartet' !     1       -6.839524677083        0.016417795628        0.112660623299        0.001685955875        0.002296712482 !     2       -6.829915786458        0.019703035642        0.118811923784        0.003986464042        0.001081803009 ! Calculate energies and stuff do t = 1 , sim % nt ! get the raw energy de ( t , 1 ) = sim % stat % ep ( t ) ! secondorder energy, first the polar term (if applicable) if ( fc2 % polar ) then energy = 0.0_flyt do a1 = 1 , ss % na v0 = 0.0_flyt do a2 = 1 , ss % na v0 = v0 + matmul ( polarfc (:,:, a2 , a1 ), sim % u (:, a2 , t )) enddo energy = energy + dot_product ( sim % u (:, a1 , t ), v0 ) * 0.5_flyt enddo de ( t , 2 ) = energy endif ! then the pair term if ( map % secondorder ) then energy = 0.0_flyt do a1 = 1 , ss % na v0 = 0.0_flyt do i1 = 1 , fc2_ss % atom ( a1 )% n a2 = fc2_ss % atom ( a1 )% pair ( i1 )% i2 m2 = fc2_ss % atom ( a1 )% pair ( i1 )% m v0 = v0 + matmul ( m2 , sim % u (:, a2 , t )) enddo energy = energy + dot_product ( sim % u (:, a1 , t ), v0 ) * 0.5_flyt enddo de ( t , 3 ) = energy endif ! triplet term if ( map % thirdorder ) then f3 = 0.0_flyt energy = 0.0_flyt do a1 = 1 , fc3_ss % na v0 = 0.0_flyt do i = 1 , fc3_ss % atom ( a1 )% n m3 = fc3_ss % atom ( a1 )% triplet ( i )% m a2 = fc3_ss % atom ( a1 )% triplet ( i )% i2 a3 = fc3_ss % atom ( a1 )% triplet ( i )% i3 u2 = sim % u (:, a2 , t ) u3 = sim % u (:, a3 , t ) do i1 = 1 , 3 do i2 = 1 , 3 do i3 = 1 , 3 v0 ( i1 ) = v0 ( i1 ) - m3 ( i1 , i2 , i3 ) * u2 ( i2 ) * u3 ( i3 ) enddo enddo enddo enddo f3 (:, a1 ) = v0 * 0.5_flyt energy = energy - dot_product ( f3 (:, a1 ), sim % u (:, a1 , t )) / 3.0_flyt enddo de ( t , 4 ) = energy endif ! quartet term if ( map % fourthorder ) then f4 = 0.0_flyt energy = 0.0_flyt do a1 = 1 , fc4_ss % na v0 = 0.0_flyt do i = 1 , fc4_ss % atom ( a1 )% n m4 = fc4_ss % atom ( a1 )% quartet ( i )% m a2 = fc4_ss % atom ( a1 )% quartet ( i )% i2 a3 = fc4_ss % atom ( a1 )% quartet ( i )% i3 a4 = fc4_ss % atom ( a1 )% quartet ( i )% i4 u2 = sim % u (:, a2 , t ) u3 = sim % u (:, a3 , t ) u4 = sim % u (:, a4 , t ) do i1 = 1 , 3 do i2 = 1 , 3 do i3 = 1 , 3 do i4 = 1 , 3 v0 ( i1 ) = v0 ( i1 ) - m4 ( i1 , i2 , i3 , i4 ) * u2 ( i2 ) * u3 ( i3 ) * u4 ( i4 ) enddo enddo enddo enddo enddo f4 (:, a1 ) = v0 / 6.0_flyt energy = energy - dot_product ( f4 (:, a1 ), sim % u (:, a1 , t )) / 4.0_flyt enddo de ( t , 5 ) = energy endif if ( lo_trueNtimes ( t , 20 , sim % nt ) ) then write ( * , \"(1X,I5,5(2X,F20.12))\" ) t , de ( t ,:) * lo_Hartree_to_eV / ss % na endif enddo ! Calculate some differences dle (:, 1 ) = de (:, 1 ) dle (:, 2 ) = de (:, 1 ) - de (:, 2 ) dle (:, 3 ) = de (:, 1 ) - de (:, 2 ) - de (:, 3 ) dle (:, 4 ) = de (:, 1 ) - de (:, 2 ) - de (:, 3 ) - de (:, 4 ) dle (:, 5 ) = de (:, 1 ) - de (:, 2 ) - de (:, 3 ) - de (:, 4 ) - de (:, 5 ) ! Convert to eV/atom dle = dle * lo_Hartree_to_eV / sim % na write ( * , * ) '' write ( * , \"(1X,'                                 avg E',F20.12,' (eV/atom) stddev ',F20.12,' eV/atom')\" ) lo_mean ( dle (:, 1 )), lo_stddev ( dle (:, 1 )) write ( * , \"(1X,'                          avg E-Epolar',F20.12,' (eV/atom) stddev ',F20.12,' eV/atom')\" ) lo_mean ( dle (:, 2 )), lo_stddev ( dle (:, 2 )) write ( * , \"(1X,'                    avg E-Epolar-Epair',F20.12,' (eV/atom) stddev ',F20.12,' eV/atom')\" ) lo_mean ( dle (:, 3 )), lo_stddev ( dle (:, 3 )) write ( * , \"(1X,'           avg E-Epolar-Epair-Etriplet',F20.12,' (eV/atom) stddev ',F20.12,' eV/atom')\" ) lo_mean ( dle (:, 4 )), lo_stddev ( dle (:, 4 )) write ( * , \"(1X,'  avg E-Epolar-Epair-Etriplet-Equartet',F20.12,' (eV/atom) stddev ',F20.12,' eV/atom')\" ) lo_mean ( dle (:, 5 )), lo_stddev ( dle (:, 5 )) ! Dump it to file u = open_file ( 'out' , 'outfile.U0' ) write ( u , \"(4(1X,E19.12))\" ) lo_mean ( dle (:, 1 )), lo_mean ( dle (:, 3 )), lo_mean ( dle (:, 4 )), lo_mean ( dle (:, 5 )) close ( u ) end block getU0 endif ! Now, perhaps test all the symmetry stuff on the forceconstants !call test_forceconstant_constraints(map,fc1,fc2,fc3,fc4,uc) write ( * , * ) 'Done in ' , tochar ( walltime () - t0 ), 's' call mw % destroy () end program","tags":"","loc":"sourcefile/main.f90.html","title":"main.f90 – TDEP"},{"text":"Files Dependent On This One sourcefile~~test_forceconstant_symmetry.f90~~AfferentGraph sourcefile~test_forceconstant_symmetry.f90 test_forceconstant_symmetry.f90 sourcefile~main.f90 main.f90 sourcefile~test_forceconstant_symmetry.f90->sourcefile~main.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \nis dependent upon another if the latter must be compiled before the former\ncan be. Modules test_forceconstant_symmetry Source Code test_forceconstant_symmetry.f90 Source Code #include \"precompilerdefinitions\" module test_forceconstant_symmetry use konstanter , only : flyt , lo_sqtol , lo_status use helpers , only : tochar , lo_sqnorm use type_crystalstructure , only : lo_crystalstructure use type_forceconstant_firstorder , only : lo_forceconstant_firstorder use type_forceconstant_secondorder , only : lo_forceconstant_secondorder use type_forceconstant_thirdorder , only : lo_forceconstant_thirdorder use type_forceconstant_fourthorder , only : lo_forceconstant_fourthorder use type_forcemap , only : lo_forcemap implicit none private public :: test_forceconstant_constraints contains subroutine test_forceconstant_constraints ( map , fc1 , fc2 , fc3 , fc4 , uc ) !> all the forceconstant metadata type ( lo_forcemap ), intent ( in ) :: map !> firstorder forceconstant type ( lo_forceconstant_firstorder ), intent ( in ) :: fc1 !> secondorder forceconstant type ( lo_forceconstant_secondorder ), intent ( in ) :: fc2 !> thirdorder forceconstant type ( lo_forceconstant_thirdorder ), intent ( in ) :: fc3 !> fourthorder forceconstant type ( lo_forceconstant_fourthorder ), intent ( in ) :: fc4 !> crystal structure type ( lo_crystalstructure ), intent ( in ) :: uc ! Start testing a lot of sum rules on the forceconstants, start with the trivial ! rotational constraints on the first order forceconstant if ( map % firstorder ) then rot1 : block real ( flyt ), dimension ( 3 , 3 ) :: m0 , m1 real ( flyt ), dimension ( 3 ) :: r integer :: a1 , i , j ! Check the constraints m0 = 0.0_flyt m1 = 0.0_flyt do a1 = 1 , uc % na r = uc % rcart (:, a1 ) do i = 1 , 3 do j = 1 , 3 m0 ( i , j ) = m0 ( i , j ) + fc1 % atom ( a1 )% m ( i ) * r ( j ) m1 ( i , j ) = m1 ( i , j ) + fc1 % atom ( a1 )% m ( j ) * r ( i ) enddo enddo enddo write ( * , * ) '     firstorder rotational constraint:' , abs ( sum ( m0 - m1 )) end block rot1 endif ! Then we have the first+second order if ( map % firstorder . and . map % secondorder ) then rot2 : block real ( flyt ), dimension ( 3 , 3 , 3 ) :: m0 , m1 real ( flyt ), dimension ( 3 ) :: r integer :: a1 , i , al , be , gm do a1 = 1 , uc % na m0 = 0.0_flyt m1 = 0.0_flyt do i = 1 , fc2 % atom ( a1 )% n r = fc2 % atom ( a1 )% pair ( i )% r do al = 1 , 3 do be = 1 , 3 do gm = 1 , 3 m0 ( al , be , gm ) = m0 ( al , be , gm ) + fc2 % atom ( a1 )% pair ( i )% m ( al , be ) * r ( gm ) + fc1 % atom ( a1 )% m ( be ) * kron ( al , gm ) m1 ( al , be , gm ) = m1 ( al , be , gm ) + fc2 % atom ( a1 )% pair ( i )% m ( al , gm ) * r ( be ) + fc1 % atom ( a1 )% m ( gm ) * kron ( al , be ) enddo enddo enddo enddo write ( * , * ) '   second+first rotational constraint:' , sum ( m0 - m1 ), '(atom ' , tochar ( a1 ), ')' enddo end block rot2 endif ! Pure secondorder rotational if ( ( map % firstorder . eqv . . false .) . and . map % secondorder ) then rot3 : block real ( flyt ), dimension ( 3 , 3 , 3 ) :: m0 , m1 real ( flyt ), dimension ( 3 ) :: r integer :: a1 , i , al , be , gm do a1 = 1 , uc % na m0 = 0.0_flyt m1 = 0.0_flyt do i = 1 , fc2 % atom ( a1 )% n r = fc2 % atom ( a1 )% pair ( i )% r do al = 1 , 3 do be = 1 , 3 do gm = 1 , 3 m0 ( al , be , gm ) = m0 ( al , be , gm ) + fc2 % atom ( a1 )% pair ( i )% m ( al , be ) * r ( gm ) m1 ( al , be , gm ) = m1 ( al , be , gm ) + fc2 % atom ( a1 )% pair ( i )% m ( al , gm ) * r ( be ) enddo enddo enddo enddo write ( * , * ) '    secondorder rotational constraint:' , abs ( sum ( m0 - m1 )) enddo end block rot3 endif if ( map % secondorder . and . map % thirdorder ) then rot4 : block real ( flyt ), dimension ( 3 , 3 , 3 , 3 ) :: m0 , m1 real ( flyt ), dimension ( 3 ) :: r real ( flyt ) :: f0 integer :: a1 , i , j , k , al , be , gm , lm , ii , ti integer , dimension (:), allocatable :: di do a1 = 1 , uc % na lo_allocate ( di ( fc3 % atom ( a1 )% n )) di = 0 f0 = 0.0_flyt do i = 1 , fc2 % atom ( a1 )% n r = fc2 % atom ( a1 )% pair ( i )% r ! get a list if triplets with the same j-vector, to sum over ii = 0 do j = 1 , fc3 % atom ( a1 )% n if ( lo_sqnorm ( r - fc3 % atom ( a1 )% triplet ( j )% rv3 ) . lt . lo_sqtol ) then ii = ii + 1 di ( ii ) = j endif enddo ! Now loop and sum over these triplets m0 = 0.0_flyt m1 = 0.0_flyt do k = 1 , ii ti = di ( k ) do al = 1 , 3 do be = 1 , 3 do gm = 1 , 3 do lm = 1 , 3 m0 ( al , be , gm , lm ) = m0 ( al , be , gm , lm ) + & fc2 % atom ( a1 )% pair ( i )% m ( gm , be ) * kron ( al , lm ) + & fc2 % atom ( a1 )% pair ( i )% m ( gm , be ) * kron ( al , lm ) + & fc3 % atom ( a1 )% triplet ( ti )% m ( al , be , gm ) * r ( lm ) m1 ( al , be , gm , lm ) = m1 ( al , be , gm , lm ) + & fc2 % atom ( a1 )% pair ( i )% m ( lm , be ) * kron ( al , gm ) + & fc2 % atom ( a1 )% pair ( i )% m ( lm , be ) * kron ( al , gm ) + & fc3 % atom ( a1 )% triplet ( ti )% m ( al , be , lm ) * r ( gm ) enddo enddo enddo enddo enddo f0 = f0 + abs ( sum ( m0 - m1 )) enddo lo_deallocate ( di ) write ( * , * ) '     thirdorder rotational constraint:' , a1 , f0 enddo end block rot4 endif contains function kron ( i , j ) result ( k ) integer :: i , j , k if ( i . eq . j ) then k = 1 else k = 0 endif end function end subroutine end module","tags":"","loc":"sourcefile/test_forceconstant_symmetry.f90.html","title":"test_forceconstant_symmetry.f90 – TDEP"},{"text":"Programs crystal_structure_info Source Code main.f90 Source Code #include \"precompilerdefinitions\" program crystal_structure_info !!{!src/crystal_structure_info/manual.md!} ! Prints general info about the lattice, high symmetry points and so on. use konstanter , only : flyt , lo_tol , lo_sqtol , lo_bohr_to_A use helpers , only : lo_frobnorm , lo_mpi_helper , lo_chop , open_file , tochar , lo_clean_fractional_coordinates , lo_determ ,& lo_fetch_tolerance , walltime , lo_return_unique , lo_invert3x3matrix , qsort use options , only : lo_opts use type_crystalstructure , only : lo_crystalstructure use type_qpointmesh , only : lo_bandstructure ! implicit none ! for normal phonon things type ( lo_opts ) :: opts type ( lo_crystalstructure ) :: uc type ( lo_bandstructure ) :: bs type ( lo_mpi_helper ) :: mw ! real ( flyt ), dimension ( 3 ) :: v0 , v1 real ( flyt ) :: tstart , f0 integer :: i , j , u character ( len = 1000 ) :: opf ! ! Get the command line arguments ! call mw % init () tstart = walltime () call opts % parse () ! Read unitcell call uc % readfromfile ( 'infile.ucposcar' , verbosity = opts % verbosity ) call uc % classify ( 'wedge' , timereversal = opts % timereversal ) write ( * , * ) 'Info about the crystal structure:' write ( * , * ) '... I believe the basis is ' , trim ( uc % info % bravaislatticelongname ), ' (' , trim ( uc % info % bravaislattice ), ') with the basis vectors' write ( * , \"(1X,'a1:',3(2X,F18.12))\" ) uc % latticevectors (:, 1 ) * lo_bohr_to_A write ( * , \"(1X,'a2:',3(2X,F18.12))\" ) uc % latticevectors (:, 2 ) * lo_bohr_to_A write ( * , \"(1X,'a3:',3(2X,F18.12))\" ) uc % latticevectors (:, 3 ) * lo_bohr_to_A write ( * , * ) '... and the atoms at these positions (in fractional coordinates)' do i = 1 , uc % na write ( * , '(1X,A8,3(2x,F15.13))' ) trim ( uc % atomic_symbol ( uc % species ( i ))), uc % r (:, i ) enddo ! Print what the conventional basis is f0 = lo_frobnorm ( uc % latticevectors - uc % info % unique_conventional_basis ) if ( f0 . gt . lo_tol ) then write ( * , * ) 'I believe this is the conventional lattice:' write ( * , \"(1X,'a1:',3(2X,F18.12))\" ) uc % info % unique_conventional_basis (:, 1 ) * lo_bohr_to_A write ( * , \"(1X,'a2:',3(2X,F18.12))\" ) uc % info % unique_conventional_basis (:, 2 ) * lo_bohr_to_A write ( * , \"(1X,'a3:',3(2X,F18.12))\" ) uc % info % unique_conventional_basis (:, 3 ) * lo_bohr_to_A endif !! It might not agree with my canonical form. !f0=lo_frobnorm(uc%latticevectors-uc%info%unique_primitive_basis) !if ( f0 .gt. lo_tol ) then !    write(*,*) ' ' !    write(*,*) 'I like this primitive basis better:' !    write(*,\"(1X,'a1:',3(2X,F18.12))\") uc%info%unique_primitive_basis(:,1) !    write(*,\"(1X,'a2:',3(2X,F18.12))\") uc%info%unique_primitive_basis(:,2) !    write(*,\"(1X,'a3:',3(2X,F18.12))\") uc%info%unique_primitive_basis(:,3) !    write(*,*) '... with the atoms at these positions (in fractional coordinates)' !    ! Convert the coordinates !    allocate(dum(3,uc%na)) !    do i=1,uc%na !        ! get the current coordinate !        v0=uc%r(:,i) !        v0=matmul(uc%info%permutation_to_unique,v0) !        v0=lo_chop(lo_clean_fractional_coordinates(v0),lo_sqtol) !        dum(:,i)=v0 !        write(*,'(1X,A8,3(2x,F15.13))') trim(uc%atomic_symbol(uc%species(i))),dum(:,i) !    enddo !endif ! Get the high symmetry points if ( uc % info % havewedge . eqv . . false . ) call uc % classify ( 'wedge' , timereversal = opts % timereversal ) write ( * , * ) ' ' write ( * , * ) 'Available high symmetry points:' write ( * , * ) '(the ones called NP are in fact high symmetry points, but noone has bothered to name them)' write ( * , * ) '      Cartesian coordinates                        Fractional coordinates' do i = 1 , uc % irrw % nnodes v0 = lo_chop ( uc % irrw % r (:, i ), lo_tol ) v1 = lo_chop ( matmul ( uc % inv_reciprocal_latticevectors , v0 ), lo_tol ) write ( * , \"(1X,I2,1X,A4,3(1X,F13.10),3X,3(1X,F13.10))\" ) i , uc % irrw % label ( i ), v0 / lo_bohr_to_A , v1 enddo call uc % write_bz_to_hdf5 ( 'outfile.brillouin_zone.hdf5' ) call bs % standardpath ( uc ) bs % npts = 100 write ( * , * ) ' ' write ( * , * ) 'Per default, the following path will be used:' do i = 1 , bs % npath write ( * , * ) trim ( bs % symb_q_start ( i )), ' -> ' , trim ( bs % symb_q_end ( i )) enddo write ( * , * ) 'It is written in \"outfile.qpoints_dispersion\", modify and' write ( * , * ) 'copy it to \"infile.qpoints_dispersion\" if you want' ! Dump a path file u = open_file ( 'out' , 'outfile.qpoints_dispersion' ) opf = \"(A5,22X,' ! Bravais lattice type')\" write ( u , opf ) uc % info % bravaislattice opf = \"(I5,22X,' ! Number of points on each path')\" write ( u , opf ) 100 opf = \"(I5,22X,' ! Number paths between special points')\" write ( u , opf ) bs % npath opf = \"(A3,1X,A3,20X,' ! Starting and ending special point')\" write ( u , opf ) bs % symb_q_start ( 1 ), bs % symb_q_end ( 1 ) opf = \"(A3,1X,A3,20X,' !')\" do i = 2 , bs % npath write ( u , opf ) bs % symb_q_start ( i ), bs % symb_q_end ( i ) enddo close ( u ) if ( opts % printsymmetry ) then write ( * , * ) ' Symmetry operations:' do i = 1 , uc % sym % n write ( * , * ) 'Operation ' , tochar ( i ), ' ' , uc % sym % op ( i )% whatkind write ( * , * ) '        Axis:' , lo_chop ( uc % sym % op ( i )% axis , lo_sqtol ) if ( uc % sym % op ( i )% fold . gt . 0 ) write ( * , * ) '       Angle: ' , tochar ( int ( anint ( 36 0.0_flyt / uc % sym % op ( i )% fold ))) opf = '        FMAP:' do j = 1 , size ( uc % sym % op ( i )% fmap ) opf = trim ( opf ) // ' ' // tochar ( j ) // '->' // tochar ( uc % sym % op ( i )% fmap ( j )) enddo write ( * , * ) trim ( opf ) !write(*,*) '        FMAP:',uc%sym%op(i)%fmap write ( * , '(1X,A,3(1X,F9.6))' ) ' translation:' , uc % sym % op ( i )% ftr write ( * , * ) ' ... in Cartesian coordinates' do j = 1 , 3 write ( * , \"(6(3X,F15.11))\" ) uc % sym % op ( i )% m ( j ,:) !write(*,\"(3(3X,A10))\") lo_fancy_real2char(uc%sym%op(i)%m(j,1)),lo_fancy_real2char(uc%sym%op(i)%m(j,2)),lo_fancy_real2char(uc%sym%op(i)%m(j,3)) enddo write ( * , * ) ' ... in fractional coordinates' do j = 1 , 3 write ( * , \"(6(3X,F15.11))\" ) uc % sym % op ( i )% fm ( j ,:) !write(*,\"(6(3X,A3))\") lo_fancy_real2char(uc%sym%op(i)%fm(j,1)),lo_fancy_real2char(uc%sym%op(i)%fm(j,2)),lo_fancy_real2char(uc%sym%op(i)%fm(j,3)) enddo write ( * , * ) ' ' enddo ! Dump symmetry operations to Mathematica-format, in case you need to play with it u = open_file ( 'out' , 'outfile.symops_mathematica' ) write ( u , * ) 'ops=ConstantArray[0,{' // tochar ( uc % sym % n ) // ',3,3}];' do i = 1 , uc % sym % n do j = 1 , 3 write ( u , * ) 'ops[[' // tochar ( i ) // ',' // tochar ( j ) // & ']]={ ' // lo_fancy_real2char ( uc % sym % op ( i )% m ( 1 , j )) // ',' // lo_fancy_real2char ( uc % sym % op ( i )% m ( 2 , j )) // ',' // lo_fancy_real2char ( uc % sym % op ( i )% m ( 3 , j )) // '};' enddo enddo close ( u ) endif write ( * , * ) 'all done' write ( * , * ) ' ' call mw % destroy () contains !!> Find the primitive cell !subroutine find_primitive_cell(basis,r,species,flavor,primbasis,tolerance) !    !> cell to be reduced !    real(flyt), dimension(3,3), intent(in) :: basis !    !> atoms in the cell !    real(flyt), dimension(:,:), intent(in) :: r !    !> species classification !    integer, dimension(:), intent(in) :: species !    !> flavor classification !    integer, dimension(:), intent(in) :: flavor !    !> primitive lattice vectors !    real(flyt), dimension(3,3), intent(out) :: primbasis !    !> tolerance !    real(flyt), intent(in) :: tolerance !    ! !    real(flyt), dimension(:,:), allocatable :: r0,r1 !    real(flyt), dimension(3,3) :: basis0,basis1 !    integer, dimension(:), allocatable :: species0,flavor0,species1,flavor1 !    integer :: i,na !    ! !    na=size(r,2) !    allocate(r0(3,na)) !    allocate(species0(na)) !    allocate(flavor0(na)) !    basis0=basis !    r0=r !    species0=species !    flavor0=flavor ! !    ! Recursively find a smaller cell !    redloop: do !        ! Try to find a smaller cell !        call reduce_cell(basis0,r0,species0,flavor0,basis1,r1,species1,flavor1,tolerance) !        if ( abs(abs(lo_determ(basis0))-abs(lo_determ(basis1))) .lt. tolerance ) then !            ! this means no new cell, we are converged. !            exit redloop !        else !            ! this means a new cell, update and try again! !            if ( allocated(r0) )       deallocate(r0) !            if ( allocated(species0) ) deallocate(species0) !            if ( allocated(flavor0) )  deallocate(flavor0) !            i=size(r1,2) !            allocate(r0(3,i)) !            allocate(species0(i)) !            allocate(flavor0(i)) !            basis0=basis1 !            r0=r1 !            species0=species1 !            flavor0=flavor1 !            if ( allocated(r1) )       deallocate(r1) !            if ( allocated(species1) ) deallocate(species1) !            if ( allocated(flavor1) )  deallocate(flavor1) !        endif !    enddo redloop ! !    ! Here we should be done. !    primbasis=basis0 ! !    if ( allocated(r0) )       deallocate(r0) !    if ( allocated(r1) )       deallocate(r1) !    if ( allocated(species0) ) deallocate(species0) !    if ( allocated(species1) ) deallocate(species1) !    if ( allocated(flavor0) )  deallocate(flavor0) !    if ( allocated(flavor1) )  deallocate(flavor1) !end subroutine !    !> single iteration of the cell reduction !    subroutine reduce_cell(latticevectors,r,species,flavor,newlatticevectors,newr,newspecies,newflavor,tolerance) !        !> original lattice vectors !        real(flyt), dimension(3,3), intent(in) :: latticevectors !        !> original positions !        real(flyt), dimension(:,:), intent(in) :: r !        !> original species !        integer, dimension(:), intent(in) :: species !        !> additional flavor for symmetry thing !        integer, dimension(:), intent(in) :: flavor !        !> tolerance !        real(flyt), intent(in) :: tolerance ! !        real(flyt), dimension(3,3), intent(out) :: newlatticevectors !        real(flyt), dimension(:,:), allocatable, intent(out) :: newr !        integer, dimension(:), allocatable, intent(out) :: newspecies !        integer, dimension(:), allocatable,intent(out) :: newflavor ! !        real(flyt), dimension(:,:), allocatable :: vecs,dum !        real(flyt), dimension(3,3) :: m0,m1 !        real(flyt) :: vol,f0,tol,reltol,frtol !        integer :: i,j,k,l,nvecs,na !        logical :: cellvalid ! !        ! set the tolerance !        call lo_fetch_tolerance(tolerance,latticevectors,realspace_cart_tol=tol,realspace_fractional_tol=frtol,relative_tol=reltol) ! !        na=size(r,2) !        ! Get a list of possible lattice vectors: All the vectors in the cell + old latticevectors !        l=na+3 !        allocate(dum(3,na+3)) !        dum(:,1:na)=lo_clean_fractional_coordinates(r,frtol**2) !        do i=1,na !            dum(:,i)=matmul(latticevectors,dum(:,i)) !        enddo !        do i=1,3 !            dum(:,i+na)=latticevectors(:,i) !        enddo !        ! Reduce these to the unique. Should not be necessary, but never hurts. !        call lo_return_unique(dum,vecs,frtol) !        nvecs=size(vecs,2) ! !        ! volume of original cell !        vol=abs(lo_determ(latticevectors)) !        ! Loop over all vectors to try to find a new cell. !        vl1: do i=1,nvecs !        vl2: do j=i+1,nvecs !        vl3: do k=j+1,nvecs !            ! possible new set of lattice vectors !            m0(:,1)=vecs(:,i) !            m0(:,2)=vecs(:,j) !            m0(:,3)=vecs(:,k) !            ! some quick tests to see if there is any point in continuing: !            f0=abs(lo_determ(m0)) !            if ( f0 .lt. tol ) cycle vl3                           ! stupid cell if volume is zero !            if ( abs(mod(vol/f0,1.0_flyt)) .gt. reltol ) cycle vl3 ! has to be an integer division !            if ( int(anint(vol/f0)) .eq. 1 ) cycle vl3             ! has to make the cell smaller, not the same !            ! I can get really retarded cells from this, do the Delaunay thing on it !            call reduce_basis_to_something_decent(m0,m1) !            ! Now do an actual test !            call test_cell(latticevectors,r,species,flavor,m1,cellvalid,newr,newspecies,newflavor,tolerance) !            if ( cellvalid ) then !                ! If I find a new cell, we will exit this routine and start over. Makes things way way faster. !                newlatticevectors=m1 !                deallocate(vecs) !                return !            endif !        enddo vl3 !        enddo vl2 !        enddo vl1 !        ! If we made it here, the cell is already the smallest. Return the same basis again. !        newlatticevectors=latticevectors !    end subroutine ! !    !> test if a new cell is a smaller unit cell !    subroutine test_cell(oldcell,oldr,oldspecies,oldflavor,cell,valid,newr,newspecies,newflavor,tolerance) !        !> original cell !        real(flyt), dimension(3,3), intent(in) :: oldcell !        !> original positions !        real(flyt), dimension(:,:), intent(in) :: oldr !        !> original species !        integer, dimension(:), intent(in) :: oldspecies !        !> original flavor !        integer, dimension(:), intent(in) :: oldflavor !        !> new cell !        real(flyt), dimension(3,3), intent(in) :: cell !        !> is it a new cell? !        logical, intent(out) :: valid !        !> new positions in case of a valid cell !        real(flyt), dimension(:,:), allocatable, intent(out) :: newr !        !> new species in case of a valid cell !        integer, dimension(:), allocatable, intent(out) :: newspecies !        !> new flavor in case of a valid cell !        integer, dimension(:), allocatable, intent(out) :: newflavor !        !> tolerance !        real(flyt), intent(in) :: tolerance !        ! !        real(flyt), dimension(3,3) :: icell,m0 !        real(flyt), dimension(:,:), allocatable :: dumr1,dumr2 !        real(flyt) :: tol,sqtol !        integer :: i,j,l,mult,oldna,newna ! !        ! set the tolerance !        call lo_fetch_tolerance(tolerance,oldcell,realspace_fractional_tol=tol) !        sqtol=tol**2 ! !        valid=.false. !        ! How many atoms should I get of each? !        mult=int(anint(abs(lo_determ(oldcell)/lo_determ(cell)))) ! !        ! m0 is a matrix that converts to fractional coordinates in the new cell !        icell=lo_invert3x3matrix( cell ) !        m0=matmul(icell,oldcell) ! !        ! convert coordinates to fractional with respect to the new cell. Also !        ! I decorate the positions with the species and flavor, to keep track of that. !        oldna=size(oldr,2) !        allocate(dumr1(5,oldna)) !        do i=1,oldna !            dumr1(1:3,i)=lo_clean_fractional_coordinates(matmul(m0,oldr(:,i)),sqtol) !            dumr1(4:5,i)=[oldspecies(i),oldflavor(i)] !        enddo !        ! Reduce this to the union of the list, the unique !        call lo_return_unique(dumr1,dumr2,tol) ! !        ! Did it become the correct number of atoms? !        if ( abs(size(dumr2,2)*mult-oldna) .ne. 0 ) then !            valid=.false. !            return !        endif ! !        ! Slightly better check: Each of the atoms in the reduced cell must appear !        ! exactly mult times in the old cell. !        do i=1,size(dumr2,2) !            l=0 !            do j=1,oldna !                if ( sum(abs(dumr1(:,j)-dumr2(:,i))) .lt. tol ) l=l+1 !            enddo !            ! kill if not true !            if ( l .ne. mult ) then !                valid=.false. !                return !            endif !        enddo ! !        ! ok, now I say this is valid, return the new cell !        newna=size(dumr2,2) !        allocate(newr(3,newna)) !        allocate(newspecies(newna)) !        allocate(newflavor(newna)) !        newr=dumr2(1:3,:) !        newspecies=int(anint(dumr2(4,:))) !        newflavor=int(anint(dumr2(5,:))) !        valid=.true. !    end subroutine !!> reduce a set of lattice vectors to canonical form !subroutine reduce_basis_to_something_decent(basis,canonical_basis) !    !> original lattice vectors !    real(flyt), dimension(3,3), intent(in) :: basis !    !> canonical lattice vectors !    real(flyt), dimension(3,3), intent(out) :: canonical_basis ! !    real(flyt), dimension(3,4) :: ext_basis !    real(flyt), dimension(3,7) :: dum !    real(flyt), dimension(7) :: d !    real(flyt) :: f0 !    integer, dimension(7) :: ind !    integer :: i,j,k ! !    ! First do the Delaunay reduction thing !    ext_basis=0.0_flyt !    ext_basis(:,1:3)=basis !    do i=1,3 !        ext_basis(:,4)=ext_basis(:,4)-basis(:,i) !    enddo !    ! Iterate and stuff !    iterloop: do !        do i=1,4 !        do j=i+1,4 !            ! check scalar product !            f0=dot_product(ext_basis(:,i),ext_basis(:,j)) !            if ( f0 .gt. lo_sqtol ) then !                ! subtract i from all not i and j !                do k=1,4 !                    if ( k .ne. i .and. k .ne. j ) then !                        ext_basis(:,k)=ext_basis(:,k)+ext_basis(:,i) !                    endif !                enddo !                ! flip sign of i !                ext_basis(:,i)=-ext_basis(:,i) !                ! start over! !                cycle iterloop !            endif !        enddo !        enddo !        ! If we make it here, we are done! !        exit iterloop !    enddo iterloop ! !    ! Look through all variants to get shortest vectors !    dum=0.0_flyt !    dum(:,1:4)=ext_basis !    dum(:,5)=ext_basis(:,1)+ext_basis(:,2) !    dum(:,6)=ext_basis(:,2)+ext_basis(:,3) !    dum(:,7)=ext_basis(:,1)+ext_basis(:,3) !    do i=1,7 !        d(i)=norm2(dum(:,i)) !    enddo !    call qsort(d,ind) !    ! !    do i=3,7 !        canonical_basis(:,1)=dum(:,ind(1)) !        canonical_basis(:,2)=dum(:,ind(2)) !        canonical_basis(:,3)=dum(:,ind(i)) !        if ( abs(lo_determ(canonical_basis)) .gt. lo_tol ) exit !    enddo !    if ( lo_determ(canonical_basis) .lt. 0.0_flyt ) canonical_basis=-canonical_basis !end subroutine ! !> Check if an array has repeated values ! logical function lo_is_vector_degenerate_brute(v,thres) !     !> array to test !     real(flyt), dimension(:), intent(in) :: v !     !> tolerance !     real(flyt), intent(in) :: thres !     ! !     integer :: i,j !     real(flyt) :: f0,f1 !     ! !     f0=lo_huge !     do i=1,size(v,1) !         do j=i+1,size(v,1) !             f1=abs(v(i)-v(j)) !             if ( f1 .lt. f0 ) f0=f1 !         enddo !     enddo !     ! !     if ( f0 .lt. thres ) then !         lo_is_vector_degenerate_brute=.true. !     else !         lo_is_vector_degenerate_brute=.false. !     endif ! end function ! ! !> Check if an array has repeated values ! logical function lo_is_vector_degenerate_qsort(v,thres) !     !> array to test !     real(flyt), dimension(:), intent(in) :: v !     !> tolerance !     real(flyt), intent(in) :: thres !     ! !     integer :: i,j !     real(flyt) :: f0,f1 !     real(flyt), dimension(:), allocatable :: dum !     ! !     lo_allocate(dum(size(v,1))) !     dum=v !     call qsort(dum) !     ! !     lo_is_vector_degenerate_qsort=.false. !     do i=1,size(dum,1)-1 !         if ( abs(dum(i)-dum(i+1)) .lt. thres ) then !             lo_is_vector_degenerate_qsort=.true. !             return !         endif !     enddo ! end function !> converts a double to a character, and tries to find well defined numbers function lo_fancy_real2char ( x , tolerance ) result ( s ) !> number to be converted real ( flyt ), intent ( in ) :: x !> optional tolerance real ( flyt ), intent ( in ), optional :: tolerance !> the string character ( len = :), allocatable :: s real ( flyt ) :: tol real ( flyt ), dimension ( 67 ), parameter :: welldefined = [& 0.0000000000000000_flyt ,& 0.1000000000000000_flyt ,& - 0.1000000000000000_flyt ,& 0.1111111111111111_flyt ,& - 0.1111111111111111_flyt ,& 0.1250000000000000_flyt ,& - 0.1250000000000000_flyt ,& 0.1428571428571428_flyt ,& - 0.1428571428571428_flyt ,& 0.1666666666666667_flyt ,& - 0.1666666666666667_flyt ,& 0.2000000000000000_flyt ,& - 0.2000000000000000_flyt ,& 0.2222222222222222_flyt ,& - 0.2222222222222222_flyt ,& 0.2500000000000000_flyt ,& - 0.2500000000000000_flyt ,& 0.2857142857142857_flyt ,& - 0.2857142857142857_flyt ,& 0.3000000000000000_flyt ,& - 0.3000000000000000_flyt ,& 0.3333333333333333_flyt ,& - 0.3333333333333333_flyt ,& 0.3750000000000000_flyt ,& - 0.3750000000000000_flyt ,& 0.4000000000000000_flyt ,& - 0.4000000000000000_flyt ,& 0.4285714285714285_flyt ,& - 0.4285714285714285_flyt ,& 0.4444444444444444_flyt ,& - 0.4444444444444444_flyt ,& 0.5000000000000000_flyt ,& - 0.5000000000000000_flyt ,& 0.5555555555555556_flyt ,& - 0.5555555555555556_flyt ,& 0.5714285714285714_flyt ,& - 0.5714285714285714_flyt ,& 0.6000000000000000_flyt ,& - 0.6000000000000000_flyt ,& 0.6250000000000000_flyt ,& - 0.6250000000000000_flyt ,& 0.6666666666666667_flyt ,& - 0.6666666666666667_flyt ,& 0.7000000000000000_flyt ,& - 0.7000000000000000_flyt ,& 0.7142857142857143_flyt ,& - 0.7142857142857143_flyt ,& 0.7500000000000000_flyt ,& - 0.7500000000000000_flyt ,& 0.7777777777777778_flyt ,& - 0.7777777777777778_flyt ,& 0.8000000000000000_flyt ,& - 0.8000000000000000_flyt ,& 0.8333333333333334_flyt ,& - 0.8333333333333334_flyt ,& 0.8571428571428571_flyt ,& - 0.8571428571428571_flyt ,& 0.8660254037844386_flyt ,& - 0.8660254037844386_flyt ,& 0.8750000000000000_flyt ,& - 0.8750000000000000_flyt ,& 0.8888888888888888_flyt ,& - 0.8888888888888888_flyt ,& 0.9000000000000000_flyt ,& - 0.9000000000000000_flyt ,& 1.0000000000000000_flyt ,& - 1.0000000000000000_flyt ] character ( len = 12 ), dimension ( 67 ), parameter :: welldefined_string = [& '0          ' ,& !    0.0000000000000000_flyt,& '1/10       ' ,& !    0.1000000000000000_flyt,& '-1/10      ' ,& !   -0.1000000000000000_flyt,& 'x          ' ,& !    0.1111111111111111_flyt,& 'x          ' ,& !   -0.1111111111111111_flyt,& '1/8        ' ,& !    0.1250000000000000_flyt,& '/1/8       ' ,& !   -0.1250000000000000_flyt,& 'x          ' ,& !    0.1428571428571428_flyt,& 'x          ' ,& !   -0.1428571428571428_flyt,& '1/6        ' ,& !    0.1666666666666667_flyt,& '-1/6       ' ,& !   -0.1666666666666667_flyt,& '1/5        ' ,& !    0.2000000000000000_flyt,& '-1/5       ' ,& !   -0.2000000000000000_flyt,& 'x          ' ,& !    0.2222222222222222_flyt,& 'x          ' ,& !   -0.2222222222222222_flyt,& '1/4        ' ,& !    0.2500000000000000_flyt,& '-1/4       ' ,& !   -0.2500000000000000_flyt,& 'x          ' ,& !    0.2857142857142857_flyt,& 'x          ' ,& !   -0.2857142857142857_flyt,& 'x          ' ,& !    0.3000000000000000_flyt,& 'x          ' ,& !   -0.3000000000000000_flyt,& 'x          ' ,& !    0.3333333333333333_flyt,& 'x          ' ,& !   -0.3333333333333333_flyt,& 'x          ' ,& !    0.3750000000000000_flyt,& 'x          ' ,& !   -0.3750000000000000_flyt,& 'x          ' ,& !    0.4000000000000000_flyt,& 'x          ' ,& !   -0.4000000000000000_flyt,& 'x          ' ,& !    0.4285714285714285_flyt,& 'x          ' ,& !   -0.4285714285714285_flyt,& 'x          ' ,& !    0.4444444444444444_flyt,& 'x          ' ,& !   -0.4444444444444444_flyt,& '1/2        ' ,& !    0.5000000000000000_flyt,& '-1/2       ' ,& !   -0.5000000000000000_flyt,& 'x          ' ,& !    0.5555555555555556_flyt,& 'x          ' ,& !   -0.5555555555555556_flyt,& 'x          ' ,& !    0.5714285714285714_flyt,& 'x          ' ,& !   -0.5714285714285714_flyt,& 'x          ' ,& !    0.6000000000000000_flyt,& 'x          ' ,& !   -0.6000000000000000_flyt,& 'x          ' ,& !    0.6250000000000000_flyt,& 'x          ' ,& !   -0.6250000000000000_flyt,& 'x          ' ,& !    0.6666666666666667_flyt,& 'x          ' ,& !   -0.6666666666666667_flyt,& 'x          ' ,& !    0.7000000000000000_flyt,& 'x          ' ,& !   -0.7000000000000000_flyt,& 'x          ' ,& !    0.7142857142857143_flyt,& 'x          ' ,& !   -0.7142857142857143_flyt,& 'x          ' ,& !    0.7500000000000000_flyt,& 'x          ' ,& !   -0.7500000000000000_flyt,& 'x          ' ,& !    0.7777777777777778_flyt,& 'x          ' ,& !   -0.7777777777777778_flyt,& 'x          ' ,& !    0.8000000000000000_flyt,& 'x          ' ,& !   -0.8000000000000000_flyt,& 'x          ' ,& !    0.8333333333333334_flyt,& 'x          ' ,& !   -0.8333333333333334_flyt,& 'x          ' ,& !    0.8571428571428571_flyt,& 'x          ' ,& !   -0.8571428571428571_flyt,& 'Sqrt[3]/2  ' ,& !    0.8660254037844386_flyt,& '-Sqrt[3]/2 ' ,& !   -0.8660254037844386_flyt,& 'x          ' ,& !    0.8750000000000000_flyt,& 'x          ' ,& !   -0.8750000000000000_flyt,& 'x          ' ,& !    0.8888888888888888_flyt,& 'x          ' ,& !   -0.8888888888888888_flyt,& '9/10       ' ,& !    0.9000000000000000_flyt,& '-9/10      ' ,& !   -0.9000000000000000_flyt,& '1          ' ,& !    1.0000000000000000_flyt,& '-1         ' ] !   -1.0000000000000000_flyt] integer :: i if ( present ( tolerance ) ) then tol = tolerance else tol = lo_sqtol endif do i = 1 , 67 if ( abs ( x - welldefined ( i )) . lt . tol ) then s = trim ( welldefined_string ( i )) return endif enddo s = 'dunno' end function end program","tags":"","loc":"sourcefile/main.f90~2.html","title":"main.f90 – TDEP"},{"text":"Programs phonon_dispersion_relations Source Code main.f90 Source Code #include \"precompilerdefinitions\" program phonon_dispersion_relations !!{!src/phonon_dispersion_relations/manual.md!} use konstanter , only : flyt , lo_tol , lo_hartree_to_eV use helpers , only : walltime , lo_mpi_helper , tochar , lo_chop , lo_mean , MPI_IN_PLACE , MPI_DOUBLE_PRECISION , MPI_SUM use dump_data , only : lo_dump_gnuplot_2d_real use options , only : lo_opts use type_crystalstructure , only : lo_crystalstructure use type_forceconstant_secondorder , only : lo_forceconstant_secondorder use type_forceconstant_thirdorder , only : lo_forceconstant_thirdorder use type_qpointmesh , only : lo_qpoint_mesh , lo_generate_qmesh , lo_read_qmesh_from_file use type_phonon_dispersions , only : lo_phonon_dispersions use type_phonon_dos , only : lo_phonon_dos use type_phonon_bandstructure , only : lo_phonon_bandstructure ! local use densityplots use velocitydos ! implicit none ! for normal phonon things type ( lo_opts ) :: opts type ( lo_mpi_helper ) :: mw type ( lo_forceconstant_secondorder ) :: fc type ( lo_forceconstant_thirdorder ) :: fct type ( lo_crystalstructure ) :: uc type ( lo_phonon_bandstructure ) :: bs class ( lo_qpoint_mesh ), allocatable :: qp type ( lo_phonon_dispersions ) :: dr type ( lo_phonon_dos ) :: pd ! for phonon dos of alloys real ( flyt ) :: timer #ifdef AGRESSIVE_SANITY real ( flyt ), parameter :: toMB = 1.0_flyt / 102 4.0_flyt ** 2 real ( flyt ), dimension (:), allocatable :: mem_per_rank #endif ! Read things from file init : block ! init MPI call mw % init () ! Get the command line arguments timer = walltime () call opts % parse () if ( mw % talk . eqv . . false . ) opts % verbosity =- 10 ! Read the crystal structure and make sure I have all the symmetry information call uc % readfromfile ( 'infile.ucposcar' , verbosity = opts % verbosity ) call uc % classify ( 'wedge' , timereversal = opts % timereversal ) ! Maybe non-default isotope distribution if ( opts % readiso ) then if ( mw % talk ) write ( * , * ) '... reading isotope distribution from file' call uc % readisotopefromfile () endif ! Read the force constant call fc % readfromfile ( uc , 'infile.forceconstant' , opts % verbosity ) ! Perhaps some Gruneisen parameters, in that case we need third order force constants. if ( opts % gruneisen ) then call fct % readfromfile ( uc , 'infile.forceconstant_thirdorder' ) endif #ifdef AGRESSIVE_SANITY ! make space for the thing that holds memory per rank lo_allocate ( mem_per_rank ( mw % n )) mem_per_rank = 0.0_flyt ! make a memory report if ( mw % talk ) then write ( * , * ) '' write ( * , * ) 'MEMORY DIAGNOSTICS (mean,max,min in MB)' endif mem_per_rank = 0.0_flyt mem_per_rank ( mw % r + 1 ) = uc % size_in_mem () * toMB call mpi_allreduce ( MPI_IN_PLACE , mem_per_rank , mw % n , MPI_DOUBLE_PRECISION , MPI_SUM , mw % comm , mw % error ) if ( mw % talk ) then write ( * , \"(1X,A,3(2X,F12.5))\" ) '                structure:' , lo_mean ( mem_per_rank ), maxval ( mem_per_rank ), minval ( mem_per_rank ) endif mem_per_rank = 0.0_flyt mem_per_rank ( mw % r + 1 ) = fc % size_in_mem () * toMB call mpi_allreduce ( MPI_IN_PLACE , mem_per_rank , mw % n , MPI_DOUBLE_PRECISION , MPI_SUM , mw % comm , mw % error ) if ( mw % talk ) then write ( * , \"(1X,A,3(2X,F12.5))\" ) '            forceconstant:' , lo_mean ( mem_per_rank ), maxval ( mem_per_rank ), minval ( mem_per_rank ) endif mem_per_rank = 0.0_flyt mem_per_rank ( mw % r + 1 ) = fct % size_in_mem () * toMB call mpi_allreduce ( MPI_IN_PLACE , mem_per_rank , mw % n , MPI_DOUBLE_PRECISION , MPI_SUM , mw % comm , mw % error ) if ( mw % talk ) then write ( * , \"(1X,A,3(2X,F12.5))\" ) ' thirdorder forceconstant:' , lo_mean ( mem_per_rank ), maxval ( mem_per_rank ), minval ( mem_per_rank ) endif mem_per_rank = 0.0_flyt mem_per_rank ( mw % r + 1 ) = qp % size_in_mem ( qp ) * toMB call mpi_allreduce ( MPI_IN_PLACE , mem_per_rank , mw % n , MPI_DOUBLE_PRECISION , MPI_SUM , mw % comm , mw % error ) if ( mw % talk ) then write ( * , \"(1X,A,3(2X,F12.5))\" ) '                   q-mesh:' , lo_mean ( mem_per_rank ), maxval ( mem_per_rank ), minval ( mem_per_rank ) endif mem_per_rank = 0.0_flyt mem_per_rank ( mw % r + 1 ) = bs % size_in_mem () * toMB call mpi_allreduce ( MPI_IN_PLACE , mem_per_rank , mw % n , MPI_DOUBLE_PRECISION , MPI_SUM , mw % comm , mw % error ) if ( mw % talk ) then write ( * , \"(1X,A,3(2X,F12.5))\" ) '            bandstructure:' , lo_mean ( mem_per_rank ), maxval ( mem_per_rank ), minval ( mem_per_rank ) endif mem_per_rank = 0.0_flyt mem_per_rank ( mw % r + 1 ) = dr % size_in_mem () * toMB call mpi_allreduce ( MPI_IN_PLACE , mem_per_rank , mw % n , MPI_DOUBLE_PRECISION , MPI_SUM , mw % comm , mw % error ) if ( mw % talk ) then write ( * , \"(1X,A,3(2X,F12.5))\" ) '              dispersions:' , lo_mean ( mem_per_rank ), maxval ( mem_per_rank ), minval ( mem_per_rank ) endif mem_per_rank = 0.0_flyt mem_per_rank ( mw % r + 1 ) = pd % size_in_mem () * toMB call mpi_allreduce ( MPI_IN_PLACE , mem_per_rank , mw % n , MPI_DOUBLE_PRECISION , MPI_SUM , mw % comm , mw % error ) if ( mw % talk ) then write ( * , \"(1X,A,3(2X,F12.5))\" ) '               phonon dos:' , lo_mean ( mem_per_rank ), maxval ( mem_per_rank ), minval ( mem_per_rank ) endif #endif end block init ! Dispersions along a path? path : block real ( flyt ), dimension ( 3 ) :: v1 real ( flyt ) :: t0 integer :: i , verb character ( len = 1000 ) :: opf ! Get the dispersions on the path t0 = walltime () if ( uc % na . ge . 4 . and . mw % talk ) then verb = opts % verbosity + 2 else verb = opts % verbosity endif if ( opts % gruneisen ) then call bs % generate ( uc , fc , timereversal = opts % timereversal , fct = fct , verbosity = verb , npts = opts % nq , readpathfromfile = opts % readpathfromfile , mpi_communicator = mw % comm ) else call bs % generate ( uc , fc , timereversal = opts % timereversal , verbosity = verb , npts = opts % nq , readpathfromfile = opts % readpathfromfile , correctionlevel = 2 , mpi_communicator = mw % comm ) endif ! Write a small summary if ( mw % talk ) then write ( * , * ) ' ' write ( * , * ) ' Settings: ' write ( * , * ) '      mode Gruneisen parameters: ' , opts % gruneisen write ( * , * ) '                number of bands: ' , tochar ( bs % nb ) write ( * , * ) '                number of paths: ' , tochar ( bs % npath ) write ( * , * ) '  number of points on each path: ' , tochar ( bs % npts ) write ( * , * ) ' ' do i = 1 , bs % npath write ( * , * ) '        path ' // tochar ( i ) // ': from ' // trim ( bs % symb_q_start ( i )) // ' to ' // trim ( bs % symb_q_end ( i )) opf = \"(1X,'  starting point: cartesian',3(F9.6,' '),'fractional',3(F9.6,' '))\" v1 = lo_chop ( uc % cartesian_to_fractional ( bs % segment ( i )% r1 , reciprocal = . true ., pbc = . false .) , lo_sqtol ) write ( * , opf ) bs % segment ( i )% r1 , v1 opf = \"(1X,'    ending point: cartesian',3(F9.6,' '),'fractional',3(F9.6,' '))\" v1 = lo_chop ( uc % cartesian_to_fractional ( bs % segment ( i )% r2 , reciprocal = . true ., pbc = . false .) , lo_sqtol ) write ( * , opf ) bs % segment ( i )% r2 , v1 enddo write ( * , * ) ' ' write ( * , \"(' ...            got the phonon bandstructure in ',F12.9,'s' )\" ) walltime () - t0 ! Dump things to files for plotting call bs % write_dispersive_property ( opts % enhet , 'frequency' , 'outfile.dispersion_relations' ,. false .) call bs % write_dispersive_property ( opts % enhet , 'groupvelocity' , 'outfile.group_velocities' ,. false .) if ( opts % gruneisen ) call bs % write_dispersive_property ( opts % enhet , 'gruneisen' , 'outfile.mode_gruneisen_parameters' ,. false .) endif end block path ! Get the full mesh and the density of states? dos : block real ( flyt ), dimension (:), allocatable :: temperatures real ( flyt ) :: f0 , f1 , f2 , f3 , t0 integer :: i , u , verb ! The dispersions along the path are done. Perhaps we want the full dispersion relations for something? if ( opts % fullmesh ) then if ( mw % talk ) then write ( * , * ) ' ' write ( * , * ) ' Calculating phonon dispersion across the Brillouin zone' endif ! Get a q-point mesh if ( opts % readqmesh ) then call lo_read_qmesh_from_file ( qp , uc , 'infile.qgrid.hdf5' , verbosity = opts % verbosity ) else if ( mw % talk ) write ( * , * ) '... generating q-mesh' select case ( opts % meshtype ) case ( 1 ) call lo_generate_qmesh ( qp , uc , opts % qgrid , 'monkhorst' , verbosity = opts % verbosity , timereversal = opts % timereversal ) case ( 2 ) call lo_generate_qmesh ( qp , uc , opts % qgrid , 'fft' , verbosity = opts % verbosity , timereversal = opts % timereversal ) case ( 3 ) call lo_generate_qmesh ( qp , uc , opts % qgrid , 'wedge' , verbosity = opts % verbosity , timereversal = opts % timereversal , mw = mw ) end select endif ! Get the full dispersion relations t0 = walltime () if ( uc % na . ge . 4 . and . mw % talk ) then verb = opts % verbosity + 2 else verb = opts % verbosity endif call dr % generate ( qp , fc , uc , verbosity = verb , timereversal = opts % timereversal , mpi_communicator = mw % comm ) endif ! Perhaps we want the phonon density of states and related things if ( opts % dos ) then t0 = walltime () if ( mw % talk . eqv . . false . ) then verb = 0 else verb = max ( 1 , opts % verbosity ) endif call pd % generate ( dr , qp , uc , verbosity = verb , integrationtype = opts % dosintegrationtype , adaptiveparameter = opts % sigma ,& ndos = opts % dospoints , mpi_communicator = mw % comm ) ! Dump it to file if ( mw % talk ) then call pd % write_to_file ( uc , opts % enhet , 'outfile.phonon_dos' ) call pd % write_to_hdf5 ( opts % enhet , 'outfile.phonon_dos.hdf5' ) endif ! Get the density-plot thing !if ( mw%talk ) call omega_vs_norm_q_density(qp,dr,uc) endif ! A positive number of temperatures means I should dump energy. I do this not in parallel. if ( opts % trangenpts . gt . 0 . and . mw % talk ) then if ( . not . opts % fullmesh ) then write ( * , * ) 'I screwed up the heuristics' stop endif write ( * , * ) '... calculating free energy' lo_allocate ( temperatures ( opts % trangenpts )) call lo_linspace ( opts % trangemin , opts % trangemax , temperatures ) ! dump some free energies and entropies write ( * , * ) '' write ( * , * ) '      T(K)     F(eV/atom)         S(eV/K/atom)       Cv(eV/K/atom)' u = open_file ( 'out' , 'outfile.free_energy' ) do i = 1 , opts % trangenpts f0 = temperatures ( i ) f1 = dr % phonon_free_energy ( f0 ) * lo_hartree_to_eV f2 = dr % phonon_entropy ( f0 ) * lo_hartree_to_eV f3 = dr % phonon_cv ( f0 ) * lo_hartree_to_eV !f4=dr%phonon_free_energy_classical(f0) if ( abs ( f1 - 12345678 9.0_flyt ) . lt . lo_tol ) then ! return NaN if I have imaginary frequencies write ( u , * ) f0 , ' NaN  NaN  NaN' !'  NaN' write ( * , * ) f0 , ' NaN  NaN  NaN' !'  NaN' else write ( u , \"(1X,F12.5,4(1X,E18.11))\" ) temperatures ( i ), f1 , f2 , f3 !,f4 write ( * , \"(1X,F12.5,4(1X,E18.11))\" ) temperatures ( i ), f1 , f2 , f3 !,f4 endif enddo close ( u ) endif end block dos ! Print some file and wrap it up wrapup : block ! Write everything on the grid to file, for some inexplicable reason. if ( opts % dumpgrid ) then ! small sanity check if ( . not . opts % fullmesh ) then write ( * , * ) 'I screwed up the heuristics' stop endif if ( opts % gruneisen ) then call dr % gruneisen ( qp , fct , uc , opts % verbosity ) endif ! actually write it if ( mw % talk ) then call dr % write_to_hdf5 ( qp , uc , 'outfile.grid_dispersions.hdf5' ) write ( * , * ) '... wrote data for the full grid' endif endif ! Dump everything to hdf5 if ( mw % talk ) then if ( opts % sortbands ) call bs % sort_bands () call bs % write_to_hdf5 ( uc , opts % enhet , 'outfile.dispersion_relations.hdf5' ) endif #ifdef AGRESSIVE_SANITY ! make a memory report if ( mw % talk ) then write ( * , * ) '' write ( * , * ) 'MEMORY DIAGNOSTICS (mean,max,min in MB)' endif mem_per_rank = 0.0_flyt mem_per_rank ( mw % r + 1 ) = uc % size_in_mem () * toMB call mpi_allreduce ( MPI_IN_PLACE , mem_per_rank , mw % n , MPI_DOUBLE_PRECISION , MPI_SUM , mw % comm , mw % error ) if ( mw % talk ) then write ( * , \"(1X,A,3(2X,F12.5))\" ) '                structure:' , lo_mean ( mem_per_rank ), maxval ( mem_per_rank ), minval ( mem_per_rank ) endif mem_per_rank = 0.0_flyt mem_per_rank ( mw % r + 1 ) = fc % size_in_mem () * toMB call mpi_allreduce ( MPI_IN_PLACE , mem_per_rank , mw % n , MPI_DOUBLE_PRECISION , MPI_SUM , mw % comm , mw % error ) if ( mw % talk ) then write ( * , \"(1X,A,3(2X,F12.5))\" ) '            forceconstant:' , lo_mean ( mem_per_rank ), maxval ( mem_per_rank ), minval ( mem_per_rank ) endif mem_per_rank = 0.0_flyt mem_per_rank ( mw % r + 1 ) = fct % size_in_mem () * toMB call mpi_allreduce ( MPI_IN_PLACE , mem_per_rank , mw % n , MPI_DOUBLE_PRECISION , MPI_SUM , mw % comm , mw % error ) if ( mw % talk ) then write ( * , \"(1X,A,3(2X,F12.5))\" ) ' thirdorder forceconstant:' , lo_mean ( mem_per_rank ), maxval ( mem_per_rank ), minval ( mem_per_rank ) endif mem_per_rank = 0.0_flyt mem_per_rank ( mw % r + 1 ) = qp % size_in_mem ( qp ) * toMB call mpi_allreduce ( MPI_IN_PLACE , mem_per_rank , mw % n , MPI_DOUBLE_PRECISION , MPI_SUM , mw % comm , mw % error ) if ( mw % talk ) then write ( * , \"(1X,A,3(2X,F12.5))\" ) '                   q-mesh:' , lo_mean ( mem_per_rank ), maxval ( mem_per_rank ), minval ( mem_per_rank ) endif mem_per_rank = 0.0_flyt mem_per_rank ( mw % r + 1 ) = bs % size_in_mem () * toMB call mpi_allreduce ( MPI_IN_PLACE , mem_per_rank , mw % n , MPI_DOUBLE_PRECISION , MPI_SUM , mw % comm , mw % error ) if ( mw % talk ) then write ( * , \"(1X,A,3(2X,F12.5))\" ) '            bandstructure:' , lo_mean ( mem_per_rank ), maxval ( mem_per_rank ), minval ( mem_per_rank ) endif mem_per_rank = 0.0_flyt mem_per_rank ( mw % r + 1 ) = dr % size_in_mem () * toMB call mpi_allreduce ( MPI_IN_PLACE , mem_per_rank , mw % n , MPI_DOUBLE_PRECISION , MPI_SUM , mw % comm , mw % error ) if ( mw % talk ) then write ( * , \"(1X,A,3(2X,F12.5))\" ) '              dispersions:' , lo_mean ( mem_per_rank ), maxval ( mem_per_rank ), minval ( mem_per_rank ) endif mem_per_rank = 0.0_flyt mem_per_rank ( mw % r + 1 ) = pd % size_in_mem () * toMB call mpi_allreduce ( MPI_IN_PLACE , mem_per_rank , mw % n , MPI_DOUBLE_PRECISION , MPI_SUM , mw % comm , mw % error ) if ( mw % talk ) then write ( * , \"(1X,A,3(2X,F12.5))\" ) '               phonon dos:' , lo_mean ( mem_per_rank ), maxval ( mem_per_rank ), minval ( mem_per_rank ) endif #endif if ( mw % talk ) then write ( * , * ) ' ' write ( * , * ) 'All done in ' , tochar ( walltime () - timer ), 's' endif call mw % destroy () end block wrapup end program","tags":"","loc":"sourcefile/main.f90~3.html","title":"main.f90 – TDEP"},{"text":"Programs atomic_distribution Source Code main.f90 Source Code #include \"precompilerdefinitions\" program atomic_distribution !!{!src/atomic_distribution/manual.md!} use konstanter , only : flyt use type_crystalstructure , only : lo_crystalstructure use type_mdsim , only : lo_mdsim use type_symmetrylist , only : lo_symlist use helpers , only : lo_mpi_helper use options , only : lo_opts use pairmapping use vectordist use pair_distribution use mean_square_displacement use timedistance_correlation use correlationfunction implicit none ! type ( lo_opts ) :: opts type ( lo_crystalstructure ) :: uc , ss type ( lo_mdsim ) :: sim type ( lo_symlist ) :: sl type ( lo_vectordist ) :: vd type ( lo_pairmapping ) :: pm type ( lo_pair_distribution ) :: pdf type ( lo_mean_square_displacement ) :: msd type ( lo_mpi_helper ) :: mw !type(lo_timedistance_correlation) :: tdc ! get command line arguments call opts % parse () call mw % init () ! read positions call uc % readfromfile ( 'infile.ucposcar' ) write ( * , * ) '... read unitcell' call ss % readfromfile ( 'infile.ssposcar' ) write ( * , * ) '... read supercell' ! Get all kinds of symmetry stuff if ( opts % cutoff . lt . 0.0_flyt ) then opts % cutoff = ss % maxcutoff () endif ! Get the pair symmetry stuff call sl % generate ( uc , ss , opts % cutoff , - 1.0_flyt , - 1.0_flyt , transposition = . false ., firstorder = . true ., polar = . false .) ! write(*,*) '... found '//tochar(sy%nun)//' unique atoms' ! do i=1,sy%nun !     write(*,*) '    atom ',i,uc%atomic_symbol( uc%species(sy%un(i)%atom_in_uc) ) ! enddo ! I know the number of unique atoms, and coordination shells. I need a reverse list, sort of. ! I need to know for each atom in the unit cell, and for each pair, which atoms to sum over ! and how they should transform call pm % setup_symmetry ( sl , uc , ss ) ! Also need the actual simulation call sim % read_from_file ( verbosity = 2 , stride = opts % stride ) ! First we calculate the symmetry-projected radial pair distribution function call pdf % bin ( ss , pm , sim , opts % nbin ) ! Write this to file call pdf % write_to_hdf5 () write ( * , * ) 'Wrote pair distribution function to file' ! Then we calculate the mean square displacement, could be useful call msd % generate ( ss , pm , sim ) call msd % write_to_hdf5 () call msd % write_to_plaintext ( pm , uc ) write ( * , * ) 'Wrote mean square displacement to file' ! ! Additionally, I like the time-distance correlation functions. Not exactly sure what they ! ! are good for, but it's interesting to look at. Only in the non-diffusive case for now. ! if ( opts%timedistance ) then !     if ( pdf%diffusion .eqv. .false. ) then !         call tdc%generate(pdf,uc,ss,pm,sim,opts%nbin) !         call tdc%write_to_hdf5() !     endif ! endif ! generate the vector distribution (only in case of no diffusion, this makes little sense if things are melted) if ( pdf % diffusion . eqv . . false . ) then call vd % generate ( pm , sim , opts % bintype , opts % transform , opts % nbin ) call vd % write_to_hdf5 ( pm ) else ! if it's melted, go with the probability density instead! write ( * , * ) 'Probability density function, but not yet. Nag on me to fix this.' call mw % destroy () stop endif ! So I decided to comment it instead of writing the manual. ! realspace velocity-velocity autocorrelation functions ! call cf%generate(uc,ss,pm,sim) ! call cf%write_to_plaintext(pm,uc) write ( * , * ) 'All done!' call mw % destroy () end program","tags":"","loc":"sourcefile/main.f90~4.html","title":"main.f90 – TDEP"},{"text":"Subroutines iso_tetrahedron_fft_oneqp threephonon_tetrahedron_fft_oneqp Source Code phononevents_tetrahedron.f90 Source Code !> Tetrahedron integration weights for isotope scattering, from one q-point subroutine iso_tetrahedron_fft_oneqp ( qp , dr , scq , gi1 , scsigma , blochlcorrections ) !> qpoint mesh !type(lo_fft_mesh), intent(in) :: qp class ( lo_qpoint_mesh ), intent ( in ) :: qp !> phonon dispersoins type ( lo_phonon_dispersions ), intent ( in ) :: dr !> current q-point type ( lo_iso2 ), intent ( inout ) :: scq !> current grid-index integer , intent ( in ) :: gi1 !> baseline smearing parameter real ( flyt ), intent ( in ) :: scsigma !> blochl corrections? logical , intent ( in ) :: blochlcorrections ! real ( flyt ), parameter :: thres_weight = lo_tiny integer , dimension ( 4 ) :: tetqpoints integer :: gi2 integer :: i , j , ii , b1 , b2 , i_gamma real ( flyt ), dimension ( 4 ) :: cval , wts1 , wts2 real ( flyt ) :: om1 , omthres , minc , maxc real ( flyt ), dimension (:,:,:), allocatable :: qpw real ( flyt ), dimension (:,:), allocatable :: omr2 real ( flyt ), dimension (:), allocatable :: omr1 lo_allocate ( omr1 ( dr % nb )) lo_allocate ( omr2 ( 4 , dr % nb )) lo_allocate ( qpw ( dr % nb , dr % nb , qp % nq_tot )) omthres = dr % omega_min * 0.2_flyt ! Calculate all integration weights for the relevant tetrahedra scq % gi1 = gi1 qpw = 0.0_flyt omr1 = dr % aq ( gi1 )% omega tetloop : do i = 1 , qp % ntet ! Grab frequencies do j = 1 , 4 gi2 = qp % tet ( i )% gridind ( j ) omr2 ( j ,:) = dr % aq ( gi2 )% omega tetqpoints ( j ) = gi2 enddo ! Add integration weights do b1 = 1 , dr % nb do b2 = 1 , dr % nb minc = lo_huge maxc =- lo_huge do j = 1 , 4 cval ( j ) = omr2 ( j , b2 ) minc = min ( minc , cval ( j )) maxc = max ( maxc , cval ( j )) enddo ! add a small delta for safety minc = minc - 3 * scsigma / 10 0.0_flyt maxc = maxc + 3 * scsigma / 10 0.0_flyt ! check if it's relevant om1 = omr1 ( b1 ) if ( om1 . gt . minc . and . om1 . lt . maxc . and . om1 . gt . omthres ) then ! Take care if it's completely degenerate if ( lo_stddev ( cval ) / om1 . lt . 1 E - 3_flyt ) then call lo_integration_weights_for_one_tetrahedron (& qp % tet ( i ), cval , om1 - scsigma / 20 0.0_flyt , wts1 , scsigma , blochlcorrections ) call lo_integration_weights_for_one_tetrahedron (& qp % tet ( i ), cval , om1 + scsigma / 20 0.0_flyt , wts2 , scsigma , blochlcorrections ) else call lo_integration_weights_for_one_tetrahedron (& qp % tet ( i ), cval , om1 - scsigma / 20 0.0_flyt , wts1 , scsigma , blochlcorrections ) call lo_integration_weights_for_one_tetrahedron (& qp % tet ( i ), cval , om1 + scsigma / 20 0.0_flyt , wts2 , scsigma , blochlcorrections ) endif ! sum up integration weights qpw ( b1 , b2 , tetqpoints ) = qpw ( b1 , b2 , tetqpoints ) + & ( wts1 + wts2 ) * 0.5_flyt endif enddo enddo enddo tetloop ! Set the integration weights for the acoustic branches to zero i_gamma =- 1 do i = 1 , qp % nq_tot if ( lo_sqnorm ( qp % ap ( i )% w ) . lt . lo_sqtol ) then i_gamma = i exit endif enddo if ( i_gamma . lt . 0 ) call lo_stop_gracefully ([ 'FFT mesh does not contain gamma' ], lo_exitcode_symmetry , __ FILE__ , __ LINE__ ) do b2 = 1 , dr % nb do b1 = 1 , dr % nb if ( dr % aq ( i_gamma )% omega ( b1 ) . lt . lo_freqtol . or . dr % aq ( i_gamma )% omega ( b2 ) . lt . lo_freqtol ) then qpw ( b1 , b2 , i_gamma ) = 0.0_flyt endif enddo enddo ! Store weights per q-point, and only the relevant q-points do b1 = 1 , dr % nb do b2 = 1 , dr % nb ! count q-points ii = 0 do i = 1 , qp % nq_tot if ( abs ( qpw ( b1 , b2 , i )) . gt . thres_weight ) then ii = ii + 1 endif enddo ! make some space scq % band ( b1 , b2 )% n = ii if ( scq % band ( b1 , b2 )% n . gt . 0 ) then lo_allocate ( scq % band ( b1 , b2 )% e ( ii )) endif ! store weights and indices ii = 0 do i = 1 , qp % nq_tot if ( abs ( qpw ( b1 , b2 , i )) . gt . thres_weight ) then ii = ii + 1 scq % band ( b1 , b2 )% e ( ii )% gi2 = i scq % band ( b1 , b2 )% e ( ii )% deltafunction = qpw ( b1 , b2 , i ) endif enddo enddo enddo lo_deallocate ( omr1 ) lo_deallocate ( omr2 ) lo_deallocate ( qpw ) end subroutine !> Tetrahedron integration weights for threephonon scattering, from one q-point subroutine threephonon_tetrahedron_fft_oneqp ( qp , dr , scq , gi1 , scsigma , blochlcorrections ) !> qpoint mesh !type(lo_fft_mesh), intent(in) :: qp class ( lo_qpoint_mesh ), intent ( in ) :: qp !> phonon dispersions type ( lo_phonon_dispersions ), intent ( in ) :: dr !> q-point in question type ( lo_3phqp2 ), intent ( inout ) :: scq !> grid-index in question integer , intent ( in ) :: gi1 !> baseline smearing real ( flyt ), intent ( in ) :: scsigma !> blochl corrections? logical , intent ( in ) :: blochlcorrections integer :: i , j , ii , jj , b1 , b2 , b3 integer :: gi2 , gi3 , i_gamma integer , dimension ( 3 ) :: dims integer , dimension ( 4 ) :: tetqpoints real ( flyt ), dimension (:,:,:,:), allocatable :: qpwp , qpwm real ( flyt ), dimension (:,:), allocatable :: omr2 , omr3 real ( flyt ), dimension (:), allocatable :: omr1 real ( flyt ), dimension ( 4 ) :: cval_p , cval_m , wts1 , wts2 real ( flyt ) :: om1 , omthres , minc_m , minc_p , maxc_m , maxc_p , wthres , sigmatol , deltaeps ! Some temporary space lo_allocate ( omr1 ( dr % nb )) lo_allocate ( omr2 ( 4 , dr % nb )) lo_allocate ( omr3 ( 4 , dr % nb )) lo_allocate ( qpwp ( dr % nb , dr % nb , dr % nb , qp % nq_tot )) lo_allocate ( qpwm ( dr % nb , dr % nb , dr % nb , qp % nq_tot )) ! smallest frequency allowed, should allow everything except acoustic modes at Gamma omthres = dr % omega_min * 0.5_flyt ! smallest weight to care about wthres = 1 E - 30_flyt !lo_tiny ! 1E-40_flyt ! Dimensions of q-point grid select type ( qp ) class is ( lo_fft_mesh ) dims = qp % griddensity class default write ( * , * ) 'Really need an fft grid for this' stop end select ! The reference q-point, q1 in q1+q2+q3=G scq % gi1 = gi1 ! Some tolerances sigmatol = scsigma / 3 0.0_flyt deltaeps = scsigma / 1 E2_flyt qpwp = 0.0_flyt qpwm = 0.0_flyt omr1 = dr % aq ( gi1 )% omega tetloop : do i = 1 , qp % ntet ! Grab frequencies do j = 1 , 4 gi2 = qp % tet ( i )% gridind ( j ) gi3 = fft_third_grid_index ( gi1 , gi2 , dims ) omr2 ( j ,:) = dr % aq ( gi2 )% omega omr3 ( j ,:) = dr % aq ( gi3 )% omega tetqpoints ( j ) = gi2 enddo ! Add integration weights do b1 = 1 , dr % nb do b2 = 1 , dr % nb do b3 = 1 , dr % nb minc_p = lo_huge maxc_p =- lo_huge minc_m = lo_huge maxc_m =- lo_huge do j = 1 , 4 cval_p ( j ) = omr3 ( j , b3 ) - omr2 ( j , b2 ) ! plus events cval_m ( j ) = omr3 ( j , b3 ) + omr2 ( j , b2 ) ! minus events minc_p = min ( minc_p , cval_p ( j )) minc_m = min ( minc_m , cval_m ( j )) maxc_p = max ( maxc_p , cval_p ( j )) maxc_m = max ( maxc_m , cval_m ( j )) enddo ! add a small delta for safety, to avid pathological cases minc_p = minc_p - sigmatol minc_m = minc_m - sigmatol maxc_p = maxc_p + sigmatol maxc_m = maxc_m + sigmatol ! check if it's relevant om1 = omr1 ( b1 ) if ( om1 . gt . minc_p . and . om1 . lt . maxc_p ) then !.and. om1 .gt. omthres ) then if ( blochlcorrections ) then wts1 = lo_LV_tetrahedron_weights ( cval_p , om1 , lo_freqtol , scsigma ) qpwp ( b1 , b2 , b3 , tetqpoints ) = qpwp ( b1 , b2 , b3 , tetqpoints ) + wts1 * qp % tet ( i )% weight else wts1 = 0.0_flyt wts2 = 0.0_flyt ! this plus event is relevant, store weights call lo_integration_weights_for_one_tetrahedron ( qp % tet ( i ), cval_p , om1 - deltaeps , wts1 , scsigma , blochlcorrections ) call lo_integration_weights_for_one_tetrahedron ( qp % tet ( i ), cval_p , om1 + deltaeps , wts2 , scsigma , blochlcorrections ) qpwp ( b1 , b2 , b3 , tetqpoints ) = qpwp ( b1 , b2 , b3 , tetqpoints ) + ( wts1 + wts2 ) * 0.5_flyt endif endif if ( om1 . gt . minc_m . and . om1 . lt . maxc_m ) then !.and. om1 .gt. omthres ) then if ( blochlcorrections ) then wts1 = lo_LV_tetrahedron_weights ( cval_m , om1 , lo_freqtol , scsigma ) qpwm ( b1 , b2 , b3 , tetqpoints ) = qpwm ( b1 , b2 , b3 , tetqpoints ) + wts1 * qp % tet ( i )% weight else ! this minus event is relevant, store weights wts1 = 0.0_flyt wts2 = 0.0_flyt call lo_integration_weights_for_one_tetrahedron ( qp % tet ( i ), cval_m , om1 - deltaeps , wts1 , scsigma , blochlcorrections ) call lo_integration_weights_for_one_tetrahedron ( qp % tet ( i ), cval_m , om1 + deltaeps , wts2 , scsigma , blochlcorrections ) qpwm ( b1 , b2 , b3 , tetqpoints ) = qpwm ( b1 , b2 , b3 , tetqpoints ) + ( wts1 + wts2 ) * 0.5_flyt endif endif enddo enddo enddo enddo tetloop i_gamma =- 1 do i = 1 , qp % nq_tot if ( lo_sqnorm ( qp % ap ( i )% w ) . lt . lo_sqtol ) then i_gamma = i exit endif enddo if ( i_gamma . lt . 0 ) call lo_stop_gracefully ([ 'FFT mesh does not contain gamma' ], lo_exitcode_symmetry , __ FILE__ , __ LINE__ ) do b3 = 1 , dr % nb do b2 = 1 , dr % nb do b1 = 1 , dr % nb if ( dr % aq ( i_gamma )% omega ( b1 ) . lt . lo_freqtol . or . & dr % aq ( i_gamma )% omega ( b2 ) . lt . lo_freqtol . or . & dr % aq ( i_gamma )% omega ( b3 ) . lt . lo_freqtol ) then qpwp ( b1 , b2 , b3 , i_gamma ) = 0.0_flyt qpwm ( b1 , b2 , b3 , i_gamma ) = 0.0_flyt endif enddo enddo enddo qpwp ( 1 : 3 , 1 : 3 , 1 : 3 , i_gamma ) = 0.0_flyt qpwm ( 1 : 3 , 1 : 3 , 1 : 3 , i_gamma ) = 0.0_flyt ! Store weights per q-point do b1 = 1 , dr % nb do b2 = 1 , dr % nb do b3 = 1 , dr % nb ! count q-points ii = 0 jj = 0 do i = 1 , qp % nq_tot if ( abs ( qpwp ( b1 , b2 , b3 , i )) . gt . wthres ) then ii = ii + 1 endif if ( abs ( qpwm ( b1 , b2 , b3 , i )) . gt . wthres ) then jj = jj + 1 endif enddo ! make some space scq % plus ( b1 , b2 , b3 )% n = ii scq % minus ( b1 , b2 , b3 )% n = jj if ( scq % plus ( b1 , b2 , b3 )% n . gt . 0 ) then lo_allocate ( scq % plus ( b1 , b2 , b3 )% e ( ii )) endif if ( scq % minus ( b1 , b2 , b3 )% n . gt . 0 ) then lo_allocate ( scq % minus ( b1 , b2 , b3 )% e ( jj )) endif ! store weights and indices ii = 0 jj = 0 do i = 1 , qp % nq_tot if ( abs ( qpwp ( b1 , b2 , b3 , i )) . gt . wthres ) then ii = ii + 1 gi2 = i scq % plus ( b1 , b2 , b3 )% e ( ii )% gi2 = gi2 scq % plus ( b1 , b2 , b3 )% e ( ii )% gi3 = fft_third_grid_index ( gi1 , gi2 , dims ) scq % plus ( b1 , b2 , b3 )% e ( ii )% deltafunction = qpwp ( b1 , b2 , b3 , i ) endif if ( abs ( qpwm ( b1 , b2 , b3 , i )) . gt . wthres ) then jj = jj + 1 gi2 = i scq % minus ( b1 , b2 , b3 )% e ( jj )% gi2 = gi2 scq % minus ( b1 , b2 , b3 )% e ( jj )% gi3 = fft_third_grid_index ( gi1 , gi2 , dims ) scq % minus ( b1 , b2 , b3 )% e ( jj )% deltafunction = qpwm ( b1 , b2 , b3 , i ) endif enddo enddo enddo enddo ! Cleanup lo_deallocate ( qpwp ) lo_deallocate ( qpwm ) lo_deallocate ( omr1 ) lo_deallocate ( omr2 ) lo_deallocate ( omr3 ) end subroutine","tags":"","loc":"sourcefile/phononevents_tetrahedron.f90.html","title":"phononevents_tetrahedron.f90 – TDEP"},{"text":"Programs thermal_conductivity Source Code main.f90 Source Code #include \"precompilerdefinitions\" program thermal_conductivity !!{!src/thermal_conductivity/manual.md!} use konstanter , only : flyt , lo_temperaturetol , lo_status , lo_kappa_au_to_SI use helpers , only : walltime , lo_mpi_helper , tochar , lo_linspace , lo_logspace , lo_mean , MPI_DOUBLE_PRECISION , MPI_IN_PLACE , MPI_SUM use type_crystalstructure , only : lo_crystalstructure use type_mdsim , only : lo_mdsim use type_forceconstant_secondorder , only : lo_forceconstant_secondorder use type_forceconstant_thirdorder , only : lo_forceconstant_thirdorder use type_qpointmesh , only : lo_qpoint_mesh , lo_generate_qmesh use type_phonon_dispersions , only : lo_phonon_dispersions use type_phonon_dos , only : lo_phonon_dos use dump_data , only : lo_dump_gnuplot_2d_real ! unique use options , only : lo_opts use scatteringstrengths , only : calculate_scattering_amplitudes use pbe , only : get_kappa , calculate_qs , get_selfconsistent_solution use phononevents , only : lo_threephononevents , lo_find_all_scattering_events use mfp , only : lo_mfp , get_cumulative_plots , write_cumulative_plots implicit none ! Standard, from libolle type ( lo_opts ) :: opts type ( lo_forceconstant_secondorder ) :: fc type ( lo_forceconstant_thirdorder ) :: fct type ( lo_phonon_dispersions ) :: dr type ( lo_phonon_dos ) :: pd type ( lo_crystalstructure ) :: uc class ( lo_qpoint_mesh ), allocatable :: qp type ( lo_mpi_helper ) :: mw ! Unique type ( lo_threephononevents ) :: sc type ( lo_mfp ) :: mf ! Small stuff real ( flyt ), dimension (:,:), allocatable :: thermal_cond real ( flyt ), dimension (:), allocatable :: temperatures ! timers real ( flyt ) :: timer_init , timer_count , timer_matrixelements , timer_scf real ( flyt ) :: timer_kappa , timer_qs , timer_cumulative , tt0 #ifdef AGRESSIVE_SANITY real ( flyt ), parameter :: toMB = 1.0_flyt / 102 4.0_flyt ** 2 real ( flyt ), dimension (:), allocatable :: mem_per_rank #endif ! Set up all harmonic properties. That involves reading all the input file, ! creating grids, getting the harmonic properties on those grids. initharmonic : block integer :: i , j ! Start MPI and timers call mw % init () #ifdef AGRESSIVE_SANITY ! make space for the thing that holds memory per rank lo_allocate ( mem_per_rank ( mw % n )) mem_per_rank = 0 #endif ! Get options call opts % parse () if ( mw % r . ne . 0 ) opts % verbosity = 0 tt0 = walltime () timer_init = walltime () timer_qs = 0.0_flyt timer_kappa = 0.0_flyt timer_scf = 0.0_flyt timer_cumulative = 0.0_flyt if ( mw % talk ) write ( * , * ) '... using ' , tochar ( mw % n ), ' MPI ranks' ! There is a bunch of stuff that all ranks need, first the unit cell: call uc % readfromfile ( 'infile.ucposcar' , verbosity = opts % verbosity ) call uc % classify ( 'wedge' , timereversal = opts % timereversal ) if ( mw % talk ) write ( * , * ) '... read unitcell poscar' ! Perhaps non-natural isotope distribution if ( opts % readiso ) then if ( mw % talk ) write ( * , * ) '... reading isotope distribution from file' call uc % readisotopefromfile () if ( mw % talk ) then do i = 1 , uc % na do j = 1 , uc % isotope ( i )% n write ( * , \"('    isotope: ',I2,' concentration: ',F8.5,' mass: ',F12.6)\" ) & j , uc % isotope ( i )% conc ( j ), uc % isotope ( i )% mass ( j ) enddo write ( * , \"('    element: ',A2,' mean mass: ',F12.6,' mass disorder parameter',F12.9)\" ) & trim ( uc % atomic_symbol ( uc % species ( i ) )), uc % isotope ( i )% mean_mass ,& uc % isotope ( i )% disorderparameter enddo endif elseif ( opts % verbosity . gt . 0 ) then do i = 1 , uc % na do j = 1 , uc % isotope ( i )% n write ( * , \"('    isotope: ',I2,' concentration: ',F8.5,' mass: ',F12.6)\" ) & j , uc % isotope ( i )% conc ( j ), uc % isotope ( i )% mass ( j ) enddo write ( * , \"('    element: ',A2,' mean mass: ',F12.6,' mass disorder parameter',F12.9)\" ) & trim ( uc % atomic_symbol ( uc % species ( i ) )), uc % isotope ( i )% mean_mass ,& uc % isotope ( i )% disorderparameter enddo endif ! Read the force constants call fc % readfromfile ( uc , 'infile.forceconstant' ) if ( mw % talk ) write ( * , * ) '... read second order forceconstant' call fct % readfromfile ( uc , 'infile.forceconstant_thirdorder' ) if ( mw % talk ) write ( * , * ) '... read third order forceconstant' ! Get q-point mesh call lo_generate_qmesh ( qp , uc , opts % qgrid , 'fft' , timereversal = opts % timereversal , nosym = . not . opts % qpsymmetry , verbosity = opts % verbosity ) ! Distribute the q-points over MPI call qp % divide_across_mpi ( mw % comm ) ! Get frequencies in the whole BZ if ( mw % talk ) then write ( * , * ) '... getting the full dispersion relations' endif call dr % generate ( qp , fc , uc , correctionlevel = 2 , timereversal = opts % timereversal , mpi_communicator = mw % comm , verbosity = opts % verbosity ) ! Also the phonon DOS, for diagnostics call pd % generate ( dr , qp , uc , opts % mfppts * 2 , opts % integrationtype , opts % sigma , opts % verbosity , mw % comm ) ! Make sure it's stable if ( dr % is_unstable ( qp ) ) then write ( * , * ) '' write ( * , * ) 'FOUND UNSTABLE MODES. WILL STOP NOW.' call mpi_barrier ( mw % comm , mw % error ) call mpi_finalize ( lo_status ) stop endif #ifdef AGRESSIVE_SANITY ! make an initial memory report if ( mw % talk ) then write ( * , * ) '' write ( * , * ) 'MEMORY DIAGNOSTICS (mean,max,min in MB)' endif mem_per_rank = 0.0_flyt mem_per_rank ( mw % r + 1 ) = uc % size_in_mem () * toMB call mpi_allreduce ( MPI_IN_PLACE , mem_per_rank , mw % n , MPI_DOUBLE_PRECISION , MPI_SUM , mw % comm , mw % error ) if ( mw % talk ) then write ( * , \"(1X,A,3(2X,F12.5))\" ) '      structure:' , lo_mean ( mem_per_rank ), maxval ( mem_per_rank ), minval ( mem_per_rank ) endif mem_per_rank = 0.0_flyt mem_per_rank ( mw % r + 1 ) = qp % size_in_mem ( qp ) * toMB call mpi_allreduce ( MPI_IN_PLACE , mem_per_rank , mw % n , MPI_DOUBLE_PRECISION , MPI_SUM , mw % comm , mw % error ) if ( mw % talk ) then write ( * , \"(1X,A,3(2X,F12.5))\" ) '         q-mesh:' , lo_mean ( mem_per_rank ), maxval ( mem_per_rank ), minval ( mem_per_rank ) endif mem_per_rank = 0.0_flyt mem_per_rank ( mw % r + 1 ) = dr % size_in_mem () * toMB call mpi_allreduce ( MPI_IN_PLACE , mem_per_rank , mw % n , MPI_DOUBLE_PRECISION , MPI_SUM , mw % comm , mw % error ) if ( mw % talk ) then write ( * , \"(1X,A,3(2X,F12.5))\" ) '    dispersions:' , lo_mean ( mem_per_rank ), maxval ( mem_per_rank ), minval ( mem_per_rank ) endif mem_per_rank = 0.0_flyt mem_per_rank ( mw % r + 1 ) = pd % size_in_mem () * toMB call mpi_allreduce ( MPI_IN_PLACE , mem_per_rank , mw % n , MPI_DOUBLE_PRECISION , MPI_SUM , mw % comm , mw % error ) if ( mw % talk ) then write ( * , \"(1X,A,3(2X,F12.5))\" ) '     phonon dos:' , lo_mean ( mem_per_rank ), maxval ( mem_per_rank ), minval ( mem_per_rank ) endif #endif ! now I have all harmonic things, stop the init timer timer_init = walltime () - timer_init end block initharmonic ! Get the integration weights and matrix elements weights_elements : block real ( flyt ) :: t0 t0 = walltime () timer_count = walltime () call lo_find_all_scattering_events ( sc , qp , dr , uc , mw , opts % sigma , opts % thres , opts % integrationtype ,& opts % correctionlevel , opts % mfp_max , opts % isotopescattering ) call mpi_barrier ( mw % comm , mw % error ) ! stop counting timer, start matrixelement timer timer_count = walltime () - timer_count timer_matrixelements = walltime () ! Calculate scattering amplitudes t0 = walltime () call calculate_scattering_amplitudes ( uc , qp , sc , dr , fct , mw ) call mpi_barrier ( mw % comm , mw % error ) ! stop matrix element timer, start some other timer timer_matrixelements = walltime () - timer_matrixelements if ( mw % talk ) write ( * , * ) 'Counted and got scattering amplitudes in ' , tochar ( walltime () - t0 ) end block weights_elements ! Make space and initialize everything to calculate thermal conductivity initkappa : block integer :: i ! Get thermal conductivity allocate ( thermal_cond ( 10 , opts % trangenpts )) thermal_cond = 0.0_flyt ! The temperature axis allocate ( temperatures ( opts % trangenpts )) if ( opts % logtempaxis ) then call lo_logspace ( opts % trangemin , opts % trangemax , temperatures ) else call lo_linspace ( opts % trangemin , opts % trangemax , temperatures ) endif ! Setup the mean-free-path vs kappa plots, as well as the thin-film plots ! how many points on the x-axis? mf % np = opts % mfppts ! how many temperature? mf % nt = opts % trangenpts ! one plot for each temperature allocate ( mf % temp ( mf % nt )) ! thin film conductivity !if ( opts%thinfilm ) then !    allocate(mf%film(mf%nt)) !endif ! Make some space to keep intermediate values do i = 1 , qp % nq_irr allocate ( dr % iq ( i )% p_plus ( dr % nb )) allocate ( dr % iq ( i )% p_minus ( dr % nb )) allocate ( dr % iq ( i )% p_iso ( dr % nb )) allocate ( dr % iq ( i )% qs ( dr % nb )) allocate ( dr % iq ( i )% linewidth ( dr % nb )) allocate ( dr % iq ( i )% F0 ( 3 , dr % nb )) allocate ( dr % iq ( i )% Fn ( 3 , dr % nb )) allocate ( dr % iq ( i )% mfp ( 3 , dr % nb )) allocate ( dr % iq ( i )% scalar_mfp ( dr % nb )) dr % iq ( i )% linewidth = 0.0_flyt dr % iq ( i )% p_plus = 0.0_flyt dr % iq ( i )% p_minus = 0.0_flyt dr % iq ( i )% p_iso = 0.0_flyt dr % iq ( i )% qs = 0.0_flyt dr % iq ( i )% F0 = 0.0_flyt dr % iq ( i )% Fn = 0.0_flyt dr % iq ( i )% mfp = 0.0_flyt dr % iq ( i )% scalar_mfp = 0.0_flyt enddo do i = 1 , qp % nq_tot allocate ( dr % aq ( i )% kappa ( 3 , 3 , dr % nb )) dr % aq ( i )% kappa = 0.0_flyt enddo end block initkappa ! Iteratively solve the BTE for each temperature. Additionally calculate mean free path plots ! and things like that. getkappa : block real ( flyt ), dimension ( 3 , 3 ) :: kappa , m0 real ( flyt ) :: t0 integer :: i if ( mw % talk ) then write ( * , * ) '' write ( * , * ) 'THERMAL CONDUCTIVITY' if ( opts % scfiterations . eq . 0 ) then write ( * , \"(3X,A11,6(1X,A14))\" ) 'Temperature' , 'kxx   ' , 'kyy   ' , 'kzz   ' , 'kxy   ' , 'kxz   ' , 'kyz   ' endif endif ! Main loop over temperatures to solve the BTE do i = 1 , opts % trangenpts ! I might get a silly tiny temperature: if ( temperatures ( i ) . lt . lo_temperaturetol ) then kappa = 0.0_flyt thermal_cond ( 1 , i ) = temperatures ( i ) thermal_cond ( 2 : 10 , i ) = 0.0_flyt cycle endif ! Scattering rates t0 = walltime () call calculate_qs ( qp , sc , dr , temperatures ( i ), mw ) timer_qs = timer_qs + walltime () - t0 ! Get the self-consistent solution call mpi_barrier ( mw % comm , mw % error ) if ( opts % scfiterations . gt . 0 ) then if ( mw % talk ) then write ( * , * ) '' write ( * , * ) 'Temperature: ' , tochar ( temperatures ( i )) write ( * , \"(1X,A4,6(1X,A14),2X,A10)\" ) 'iter' , 'kxx   ' , 'kyy   ' , 'kzz   ' , 'kxy   ' , 'kxz   ' , 'kyz   ' , 'DeltaF/F' endif t0 = walltime () call get_selfconsistent_solution ( sc , dr , qp , uc , mw , temperatures ( i ), opts % scfiterations , opts % scftol ) timer_scf = timer_scf + walltime () - t0 call get_kappa ( dr , qp , uc , temperatures ( i ), kappa ) m0 = kappa * lo_kappa_au_to_SI if ( mw % talk ) write ( * , \"(5X,6(1X,F14.4),2X,E10.3)\" ) m0 ( 1 , 1 ), m0 ( 2 , 2 ), m0 ( 3 , 3 ), m0 ( 1 , 2 ), m0 ( 1 , 3 ), m0 ( 2 , 3 ) else call get_kappa ( dr , qp , uc , temperatures ( i ), kappa ) m0 = kappa * lo_kappa_au_to_SI if ( mw % talk ) write ( * , \"(1X,F12.3,6(1X,F14.4),2X,E10.3)\" ) temperatures ( i ), m0 ( 1 , 1 ), m0 ( 2 , 2 ), m0 ( 3 , 3 ), m0 ( 1 , 2 ), m0 ( 1 , 3 ), m0 ( 2 , 3 ) endif ! Store thermal conductivity tensor thermal_cond ( 1 , i ) = temperatures ( i ) thermal_cond ( 2 , i ) = kappa ( 1 , 1 ) * lo_kappa_au_to_SI thermal_cond ( 3 , i ) = kappa ( 2 , 2 ) * lo_kappa_au_to_SI thermal_cond ( 4 , i ) = kappa ( 3 , 3 ) * lo_kappa_au_to_SI thermal_cond ( 5 , i ) = kappa ( 1 , 3 ) * lo_kappa_au_to_SI thermal_cond ( 6 , i ) = kappa ( 2 , 3 ) * lo_kappa_au_to_SI thermal_cond ( 7 , i ) = kappa ( 1 , 2 ) * lo_kappa_au_to_SI thermal_cond ( 8 , i ) = kappa ( 3 , 1 ) * lo_kappa_au_to_SI thermal_cond ( 9 , i ) = kappa ( 3 , 2 ) * lo_kappa_au_to_SI thermal_cond ( 10 , i ) = kappa ( 2 , 1 ) * lo_kappa_au_to_SI ! Calculate the cumulative plots t0 = walltime () call mpi_barrier ( mw % comm , mw % error ) call get_cumulative_plots ( mf % temp ( i ), qp , dr , pd , uc , opts % mfppts , temperatures ( i ), opts % sigma , kappa , mw ) ! And the thin film thing !if ( mw%r .eq. 0 .and. opts%thinfilm ) then !    call calculate_thinfilm_kappa(mf%film(i),qp,dr,mf%np,uc,temperatures(i),& !                                  [0.0_flyt,0.0_flyt,1.0_flyt],[0.0_flyt,1.0_flyt,0.0_flyt]) !endif timer_cumulative = timer_cumulative + walltime () - t0 call mpi_barrier ( mw % comm , mw % error ) enddo end block getkappa ! dump things to file and print timings finalize_and_write : block real ( flyt ) :: t0 ! Write thermal conductivity to file if ( mw % talk ) call lo_dump_gnuplot_2d_real ( thermal_cond , 'outfile.thermal_conductivity' ,& ylabel = '\\kappa W/mK' , xlabel = 'Temperature (K)' ) ! Write the cumulative kappa if ( mw % talk ) call write_cumulative_plots ( mf , pd , 'thz' ) ! Maybe dump data on a grid if ( mw % talk . and . opts % dumpgrid . and . opts % trangenpts . eq . 1 ) then write ( * , * ) '... dumping auxiliary data to files:' call dr % write_to_hdf5 ( qp , uc , 'outfile.grid_thermal_conductivity.hdf5' , temperatures ( 1 ) ) endif ! sum up the total time if ( mw % talk ) tt0 = walltime () - tt0 ! Print timings if ( mw % talk ) then t0 = timer_init + timer_count + timer_matrixelements + timer_qs + timer_kappa + timer_scf + timer_cumulative write ( * , * ) ' ' write ( * , * ) 'Timings:' write ( * , \"(A,F12.3,A,F7.3,A)\" ) '            initialization:' , timer_init , ' s, ' , real ( timer_init * 100 / tt0 ), '%' write ( * , \"(A,F12.3,A,F7.3,A)\" ) '       integration weights:' , timer_count , ' s, ' , real ( timer_count * 100 / tt0 ), '%' write ( * , \"(A,F12.3,A,F7.3,A)\" ) '           matrix elements:' , timer_matrixelements , ' s, ' , real ( timer_matrixelements * 100 / tt0 ), '%' write ( * , \"(A,F12.3,A,F7.3,A)\" ) '            QS calculation:' , timer_qs , ' s, ' , real ( timer_qs * 100 / tt0 ), '%' write ( * , \"(A,F12.3,A,F7.3,A)\" ) '                     kappa:' , timer_kappa , ' s, ' , real ( timer_kappa * 100 / tt0 ), '%' write ( * , \"(A,F12.3,A,F7.3,A)\" ) '          self consistency:' , timer_scf , ' s, ' , real ( timer_scf * 100 / tt0 ), '%' write ( * , \"(A,F12.3,A,F7.3,A)\" ) '          cumulative plots:' , timer_cumulative , ' s, ' , real ( timer_cumulative * 100 / tt0 ), '%' write ( * , \"(A,F12.3,A)\" ) '                     total:' , tt0 , ' seconds' endif end block finalize_and_write ! And we are done! call mpi_barrier ( mw % comm , mw % error ) call mpi_finalize ( lo_status ) end program","tags":"","loc":"sourcefile/main.f90~5.html","title":"main.f90 – TDEP"},{"text":"Subroutines threephonon_gaussian_fft_oneqp iso_gaussian_fft_oneqp Source Code phononevents_gaussian.f90 Source Code !> count three-phonons scattering events with gaussian smearing subroutine threephonon_gaussian_fft_oneqp ( qp , dr , scq , gi1 , scsigma , thres , adaptiveparameter , progressbar ) !type(lo_fft_mesh), intent(in) :: qp class ( lo_qpoint_mesh ), intent ( in ) :: qp type ( lo_phonon_dispersions ), intent ( in ) :: dr type ( lo_3phqp2 ), intent ( inout ) :: scq integer , intent ( in ) :: gi1 real ( flyt ), intent ( in ) :: scsigma , thres real ( flyt ), intent ( in ), optional :: adaptiveparameter logical , intent ( in ), optional :: progressbar ! integer :: i integer :: b1 , b2 , b3 integer :: gi2 , gi3 integer , dimension ( 3 ) :: dims integer , dimension (:,:,:), allocatable :: bc1 , bc2 real ( flyt ), dimension (:,:), allocatable :: vel2 , vel3 real ( flyt ), dimension (:), allocatable :: omr1 , omr2 , omr3 real ( flyt ) :: deltafunction , om1 , om2 , om3 , sigma , omthres logical :: adaptive , progress ! Adaptive or fixed gaussian if ( present ( adaptiveparameter ) ) then adaptive = . true . else adaptive = . false . endif ! Show a progress bar? if ( present ( progressbar ) ) then progress = progressbar else progress = . false . endif ! Threshold for small frequencies omthres = dr % omega_min * 0.2_flyt ! Some temporary space lo_allocate ( bc1 ( dr % nb , dr % nb , dr % nb )) lo_allocate ( bc2 ( dr % nb , dr % nb , dr % nb )) lo_allocate ( omr1 ( dr % nb )) lo_allocate ( omr2 ( dr % nb )) lo_allocate ( omr3 ( dr % nb )) lo_allocate ( vel2 ( 3 , dr % nb )) lo_allocate ( vel3 ( 3 , dr % nb )) ! grid dimensions select type ( qp ) class is ( lo_fft_mesh ) dims = qp % griddensity class default write ( * , * ) 'Really need an fft grid for this' stop end select ! Set the q-index and omega for q, and reset counters scq % gi1 = gi1 bc1 = 0 bc2 = 0 omr1 = dr % aq ( gi1 )% omega ! Do the actual counting if ( progress ) call lo_progressbar_init () do i = 1 , qp % nq_tot ! Get q'', This is q1+q2+q3=G gi2 = i gi3 = fft_third_grid_index ( gi1 , gi2 , dims ) ! omr2 = dr % aq ( gi2 )% omega omr3 = dr % aq ( gi3 )% omega vel2 = dr % aq ( gi2 )% vel vel3 = dr % aq ( gi3 )% vel ! Count events do b1 = 1 , dr % nb do b2 = 1 , dr % nb do b3 = 1 , dr % nb om1 = omr1 ( b1 ) om2 = omr2 ( b2 ) om3 = omr3 ( b3 ) ! plus-events, first get sigma if ( adaptive ) then sigma = qp % smearingparameter ( vel2 (:, b2 ) - vel3 (:, b3 ), scsigma , adaptiveparameter ) else sigma = scsigma endif if ( abs ( om1 - om3 + om2 ) . lt . thres * sigma ) then if ( om1 . gt . omthres . and . om2 . gt . omthres . and . om3 . gt . omthres ) then bc1 ( b1 , b2 , b3 ) = bc1 ( b1 , b2 , b3 ) + 1 endif endif ! minus-events if ( adaptive ) then sigma = qp % smearingparameter ( vel2 (:, b2 ) + vel3 (:, b3 ), scsigma , adaptiveparameter ) else sigma = scsigma endif if ( abs ( om1 - om2 - om3 ) . lt . thres * sigma ) then if ( om1 . gt . omthres . and . om2 . gt . omthres . and . om3 . gt . omthres ) then bc2 ( b1 , b2 , b3 ) = bc2 ( b1 , b2 , b3 ) + 1 endif endif enddo enddo enddo if ( progress ) call lo_progressbar ( ' ... counting scattering events' , i , qp % nq_tot * 2 ) enddo ! Allocate the storage do b1 = 1 , dr % nb do b2 = 1 , dr % nb do b3 = 1 , dr % nb scq % plus ( b1 , b2 , b3 )% n = bc1 ( b1 , b2 , b3 ) scq % minus ( b1 , b2 , b3 )% n = bc2 ( b1 , b2 , b3 ) if ( scq % plus ( b1 , b2 , b3 )% n . gt . 0 ) then lo_allocate ( scq % plus ( b1 , b2 , b3 )% e ( bc1 ( b1 , b2 , b3 ) )) endif if ( scq % minus ( b1 , b2 , b3 )% n . gt . 0 ) then lo_allocate ( scq % minus ( b1 , b2 , b3 )% e ( bc2 ( b1 , b2 , b3 ) )) endif enddo enddo enddo ! Count again and store things bc1 = 0 bc2 = 0 do i = 1 , qp % nq_tot ! This is q1+q2+q3=G gi2 = i gi3 = fft_third_grid_index ( gi1 , gi2 , dims ) omr2 = dr % aq ( gi2 )% omega omr3 = dr % aq ( gi3 )% omega vel2 = dr % aq ( gi2 )% vel vel3 = dr % aq ( gi3 )% vel do b1 = 1 , dr % nb do b2 = 1 , dr % nb do b3 = 1 , dr % nb om1 = omr1 ( b1 ) om2 = omr2 ( b2 ) om3 = omr3 ( b3 ) ! plus-events, first get sigma if ( adaptive ) then sigma = qp % smearingparameter ( vel2 (:, b2 ) - vel3 (:, b3 ), scsigma , adaptiveparameter ) else sigma = scsigma endif if ( abs ( om1 - om3 + om2 ) . lt . thres * sigma ) then if ( om1 . gt . omthres . and . om2 . gt . omthres . and . om3 . gt . omthres ) then deltafunction = lo_gauss ( om1 , om3 - om2 , sigma ) bc1 ( b1 , b2 , b3 ) = bc1 ( b1 , b2 , b3 ) + 1 scq % plus ( b1 , b2 , b3 )% e ( bc1 ( b1 , b2 , b3 ) )% gi2 = gi2 scq % plus ( b1 , b2 , b3 )% e ( bc1 ( b1 , b2 , b3 ) )% gi3 = gi3 scq % plus ( b1 , b2 , b3 )% e ( bc1 ( b1 , b2 , b3 ) )% deltafunction = deltafunction / qp % nq_tot endif endif ! minus-events if ( adaptive ) then sigma = qp % smearingparameter ( vel2 (:, b2 ) + vel3 (:, b3 ), scsigma , adaptiveparameter ) else sigma = scsigma endif if ( abs ( om1 - om2 - om3 ) . lt . thres * sigma ) then if ( om1 . gt . omthres . and . om2 . gt . omthres . and . om3 . gt . omthres ) then bc2 ( b1 , b2 , b3 ) = bc2 ( b1 , b2 , b3 ) + 1 deltafunction = lo_gauss ( om1 , om2 + om3 , sigma ) scq % minus ( b1 , b2 , b3 )% e ( bc2 ( b1 , b2 , b3 ) )% gi2 = gi2 scq % minus ( b1 , b2 , b3 )% e ( bc2 ( b1 , b2 , b3 ) )% gi3 = gi3 scq % minus ( b1 , b2 , b3 )% e ( bc2 ( b1 , b2 , b3 ) )% deltafunction = deltafunction / qp % nq_tot endif endif enddo enddo enddo if ( progress ) call lo_progressbar ( ' ... counting scattering events' , qp % nq_tot + i , qp % nq_tot * 2 ) enddo ! Cleanup lo_deallocate ( bc1 ) lo_deallocate ( bc2 ) lo_deallocate ( omr1 ) lo_deallocate ( omr2 ) lo_deallocate ( omr3 ) lo_deallocate ( vel2 ) lo_deallocate ( vel3 ) end subroutine !> Gaussian integration weights for isotope scattering, from one q-point subroutine iso_gaussian_fft_oneqp ( qp , dr , scq , gi1 , scsigma , thres , adaptiveparameter ) !> q-point mesh !type(lo_fft_mesh), intent(in) :: qp class ( lo_qpoint_mesh ), intent ( in ) :: qp !> phonon dispersions type ( lo_phonon_dispersions ), intent ( in ) :: dr !> qpoint in question type ( lo_iso2 ), intent ( inout ) :: scq !> gridindex in question integer , intent ( in ) :: gi1 !> baseline smearing real ( flyt ), intent ( in ) :: scsigma !> threshold to cut of gaussian real ( flyt ), intent ( in ) :: thres !> scaling factor for adaptive gaussian real ( flyt ), intent ( in ), optional :: adaptiveparameter ! integer :: i , ii , b1 , b2 integer :: gi2 integer , dimension (:,:), allocatable :: bandcounter real ( flyt ) :: deltafunction , om1 , om2 , omthres , sigma logical :: adaptive ! Fix or adaptive gaussian? if ( present ( adaptiveparameter ) ) then adaptive = . true . else adaptive = . false . endif ! Values for q omthres = dr % omega_min * 0.2_flyt scq % gi1 = gi1 ! count first lo_allocate ( bandcounter ( dr % nb , dr % nb )) bandcounter = 0 do i = 1 , qp % nq_tot gi2 = i do b1 = 1 , dr % nb do b2 = 1 , dr % nb om1 = dr % aq ( gi1 )% omega ( b1 ) om2 = dr % aq ( gi2 )% omega ( b2 ) if ( om1 . gt . omthres . and . om2 . gt . omthres ) then if ( adaptive ) then sigma = qp % smearingparameter ( dr % aq ( gi2 )% vel (:, b2 ), scsigma , adaptiveparameter ) else sigma = scsigma endif if ( abs ( om1 - om2 ) . lt . thres * sigma ) then bandcounter ( b1 , b2 ) = bandcounter ( b1 , b2 ) + 1 endif endif enddo enddo enddo ! Allocate storage do b1 = 1 , dr % nb do b2 = 1 , dr % nb scq % band ( b1 , b2 )% n = bandcounter ( b1 , b2 ) if ( scq % band ( b1 , b2 )% n . gt . 0 ) then lo_allocate ( scq % band ( b1 , b2 )% e ( scq % band ( b1 , b2 )% n )) endif enddo enddo ! Count again and store bandcounter = 0 do i = 1 , qp % nq_tot gi2 = i ! It should not bounce to itself, perhaps do b1 = 1 , dr % nb do b2 = 1 , dr % nb om1 = dr % aq ( gi1 )% omega ( b1 ) om2 = dr % aq ( gi2 )% omega ( b2 ) if ( om1 . gt . omthres . and . om2 . gt . omthres ) then if ( adaptive ) then sigma = qp % smearingparameter ( dr % aq ( gi2 )% vel (:, b2 ), scsigma , adaptiveparameter ) else sigma = scsigma endif if ( abs ( om1 - om2 ) . lt . thres * sigma ) then bandcounter ( b1 , b2 ) = bandcounter ( b1 , b2 ) + 1 ii = bandcounter ( b1 , b2 ) deltafunction = lo_gauss ( om1 , om2 , sigma ) scq % band ( b1 , b2 )% e ( ii )% deltafunction = deltafunction / qp % nq_tot scq % band ( b1 , b2 )% e ( ii )% gi2 = gi2 endif endif enddo enddo enddo lo_deallocate ( bandcounter ) end subroutine","tags":"","loc":"sourcefile/phononevents_gaussian.f90.html","title":"phononevents_gaussian.f90 – TDEP"},{"text":"Programs samples_from_md Source Code main.f90 Source Code #include \"precompilerdefinitions\" program samples_from_md !!{!src/samples_from_md/manual.md!} use konstanter , only : flyt , lo_huge , lo_tol use helpers , only : open_file , lo_mean , lo_stddev , lo_random_int , tochar , lo_seed_random_numbers , lo_progressbar_init ,& lo_progressbar , lo_shuffle_int_array use type_crystalstructure , only : lo_crystalstructure use type_mdsim , only : lo_mdsim !use dump_data use options , only : lo_opts implicit none type ( lo_opts ) :: opts type ( lo_mdsim ) :: sim type ( lo_crystalstructure ) :: p integer , dimension (:), allocatable :: sample , indices , testsample integer :: i , j , k , ii , jj , mindist , u real ( flyt ) :: f0 , f1 , f2 , t0 , t1 real ( flyt ) :: mean_ep , mean_ek , sigma_ep , sigma_ek real ( flyt ) :: mp0 , mp1 , mk0 , mk1 , sp0 , sp1 , sk0 , sk1 character ( len = 80 ) :: fname ! Get options call opts % parse () ! Seed random numbers call lo_seed_random_numbers () ! Get simulation call sim % read_from_file () ! List of all the samples allocate ( indices ( sim % nt )) do i = 1 , sim % nt indices ( i ) = i enddo ! Get a first sample allocate ( sample ( opts % n )) allocate ( testsample ( opts % n )) call random_number ( f0 ) sample ( 1 ) = floor ( f0 * sim % nt ) + 1 ! Get the minimum distance between two samples mindist = sim % nt / opts % n / 5 write ( * , * ) 'minimum distance' , mindist ! Choose the rest do i = 2 , opts % n j = select_ok_random_sample ( indices , sample ( 1 : i - 1 ), mindist ) sample ( i ) = j enddo ! Values for the entire simulation mean_ep = lo_mean ( sim % stat % ep ) mean_ek = lo_mean ( sim % stat % ek ) sigma_ep = lo_stddev ( sim % stat % ep ) sigma_ek = lo_stddev ( sim % stat % ek ) ! Starting values for monte-carlo run mp0 = lo_mean ( sim % stat % ep ( sample )) mk0 = lo_mean ( sim % stat % ek ( sample )) sp0 = lo_stddev ( sim % stat % ep ( sample )) sk0 = lo_stddev ( sim % stat % ek ( sample )) mp0 = abs ( mp0 - mean_ep ) mk0 = abs ( mk0 - mean_ek ) sp0 = abs ( sp0 - sigma_ep ) sk0 = abs ( sk0 - sigma_ek ) t0 = mp0 + mk0 + sp0 + sk0 write ( * , * ) 'Starting Monte-Carlo, distances:' write ( * , \"(9X,4(1X,A18))\" ) '|<Ep>-<Ep0>|' , '|<Ek>-<Ek0>|' , '|S(Ep)-S(Ep0)|' , '|S(Ek)-S(Ek0)|' write ( * , \"(1X,I8,4(1X,F18.6))\" ) 0 , mp0 , mk0 , sp0 , sk0 do i = 1 , opts % maxiter ! try a new configuration testsample = sample ! CHANGE PLACES k = lo_random_int ( opts % n ) j = select_ok_random_sample ( indices , sample , mindist ) testsample ( k ) = j ! Measure distances mp1 = lo_mean ( sim % stat % ep ( testsample )) mk1 = lo_mean ( sim % stat % ek ( testsample )) sp1 = lo_stddev ( sim % stat % ep ( testsample )) sk1 = lo_stddev ( sim % stat % ek ( testsample )) mp1 = abs ( mp1 - mean_ep ) mk1 = abs ( mk1 - mean_ek ) sp1 = abs ( sp1 - sigma_ep ) sk1 = abs ( sk1 - sigma_ek ) t1 = mp1 + mk1 + sp1 + sk1 ! MC check call random_number ( f2 ) if ( exp ( - ( t1 - t0 ) / opts % temp ) . gt . f2 ) then sample = testsample mp0 = mp1 mk0 = mk1 sp0 = sp1 sk0 = sk1 t0 = t1 write ( * , \"(1X,I8,4(1X,F18.6))\" ) i , mp0 , mk0 , sp0 , sk0 if ( t0 . lt . lo_tol ) exit endif enddo write ( * , * ) ' ' write ( * , * ) ' Results of Monte-Carlo run ' write ( * , \"('                 ',4(1X,A18))\" ) '<Ep>' , '<Ek>' , 'Sigma(Ep)' , 'Sigma(Ek)' write ( * , \"('Full simulation:',4(1X,F18.6))\" ) & lo_mean ( sim % stat % ep ), lo_mean ( sim % stat % ek ), lo_stddev ( sim % stat % ep ), lo_stddev ( sim % stat % ek ) write ( * , \"('        Samples:',4(1X,F18.6))\" ) & lo_mean ( sim % stat % ep ( sample )), lo_mean ( sim % stat % ek ( sample )), lo_stddev ( sim % stat % ep ( sample )), lo_stddev ( sim % stat % ek ( sample )) ! Find the minimum, maximum and mean distance between two samples ii = 0 jj = 1000000000 f0 = 0.0_flyt do i = 1 , opts % n f1 = lo_huge do j = 1 , opts % n if ( i . ne . j ) then jj = min ( abs (( sample ( i ) - sample ( j ))), jj ) f1 = min ( abs (( sample ( i ) - sample ( j )) * 1.0_flyt ), f1 ) endif enddo ii = max ( floor ( f1 ), ii ) f0 = f0 + f1 enddo f0 = f0 / opts % n write ( * , * ) '  Max distance:' , ii write ( * , * ) '  Min distance:' , jj write ( * , * ) ' Mean distance:' , int ( f0 ) ! write the samples p = sim % crystalstructure call lo_shuffle_int_array ( sample ) do i = 1 , opts % n p % r = sim % r (:,:, sample ( i )) p % v = sim % v (:,:, sample ( i )) p % info % title = 'sample ' // tochar ( sample ( i ), 7 ) fname = 'sample' // tochar ( i , 5 ) select case ( opts % output_format ) case ( 1 ) ! VASP call p % writetofile ( fname , opts % output_format ,. true .) case ( 2 ) ! Abinit call p % writetofile ( fname , opts % output_format ,. true .) case default write ( * , * ) 'Output format not fixe yet' stop end select enddo ! and the energies and stuff of the samples u = open_file ( 'out' , 'outfile.stat_sample' ) do j = 1 , opts % n i = sample ( j ) write ( u , \"(I6,' ',13(2X,EN16.7))\" ) & i , i * sim % ts , sim % stat % et ( i ), sim % stat % ep ( i ), sim % stat % ek ( i ), sim % stat % t ( i ), sim % stat % p ( i ), sim % stat % stress (:, i ) enddo close ( u ) contains !> choose a sample, but not too stupidly integer function select_ok_random_sample ( indices , forbidden , mindist ) integer , dimension (:), intent ( in ) :: indices , forbidden integer , intent ( in ) :: mindist ! integer :: i , ii , j , l , nt , nf nf = size ( forbidden , 1 ) nt = size ( indices , 1 ) do ii = 1 , 100 i = lo_random_int ( nt ) l = 0 do j = 1 , nf if ( abs ( indices ( i ) - indices ( forbidden ( j ))) . le . mindist ) l = l + 1 enddo if ( l . eq . 0 ) exit enddo select_ok_random_sample = i end function end program","tags":"","loc":"sourcefile/main.f90~6.html","title":"main.f90 – TDEP"},{"text":"Subroutines generate kramer_kronig_transform_to_get_real_part Source Code phonondamping_generation.f90 Source Code !> Generate the self-energy at a single q-point subroutine generate ( se , qpoint , ompoint , uc , fc , fct , fcf , qp , dr , opts , mw ) !> self energy class ( lo_phonon_selfenergy ), intent ( out ) :: se !> qpoint of interest class ( lo_qpoint ), intent ( in ) :: qpoint !> harmonic properties at this q-point type ( lo_phonon_dispersions_qpoint ), intent ( in ) :: ompoint !> crystal structure type ( lo_crystalstructure ), intent ( in ) :: uc !> second order force constant type ( lo_forceconstant_secondorder ), intent ( inout ) :: fc !> third order force constant type ( lo_forceconstant_thirdorder ), intent ( in ) :: fct !> fourth order force constant type ( lo_forceconstant_fourthorder ), intent ( in ) :: fcf !> q-point mesh class ( lo_qpoint_mesh ), intent ( in ) :: qp !> harmonic properties on this mesh type ( lo_phonon_dispersions ), intent ( in ) :: dr !> all settings type ( lo_opts ), intent ( in ) :: opts !> MPI communicator type ( lo_mpi_helper ), intent ( inout ) :: mw type ( lo_listofscatteringrates ) :: sr ! First thing to do is to initialize all arrays, and set all options setopts : block integer :: i se % nf = opts % nf ! Number of points on the energy axis se % nb = uc % na * 3 ! Number of bands se % sigma = opts % sigma * dr % default_smearing () ! Baseline fix smearing parameter se % adaptiveparameter = opts % sigma ! Scaling for adaptive gaussian se % integrationtype = opts % integrationtype ! How to integrate se % blochlcorrections = . false . ! dunno se % verbosity = opts % verbosity ! How much to talk se % isotope = opts % isotopescattering ! isotope scattering se % thirdorder = opts % thirdorder ! threephonon term se % fourthorder = opts % fourthorder ! fourphonon term se % dos = opts % phonondos ! dunno se % slightsmear = opts % slightsmearing ! smear things a little little bit. se % diagonal = opts % diagonal ! calculate only the diagonal part of the self-energy ! Make space for all the necessary arrays if ( allocated ( se % faxis ) ) deallocate ( se % faxis ) if ( allocated ( se % intensityaxis ) ) deallocate ( se % intensityaxis ) if ( allocated ( se % im_3ph ) ) deallocate ( se % im_3ph ) if ( allocated ( se % im_iso ) ) deallocate ( se % im_iso ) if ( allocated ( se % re_3ph ) ) deallocate ( se % re_3ph ) if ( allocated ( se % re_4ph ) ) deallocate ( se % re_4ph ) if ( allocated ( se % intensity ) ) deallocate ( se % intensity ) !        if ( allocated(se%im_nd) )          deallocate(se%im_nd) !        if ( allocated(se%re_nd) )          deallocate(se%re_nd) allocate ( se % faxis ( se % nf )) allocate ( se % intensityaxis ( se % nf )) allocate ( se % im_3ph ( se % nf , se % nb )) allocate ( se % im_iso ( se % nf , se % nb )) allocate ( se % re_3ph ( se % nf , se % nb )) allocate ( se % re_4ph ( se % nf , se % nb )) allocate ( se % intensity ( se % nf , se % nb )) !        allocate(se%im_nd(se%nf,se%nb,se%nb)) !        allocate(se%re_nd(se%nf,se%nb,se%nb)) ! And set the to appropriate values se % im_3ph = 0.0_flyt se % im_iso = 0.0_flyt se % re_3ph = 0.0_flyt se % re_4ph = 0.0_flyt !        se%re_nd=0.0_flyt !        se%im_nd=0.0_flyt se % intensity = 0.0_flyt call lo_linspace ( 0.0_flyt , 2.1_flyt * dr % omega_max , se % faxis ) call lo_linspace ( 0.0_flyt , opts % maxf * dr % omega_max , se % intensityaxis ) ! Store the harmonic properties, and the q-point se % q % w = qpoint % w se % q % v = qpoint % v call lo_get_small_group_of_qpoint ( se % q , uc ) se % p = ompoint ! Now things should be clean and nice. Maybe say what we are about to do? if ( se % verbosity . gt . 1 ) then write ( * , * ) '         liso:' , se % isotope write ( * , * ) '  lthirdorder:' , se % thirdorder write ( * , * ) ' lfourthorder:' , se % fourthorder write ( * , * ) '          dos:' , se % dos write ( * , * ) '  slightsmear:' , se % slightsmear write ( * , * ) '        sigma:' , se % sigma * lo_frequency_Hartree_to_THz write ( * , * ) '  temperature: ' , tochar ( opts % temperature ), ' K' write ( * , * ) '  frequencies:' do i = 1 , dr % nb write ( * , * ) '    mode ' , tochar ( i , - 3 ), ', omega: ' , tochar ( se % p % omega ( i ) * lo_frequency_Hartree_to_THz , 6 ), ' THz' enddo endif ! Divide everything over MPI. Right now, I only divide over qpoint I think. if ( qp % mpi % initialized . eqv . . false . ) then write ( * , * ) 'q-grid not distributed over MPI' stop endif end block setopts ! Now calculate all the matrix elements call sr % generate ( se % q , se % p , qp , dr , uc , fc , fct , se % verbosity , se % isotope , se % thirdorder , mw ) ! Start to actually calculate stuff, isotope things first if ( se % isotope ) then select case ( se % integrationtype ) case ( 1 ) call isotope_imaginary_selfenergy_gaussian ( qp , dr , opts % temperature , se , sr , mw ) case ( 2 ) call isotope_imaginary_selfenergy_gaussian ( qp , dr , opts % temperature , se , sr , mw ) case ( 3 ) se % blochlcorrections = . false . call isotope_imaginary_selfenergy_tetrahedron ( qp , dr , opts % temperature , se , sr , mw ) case ( 4 ) se % blochlcorrections = . true . call isotope_imaginary_selfenergy_tetrahedron ( qp , dr , opts % temperature , se , sr , mw ) end select endif ! Then three-phonon things if ( se % thirdorder ) then select case ( se % integrationtype ) case ( 1 ) call threephonon_imaginary_selfenergy_gaussian ( se , sr , qp , dr , opts % temperature , mw ) case ( 2 ) call threephonon_imaginary_selfenergy_gaussian ( se , sr , qp , dr , opts % temperature , mw ) case ( 3 ) se % blochlcorrections = . false . call threephonon_imaginary_selfenergy_tetrahedron ( qp , sr , dr , opts % temperature , se , mw ) case ( 4 ) se % blochlcorrections = . true . call threephonon_imaginary_selfenergy_tetrahedron ( qp , sr , dr , opts % temperature , se , mw ) end select endif ! Maybe fourthorder things if ( se % fourthorder ) then fourthorder : block real ( flyt ), dimension (:), allocatable :: delta integer :: j allocate ( delta ( dr % nb )) call fourphonon_selfenergy ( se % q , se % p , qp , opts % temperature , dr , uc , fc , fcf , delta , mw , se % verbosity ) do j = 1 , se % nb se % re_4ph (:, j ) = delta ( j ) se % re_4ph ( 1 , j ) = 0.0_flyt enddo deallocate ( delta ) end block fourthorder endif !> finalize to ensure that it's reasonable. sanity : block real ( flyt ) :: f0 , f1 integer :: i , j ! Make sure the selfenergy is zero where it's supposed to be do j = 1 , se % nb do i = 1 , se % nf if ( se % im_3ph ( i , j ) . lt . 0.0_flyt ) se % im_3ph ( i , j ) = 0.0_flyt if ( se % im_iso ( i , j ) . lt . 0.0_flyt ) se % im_iso ( i , j ) = 0.0_flyt enddo enddo ! zero at zero se % im_3ph ( 1 ,:) = 0.0_flyt se % im_iso ( 1 ,:) = 0.0_flyt ! Do a slight smearing of the imaginary selfenergy, it can become ! really spiky sometimes. if ( se % slightsmear ) then do j = 1 , se % nb if ( se % thirdorder ) then f0 = lo_trapezoid_integration ( se % faxis , se % im_3ph (:, j )) if ( f0 * se % nf . lt . lo_freqtol ) cycle call slightsmearing ( se % im_3ph (:, j ), 1 ) se % im_3ph (:, j ) = se % im_3ph (:, j ) * f0 / lo_trapezoid_integration ( se % faxis , se % im_3ph (:, j )) endif ! if ( se % isotope ) then f0 = lo_trapezoid_integration ( se % faxis , se % im_iso (:, j )) if ( f0 * se % nf . lt . lo_freqtol ) cycle call slightsmearing ( se % im_iso (:, j ), 1 ) se % im_iso (:, j ) = se % im_iso (:, j ) * f0 / lo_trapezoid_integration ( se % faxis , se % im_iso (:, j )) endif se % im_3ph ( 1 , j ) = 0.0_flyt se % im_iso ( 1 , j ) = 0.0_flyt enddo endif end block sanity ! Kramer-Kronig transform the imaginary to get the real part call kramer_kronig_transform_to_get_real_part ( se ) ! Add the isotope part do the non-diagonal self-energy !    do i=1,se%nf !        do j=1,se%nb !            se%im_nd(i,j,j)=se%im_nd(i,j,j)+se%im_iso(i,j) !        enddo !    enddo !    ! and maybe the fourthorder !    if ( se%fourthorder ) then !        if ( se%diagonal ) then !            do i=1,se%nf !                do j=1,se%nb !                    se%re_nd(i,j,j)= se%re_nd(i,j,j)+se%re_4ph(i,j) !                enddo !            enddo !        else !            do i=1,se%nf !                se%re_nd(i,:,:)=se%re_nd(i,:,:)+nddelta !            enddo !        endif !    endif end subroutine !> transform the imaginary part to the real part subroutine kramer_kronig_transform_to_get_real_part ( se ) !> selfenergy type ( lo_phonon_selfenergy ), intent ( inout ) :: se ! integer :: i , j , j1 , j2 real ( flyt ), dimension (:), allocatable :: x , y real ( flyt ) :: sig allocate ( x ( se % nf ), y ( se % nf )) sig = ( se % faxis ( 2 ) - se % faxis ( 1 )) * lo_sqtol x = se % faxis do i = 1 , se % nf do j = 1 , se % nb y = se % im_3ph (:, j ) y = y * x !y=real(y/(x(i)**2-x**2+lo_imag*sig) ) y = real ( y / ( x ( i ) ** 2 - x ** 2 + lo_imag * sig ) ) !y(i)=0.0_flyt se % re_3ph ( i , j ) = lo_trapezoid_integration ( x , y ) * 2.0_flyt / lo_pi enddo enddo !    se%re_nd=0.0_flyt !    if ( se%diagonal ) then !        do j=1,se%nb !            se%re_nd(:,j,j)=se%re_3ph(:,j) !        enddo !    else !        do i=1,se%nf !            do j1=1,se%nb !            do j2=1,se%nb !                y=se%im_nd(:,j1,j2) !                y=y*x !                y=real(y/(x(i)**2-x**2+lo_imag*sig) ) !                !y(i)=0.0_flyt !                se%re_nd(i,j1,j2)=lo_trapezoid_integration(x,y)*2.0_flyt/lo_pi !            enddo !            enddo !        enddo !    endif deallocate ( x , y ) end subroutine","tags":"","loc":"sourcefile/phonondamping_generation.f90.html","title":"phonondamping_generation.f90 – TDEP"},{"text":"Subroutines get_thermally_broadened_intensity_along_path Source Code phonondamping_thermalpath.f90 Source Code !> calculate the intensity along a path subroutine get_thermally_broadened_intensity_along_path ( bs , uc , fc , fct , fcf , qp , dr , loto , opts , mw , lsmpi ) !> the bandstructure type ( lo_phonon_bandstructure ), intent ( inout ) :: bs !> crystal structure type ( lo_crystalstructure ), intent ( inout ) :: uc !> second order force constant type ( lo_forceconstant_secondorder ), intent ( in ) :: fc !> third order force constant type ( lo_forceconstant_thirdorder ), intent ( in ) :: fct !> fourth order force constant type ( lo_forceconstant_fourthorder ), intent ( in ) :: fcf !> q-point mesh type ( lo_monkhorst_pack_mesh ), intent ( in ) :: qp !> harmonic properties on this mesh type ( lo_phonon_dispersions ), intent ( in ) :: dr !> electrostatic corrections type ( lo_loto ), intent ( in ) :: loto !> all settings type ( lo_opts ), intent ( in ) :: opts !> mpi communicator type ( lo_mpiinfo ), intent ( in ) :: mw !> mpi helper type ( lo_lsmpi ), intent ( in ) :: lsmpi type ( lo_phonon_selfenergy ) :: se !real(flyt), dimension(:,:,:), allocatable :: rebuf,imbuf,dumbuf !real(flyt), dimension(:,:), allocatable :: intbuf,thintbuf,lwbuf,shbuf,kernel !real(flyt), dimension(:), allocatable :: dum !real(flyt), dimension(3) :: qv1,qv2 !real(flyt), dimension(2) :: lsintx,lsinty !real(flyt) :: t0,f0,f1,f2 !complex(flyt) :: c0,c1,c2 !integer :: q1,nb,lqp,i,j,path,ii,jj,k,nkern,iii,jjj type ( lo_phonon_dispersions_qpoint ) :: ompoint type ( lo_qpoint ) :: qpoint real ( flyt ), dimension (:,:), allocatable :: q_in_sphere , intbuf1 , intbuf2 real ( flyt ), dimension (:,:), allocatable :: spf1 real ( flyt ), dimension ( 3 ) :: v0 real ( flyt ) :: sigma_q , sigma_e , f0 , f1 , t0 integer :: q1 , q2 , b1 , i , j , k , l , lqp integer :: nspherepoints logical :: onlyharmonic call lo_seed_random_numbers () sigma_q = 0.015_flyt sigma_e = 0.1 * lo_twopi * 1 E12_flyt !dr%default_smearing() onlyharmonic = . true . t0 = walltime () ! Get some points on a sphere nspherepoints = 1000 !400 getpointsonsphere : block real ( flyt ), dimension (:,:), allocatable :: dum real ( flyt ), dimension ( 3 ) :: v0 integer :: ctr ! lo_allocate ( q_in_sphere ( 3 , nspherepoints )) lo_allocate ( dum ( 3 , nspherepoints )) q_in_sphere = 0.0_flyt dum = 0.0_flyt if ( mw % r . eq . 0 ) then q_in_sphere = 0.0_flyt ctr = 0 do call random_number ( v0 ) v0 = 2.0_flyt * ( v0 - 0.5_flyt ) if ( lo_sqnorm ( v0 ) . gt . 1.0_flyt ) cycle ctr = ctr + 1 dum (:, ctr ) = v0 if ( ctr . eq . nspherepoints ) exit enddo ! make the sphere 3 sigmas large dum = dum * 3 * sigma_q dum (:, 1 ) = 0.0_flyt !do i=1,size(dum,2) !    write(*,*) i,dum(:,i) !enddo endif ! make sure all ranks have this call mpi_allreduce ( dum , q_in_sphere , 3 * nspherepoints , MPI_DOUBLE_PRECISION , MPI_SUM , mw % comm , mw % error ) end block getpointsonsphere if ( onlyharmonic ) then se % nf = opts % nf lo_allocate ( se % intensityaxis ( se % nf )) call lo_linspace ( 0.0_flyt , opts % maxf * dr % omega_max , se % intensityaxis ) endif ! Make some space for stuff lo_allocate ( spf1 ( se % nf , dr % nb )) lo_allocate ( intbuf1 ( bs % nptot , se % nf )) lo_allocate ( intbuf2 ( bs % nptot , se % nf )) intbuf1 = 0.0_flyt intbuf2 = 0.0_flyt ! Do the entire brutal calculation: if ( mw % talk ) call lo_progressbar_init () do lqp = 1 , lsmpi % nq q1 = lsmpi % ind ( lqp ) do q2 = 1 , nspherepoints ! Get the harmonic stuff v0 = bs % q ( q1 )% v + q_in_sphere (:, q2 ) call harmonic_things_at_single_q ( v0 , uc , fc , loto , qpoint , ompoint ) ! Get the raw lineshapes if ( onlyharmonic ) then ! Get a fake lineshape, just from the experimental energyresolution or something do b1 = 1 , dr % nb do i = 1 , se % nf spf1 ( i , b1 ) = lo_gauss ( ompoint % omega ( b1 ), se % intensityaxis ( i ), sigma_e ) enddo enddo else ! Get the actual lineshape stuff write ( * , * ) 'Actual lineshape not done yet' stop endif ! Add it together f0 = lo_gauss ( 0.0_flyt , norm2 ( q_in_sphere (:, q2 )), sigma_q ) do b1 = 1 , dr % nb intbuf1 ( q1 ,:) = intbuf1 ( q1 ,:) + f0 * spf1 (:, b1 ) do i = 1 , se % nf f1 = se % intensityaxis ( i ) !max(dr%omega_max/50.0_flyt,se%intensityaxis(i)) spf1 ( i , b1 ) = spf1 ( i , b1 ) * ( 1 + lo_planck ( opts % temperature , f1 )) enddo intbuf2 ( q1 ,:) = intbuf2 ( q1 ,:) + f0 * spf1 (:, b1 ) * ompoint % thermal_prefactor ( b1 ) enddo enddo if ( mw % talk ) then call lo_progressbar ( ' ... broadened spectral function' , lqp , lsmpi % nq , walltime () - t0 ) endif enddo lo_allocate ( bs % intensity ( bs % nptot , se % nf )) lo_allocate ( bs % intensity_with_prefactor ( bs % nptot , se % nf )) lo_allocate ( bs % faxis ( se % nf )) bs % intensity = 0.0_flyt bs % intensity_with_prefactor = 0.0_flyt bs % faxis = se % intensityaxis call mpi_allreduce ( intbuf1 , bs % intensity , bs % nptot * opts % nf , MPI_DOUBLE_PRECISION , MPI_SUM , mw % comm , mw % error ) call mpi_allreduce ( intbuf2 , bs % intensity_with_prefactor , bs % nptot * opts % nf , MPI_DOUBLE_PRECISION , MPI_SUM , mw % comm , mw % error ) lo_deallocate ( intbuf1 ) lo_deallocate ( intbuf2 ) if ( mw % r . eq . 0 ) then call bs % write_intensity ( opts % enhet , logscale = . true .) endif !stop !    t0=mpi_wtime() !    ! Make space for linewidths !    do q1=1,bs%nptot !        allocate(bs%p(q1)%linewidth(bs%nb)) !        allocate(bs%p(q1)%shift(bs%nb)) !        allocate(bs%p(q1)%threephononphasespace(bs%nb)) !        allocate(bs%p(q1)%thermal_prefactor(bs%nb)) !    enddo !    ! Space for intensity !    allocate(bs%intensity(bs%nptot,opts%nf)) !    allocate(bs%intensity_with_prefactor(bs%nptot,opts%nf)) !    allocate(bs%selfenergy_real(bs%nptot,opts%nf,dr%nb)) !    allocate(bs%selfenergy_imag(bs%nptot,opts%nf,dr%nb)) ! !    ! Calculate the prefactors !    do q1=1,bs%nptot !    do i=1,bs%nb !        f0=0.0_flyt !        do j=1,uc%na !            f1=dot_product(lo_twopi*bs%q(q1)%v,uc%rcart(:,j)) !            c0=dcmplx( cos(f1), sin(f1) ) !            ii=(j-1)*3+1 !            jj=j*3 !            c1=dot_product(lo_twopi*bs%q(q1)%v,bs%p(q1)%egv(ii:jj,i)) !            c2=c0*c1*uc%inelastic_neutron_cross_section(j) !            f0=f0+abs(conjg(c2)*c2) !        enddo !        bs%p(q1)%thermal_prefactor(i)=f0 !    enddo !    enddo ! !    bs%intensity=0.0_flyt !    bs%intensity_with_prefactor=0.0_flyt !    bs%selfenergy_real=0.0_flyt !    bs%selfenergy_imag=0.0_flyt ! !    ! Dump some general info !    if ( mw%talk ) then !        write(*,*) '        isotope:',opts%isotopescattering !        write(*,*) '    threephonon:',opts%thirdorder !        write(*,*) '     fourphonon:',opts%fourthorder !        write(*,*) '           loto:',opts%loto !        write(*,*) 'integrationtype:',opts%integrationtype !    endif ! !    ! Turn off openmp !    call omp_set_num_threads(1) ! !    ! Calculate self energy !    if ( mw%talk ) call lo_progressbar_init() !    allocate(rebuf(bs%nptot,opts%nf,dr%nb)) !    allocate(imbuf(bs%nptot,opts%nf,dr%nb)) !    allocate(lwbuf(dr%nb,bs%nptot)) !    allocate(shbuf(dr%nb,bs%nptot)) !    rebuf=0.0_flyt !    imbuf=0.0_flyt !    lwbuf=0.0_flyt !    shbuf=0.0_flyt !    do q1=1,lsmpi%nq !        ! global q-point index !        lqp=lsmpi%ind(q1) !        ! get the actual self-energy !        call se%generate(bs%q(lqp),bs%p(lqp),uc,fc,fct,fcf,qp,dr,loto,opts) !        ! Add it to the intensity !        do j=1,bs%nb !            do i=2,se%nf !                imbuf(lqp,i,j)=se%im_3ph(i,j)+se%im_iso(i,j) !                rebuf(lqp,i,j)=se%re_3ph(i,j)+se%re_4ph(i,j) !            enddo !            ! get the linewidth exactly at the harmonic frequency !            lwbuf(j,lqp)=lo_linear_interpolation(se%faxis,se%im_3ph(:,j)+se%im_iso(:,j),bs%p(lqp)%omega(j))*2.0_flyt !            ! get the anharmonic shift at the harmonic frequency !            shbuf(j,lqp)=lo_linear_interpolation(se%faxis,se%re_3ph(:,j)+se%re_4ph(:,j),bs%p(lqp)%omega(j)) !        enddo !        if ( mw%talk ) call lo_progressbar(' ... lineshape on path',q1,lsmpi%nq,mpi_wtime()-t0) !    enddo ! !    ! Add these up! !    call mpi_allreduce(rebuf,bs%selfenergy_real,bs%nptot*opts%nf*bs%nb,MPI_DOUBLE_PRECISION,MPI_SUM,mw%comm,mw%error) !    call mpi_allreduce(imbuf,bs%selfenergy_imag,bs%nptot*opts%nf*bs%nb,MPI_DOUBLE_PRECISION,MPI_SUM,mw%comm,mw%error) !    allocate(intbuf(dr%nb,bs%nptot)) !    intbuf=0.0_flyt !    call mpi_allreduce(lwbuf,intbuf,bs%nptot*bs%nb,MPI_DOUBLE_PRECISION,MPI_SUM,mw%comm,mw%error) !    do i=1,bs%nptot !    do j=1,bs%nb !        bs%p(i)%linewidth(j)=intbuf(j,i) !    enddo !    enddo !    intbuf=0.0_flyt !    call mpi_allreduce(shbuf,intbuf,bs%nptot*bs%nb,MPI_DOUBLE_PRECISION,MPI_SUM,mw%comm,mw%error) !    do i=1,bs%nptot !    do j=1,bs%nb !        bs%p(i)%shift(j)=intbuf(j,i) !    enddo !    enddo !    deallocate(intbuf) !    deallocate(lwbuf) !    deallocate(shbuf) !    ! Dump the shifts and widths !    if ( mw%r .eq. 0 ) then !        call bs%write_dispersive_property(opts%enhet,'shift','outfile.dispersion_shifts',.false.) !        call bs%write_dispersive_property(opts%enhet,'linewidth','outfile.dispersion_linewidths',.false.) !    endif !    if ( mw%talk ) write(*,*) '... dumped some intermediate stuff' ! !    rebuf=0.0_flyt !    imbuf=0.0_flyt !    t0=mpi_wtime() !    ! Figure out some neat interpolation of self-energy for really small q !    if ( mw%talk ) call lo_progressbar_init() !    do q1=1,lsmpi%nq !        lqp=lsmpi%ind(q1) !        ! what path am I on? !        path=bs%q(lqp)%path !        ! The start and end-points !        qv1=bs%segment(path)%r1-uc%bz%gshift( bs%segment(path)%r1 + lo_degenvector ) !        qv2=bs%segment(path)%r2-uc%bz%gshift( bs%segment(path)%r2 + lo_degenvector ) !        ! does it contain gamma? ! !        if ( norm2(qv1) .gt. lo_tol .and. norm2(qv2) .gt. lo_tol ) cycle !        ! seems it does, have to fix this, maybe. !        ! Good small number to use !        f0=(se%intensityaxis(2)-se%intensityaxis(1))*0.25_flyt ! smallest selfenergy !        ! Is it in the beginning or the end? !        if ( norm2(qv1) .lt. lo_tol ) then !            ! Index of gamma !            ii=(path-1)*bs%npts+1 !            ! Fix the acoustic branches !            do j=1,3 !                ! Find index of point that is ok !                do i=ii,ii+bs%npts-1 !                    if ( bs%p(i)%omega(j) .gt. dr%omega_min*0.5_flyt ) then !                        jj=i !                        exit !                    endif !                enddo !                ! now I know that things are zero at ii, and ok at jj !                bs%selfenergy_imag(ii,:,j)=f0       ! set imaginary at gamma !                bs%selfenergy_real(ii,:,j)=0.0_flyt ! set real at gamma !                lsintx(1)=bs%q_axis(ii)-lo_sqtol !                lsintx(2)=bs%q_axis(jj)+lo_sqtol !                ! Interpolate the missing self-energies at this point !                do k=1,se%nf !                    ! y-axis for interpolation, imaginary part !                    lsinty(1)=bs%selfenergy_imag(ii,k,j) !                    lsinty(2)=bs%selfenergy_imag(jj,k,j) !                    imbuf(lqp,k,j)=lo_linear_interpolation(lsintx,lsinty,bs%q_axis(lqp)) !                    ! y-axis for interpolation, real part !                    lsinty(1)=bs%selfenergy_real(ii,k,j) !                    lsinty(2)=bs%selfenergy_real(jj,k,j) !                    rebuf(lqp,k,j)=lo_linear_interpolation(lsintx,lsinty,bs%q_axis(lqp)) !                enddo !            enddo !        else !            ! Same thing again, but this time gamma is at the end. !            ii=path*bs%npts !            ! loop over the three lowest branches !            do j=1,3 !                jj=0 !                do i=ii,(path-1)*bs%npts+1,-1 !                    if ( bs%p(i)%omega(j) .gt. dr%omega_min*0.5_flyt ) then !                        jj=i !                        exit !                    endif !                enddo !                ! Interpolate this, somehow !                bs%selfenergy_imag(ii,:,j)=f0       ! set imaginary at gamma !                bs%selfenergy_real(ii,:,j)=0.0_flyt ! set real at gamma !                ! x-axis for interpolation !                lsintx(2)=bs%q_axis(ii)-lo_sqtol !                lsintx(1)=bs%q_axis(jj)+lo_sqtol !                ! interpolate to missing points !                do k=1,se%nf !                    ! y-axis for interpolation !                    lsinty(2)=bs%selfenergy_imag(ii,k,j) !                    lsinty(1)=bs%selfenergy_imag(jj,k,j) !                    imbuf(lqp,k,j)=lo_linear_interpolation(lsintx,lsinty,bs%q_axis(lqp)) !                    ! y-axis for interpolation !                    lsinty(2)=bs%selfenergy_real(ii,k,j) !                    lsinty(1)=bs%selfenergy_real(jj,k,j) !                    rebuf(lqp,k,j)=lo_linear_interpolation(lsintx,lsinty,bs%q_axis(lqp)) !                enddo !            enddo !        endif !        ! !        if ( mw%talk ) call lo_progressbar(' ... fixing tiny q',q1,lsmpi%nq,mpi_wtime()-t0) !        ! !    enddo ! !    ! Add this together, and add it to the self energy !    allocate(dumbuf(bs%nptot,opts%nf,dr%nb)) !    dumbuf=0.0_flyt !    call mpi_allreduce(rebuf,dumbuf,bs%nptot*opts%nf*bs%nb,MPI_DOUBLE_PRECISION,MPI_SUM,mw%comm,mw%error) !    bs%selfenergy_real=bs%selfenergy_real+dumbuf !    dumbuf=0.0_flyt !    call mpi_allreduce(imbuf,dumbuf,bs%nptot*opts%nf*bs%nb,MPI_DOUBLE_PRECISION,MPI_SUM,mw%comm,mw%error) !    bs%selfenergy_imag=bs%selfenergy_imag+dumbuf !    deallocate(dumbuf) ! !    ! Can't have anything negative in the imaginary selfenergy !    do i=1,bs%nptot !    do j=1,se%nf !    do k=1,se%nb !        bs%selfenergy_imag(i,j,k)=max(bs%selfenergy_imag(i,j,k),0.0_flyt) !    enddo !    enddo !    enddo ! !    if ( mw%talk ) then !        write(*,*) '... selfenergies probably ok' !        write(*,*) 'Im min,max,sum',minval(bs%selfenergy_imag/lo_twopi/1E12_flyt),& !                                 maxval(bs%selfenergy_imag/lo_twopi/1E12_flyt),& !                                 sum(bs%selfenergy_imag/lo_twopi/1E12_flyt) !        write(*,*) 'Re min,max,sum',minval(bs%selfenergy_real/lo_twopi/1E12_flyt),& !                                 maxval(bs%selfenergy_real/lo_twopi/1E12_flyt),& !                                 sum(bs%selfenergy_real/lo_twopi/1E12_flyt) !    endif !    ! Probably a neat idea to ever so slightly smear the self-energies !    rebuf=0.0_flyt !    imbuf=0.0_flyt !    ! A kernel to smear with !    nkern=3 !    lo_allocate(kernel(2*nkern+1,2*nkern+1)) !    kernel=0.0_flyt !    do i=-nkern,nkern !    do j=-nkern,nkern !        ii=i+nkern+1 !        jj=j+nkern+1 !        f0=norm2([i,j]*1.0_flyt) !        kernel(ii,jj)=lo_gauss(0.0_flyt,f0,nkern*0.5_flyt) !    enddo !    enddo !    f0=sum(bs%selfenergy_real) !    f1=sum(bs%selfenergy_imag) !    kernel=kernel/sum(kernel) !    do q1=1,lsmpi%nq !        lqp=lsmpi%ind(q1) !        do j=1,bs%nb !        do i=1,se%nf !            do ii=1,2*nkern+1 !            do jj=1,2*nkern+1 !                iii=min(max(q1+ii-1-nkern,1),bs%nptot) !                jjj=min(max(i+jj-1-nkern,1),se%nf) !                rebuf(lqp,i,j)=rebuf(lqp,i,j)+kernel(ii,jj)*bs%selfenergy_real(iii,jjj,j) !                imbuf(lqp,i,j)=imbuf(lqp,i,j)+kernel(ii,jj)*bs%selfenergy_imag(iii,jjj,j) !            enddo !            enddo !        enddo !        enddo !    enddo !    bs%selfenergy_real=0.0_flyt !    bs%selfenergy_imag=0.0_flyt !    call mpi_allreduce(rebuf,bs%selfenergy_real,bs%nptot*opts%nf*bs%nb,MPI_DOUBLE_PRECISION,MPI_SUM,mw%comm,mw%error) !    call mpi_allreduce(imbuf,bs%selfenergy_imag,bs%nptot*opts%nf*bs%nb,MPI_DOUBLE_PRECISION,MPI_SUM,mw%comm,mw%error) !    bs%selfenergy_real=bs%selfenergy_real*f0/sum(bs%selfenergy_real) !    bs%selfenergy_imag=bs%selfenergy_imag*f1/sum(bs%selfenergy_imag) !    ! Now all the self-energies are nice, time to get the intensities !    allocate(intbuf(bs%nptot,opts%nf)) !    allocate(thintbuf(bs%nptot,opts%nf)) !    allocate(dum(opts%nf)) !    intbuf=0.0_flyt !    thintbuf=0.0_flyt !    t0=mpi_wtime() !    ! Figure out some neat interpolation of self-energy for really small q !    if ( mw%talk ) call lo_progressbar_init() !    do q1=1,lsmpi%nq !        lqp=lsmpi%ind(q1) !        do j=1,bs%nb !            ! Get the lineshape !            dum=0.0_flyt !            if ( bs%p(lqp)%omega(j) .gt. lo_freqtol ) then !                call getintensity(se%faxis,bs%selfenergy_imag(lqp,:,j),bs%selfenergy_real(lqp,:,j),& !                bs%p(lqp)%omega(j),se%intensityaxis,dum) !            else !                ! acoustic branch at Gamma. Add a gaussian at 0 to no make it disappear. !                do i=1,se%nf !                    dum(i)=lo_gauss(se%intensityaxis(i),0.0_flyt,se%intensityaxis(2)-se%intensityaxis(1)) !                enddo !            endif !            ! Add it to the intensity !            intbuf(lqp,:)=intbuf(lqp,:)+dum !            ! And the one with thermal factors !            !do i=2,se%nf !            !    f0=max(dr%omega_min*0.5_flyt,se%intensityaxis(i)) !            !    dum(i)=dum(i)*(lo_planck(opts%temperature,f0)+1.0_flyt) !            !enddo !            !thintbuf(lqp,:)=thintbuf(lqp,:)+dum*bs%p(lqp)%thermal_prefactor(j) !        enddo !        ! !        if ( mw%talk ) call lo_progressbar(' ... intensities',q1,lsmpi%nq,mpi_wtime()-t0) !    enddo !    ! add them up !    call mpi_allreduce(intbuf,bs%intensity,bs%nptot*opts%nf,MPI_DOUBLE_PRECISION,MPI_SUM,mw%comm,mw%error) !    call mpi_allreduce(thintbuf,bs%intensity_with_prefactor,bs%nptot*opts%nf,MPI_DOUBLE_PRECISION,MPI_SUM,mw%comm,mw%error) !    deallocate(intbuf) !    deallocate(thintbuf) !    deallocate(dum) ! !    ! Dump to file !    if ( mw%r .eq. 0 ) then !        write(*,*) 'Writing intensity to file' !        lo_allocate(bs%faxis(se%nf)) !        bs%faxis=se%intensityaxis !        call bs%write_intensity(opts%enhet,logscale=.true.) !    endif ! And it is done! end subroutine","tags":"","loc":"sourcefile/phonondamping_thermalpath.f90.html","title":"phonondamping_thermalpath.f90 – TDEP"},{"text":"Subroutines spectralfunction_along_path Source Code phonondamping_path.f90 Source Code !> Calculate the spectral function along a path in the BZ subroutine spectralfunction_along_path ( bs , uc , fc , fct , fcf , qp , dr , opts , mw ) !> the bandstructure type ( lo_phonon_bandstructure ), intent ( inout ) :: bs !> crystal structure type ( lo_crystalstructure ), intent ( inout ) :: uc !> second order force constant type ( lo_forceconstant_secondorder ), intent ( inout ) :: fc !> third order force constant type ( lo_forceconstant_thirdorder ), intent ( in ) :: fct !> fourth order force constant type ( lo_forceconstant_fourthorder ), intent ( in ) :: fcf !> q-point mesh class ( lo_qpoint_mesh ), intent ( in ) :: qp !> harmonic properties on this mesh type ( lo_phonon_dispersions ), intent ( in ) :: dr !> all settings type ( lo_opts ), intent ( in ) :: opts !> mpi communicator type ( lo_mpi_helper ), intent ( inout ) :: mw real ( flyt ), parameter :: timereport = 3 0.0_flyt real ( flyt ), dimension (:,:,:), allocatable :: imbuf , rebuf real ( flyt ), dimension (:), allocatable :: seax , inax real ( flyt ) :: timer , minsmear ! Make some space and things like that init : block real ( flyt ) :: f0 integer :: i , j , k , l timer = walltime () ! Figure out how much space is needed to store the buffers, and maybe print a warning ! in case it's some really large amount f0 = 4 * dr % nb * opts % nf * bs % nptot * 4.0_flyt / 1024 / 1024 if ( f0 . gt . 2 0.0_flyt . and . mw % talk ) then write ( * , * ) '... Will use at least ' , tochar ( int ( f0 )), 'MB memory per rank, probably a lot more.' endif ! Make space for linewidth, shifts and so on do i = 1 , bs % nptot allocate ( bs % p ( i )% linewidth ( bs % nb )) allocate ( bs % p ( i )% shift3 ( bs % nb )) allocate ( bs % p ( i )% shift4 ( bs % nb )) bs % p ( i )% linewidth = 0.0_flyt bs % p ( i )% shift3 = 0.0_flyt bs % p ( i )% shift4 = 0.0_flyt enddo ! Space for intensity allocate ( bs % intensity ( bs % nptot , opts % nf )) allocate ( bs % selfenergy_real ( bs % nptot , opts % nf , dr % nb )) allocate ( bs % selfenergy_imag ( bs % nptot , opts % nf , dr % nb )) allocate ( rebuf ( bs % nptot , opts % nf , dr % nb )) allocate ( imbuf ( bs % nptot , opts % nf , dr % nb )) allocate ( bs % faxis ( opts % nf )) bs % faxis = 0.0_flyt bs % selfenergy_real = 0.0_flyt bs % selfenergy_imag = 0.0_flyt bs % intensity = 0.0_flyt lo_allocate ( seax ( opts % nf )) lo_allocate ( inax ( opts % nf )) seax = 0.0_flyt inax = 0.0_flyt end block init ! Get the self-energies selfenergy : block type ( lo_phonon_selfenergy ) :: se real ( flyt ), dimension (:), allocatable :: x , y , z real ( flyt ) :: f0 , f1 , t0 integer :: i , j , k , l , ctr , path , q , nq_per_path , band t0 = walltime () ! Count q-points per path, and make space for dummy arrays nq_per_path = 0 do q = 1 , bs % npts , opts % stride nq_per_path = nq_per_path + 1 enddo lo_allocate ( x ( nq_per_path )) lo_allocate ( y ( nq_per_path )) lo_allocate ( z ( nq_per_path )) rebuf = 0.0_flyt imbuf = 0.0_flyt if ( mw % talk ) call lo_progressbar_init () do path = 1 , bs % npath do q = 1 , bs % npts , opts % stride i = ( path - 1 ) * bs % npts + q ! get the self-energies call se % generate ( bs % q ( i ), bs % p ( i ), uc , fc , fct , fcf , qp , dr , opts , mw ) minsmear = ( se % faxis ( 2 ) - se % faxis ( 1 )) * opts % minsmear ! store them rebuf ( i ,:,:) = se % re_3ph + se % re_4ph imbuf ( i ,:,:) = se % im_3ph + se % im_iso ! add minimum smearing do j = 1 , se % nb do k = 1 , opts % nf imbuf ( i , k , j ) = max ( imbuf ( i , k , j ), minsmear ) enddo enddo ! Interpolate the shifts do j = 1 , se % nb bs % p ( i )% shift3 ( j ) = lo_linear_interpolation ( se % faxis , se % re_3ph (:, j ), bs % p ( i )% omega ( j ) ) bs % p ( i )% shift4 ( j ) = lo_linear_interpolation ( se % faxis , se % re_4ph (:, j ), bs % p ( i )% omega ( j ) ) enddo if ( mw % talk ) then if ( walltime () - t0 . gt . timereport ) then call lo_looptimer ( '... spectralfunction along path' , timer , walltime (), i , bs % nptot ) t0 = walltime () endif endif enddo enddo if ( opts % stride . gt . 1 ) then t0 = walltime () bs % selfenergy_real = 0.0_flyt bs % selfenergy_imag = 0.0_flyt ! Interpolate the self-energy to all q ctr = 0 if ( mw % talk ) call lo_progressbar_init () do path = 1 , bs % npath ! fetch the x-values for this path l = 0 do q = 1 , bs % npts , opts % stride i = ( path - 1 ) * bs % npts + q l = l + 1 x ( l ) = bs % q_axis ( i ) enddo do band = 1 , dr % nb do j = 1 , opts % nf ! fetch self-energies l = 0 y = 0.0_flyt z = 0.0_flyt do q = 1 , bs % npts , opts % stride i = ( path - 1 ) * bs % npts + q l = l + 1 y ( l ) = rebuf ( i , j , band ) z ( l ) = imbuf ( i , j , band ) enddo ! interpolate self-energies do q = 1 , bs % npts i = ( path - 1 ) * bs % npts + q f0 = lo_linear_interpolation ( x , y , bs % q_axis ( i )) f1 = lo_linear_interpolation ( x , z , bs % q_axis ( i )) bs % selfenergy_real ( i , j , band ) = f0 bs % selfenergy_imag ( i , j , band ) = max ( f1 , 0.0_flyt ) enddo enddo ctr = ctr + 1 if ( mw % talk ) call lo_progressbar ( ' ... interpolating selfenergy' , ctr , bs % npath * dr % nb , walltime () - t0 ) enddo enddo rebuf = bs % selfenergy_real imbuf = bs % selfenergy_imag endif ! and the different intensity axes seax = se % faxis inax = se % intensityaxis end block selfenergy ! Figure out some neat interpolation of self-energy for really small q smallq : block real ( flyt ), dimension (:), allocatable :: dumre , dumim real ( flyt ), dimension ( 3 ) :: qv1 , qv2 real ( flyt ), dimension ( 2 ) :: lsintx , lsinty real ( flyt ) :: f0 , t0 integer :: q , path , ii , jj , i , j , k ! Temporarily store self-energies lo_allocate ( dumre ( opts % nf )) lo_allocate ( dumim ( opts % nf )) ! Set smallest imaginary selfenergy dumre = 0.0_flyt dumim = 0.0_flyt ! Good small number to use f0 = ( seax ( 2 ) - seax ( 1 )) * 0.5_flyt ! smallest selfenergy t0 = walltime () ! if ( mw % talk ) call lo_progressbar_init () do q = 1 , bs % nptot ! what path am I on? path = bs % q ( q )% path ! The start and end-points qv1 = bs % segment ( path )% r1 - uc % bz % gshift ( bs % segment ( path )% r1 + lo_degenvector ) qv2 = bs % segment ( path )% r2 - uc % bz % gshift ( bs % segment ( path )% r2 + lo_degenvector ) ! does it contain gamma? if ( norm2 ( qv1 ) . gt . lo_tol . and . norm2 ( qv2 ) . gt . lo_tol ) cycle ! Is it in the beginning or the end? if ( norm2 ( qv1 ) . lt . lo_tol ) then ! Index of gamma ii = ( path - 1 ) * bs % npts + 1 ! Fix the acoustic branches do j = 1 , dr % nb ! skip if omega too large if ( bs % p ( q )% omega ( j ) . gt . dr % omega_min * 0.5_flyt ) cycle ! Find index of point that is ok jj = ii + bs % npts - 1 do i = ii , ii + bs % npts - 1 if ( bs % p ( i )% omega ( j ) . gt . dr % omega_min * 0.5_flyt ) then jj = i exit endif enddo ! Fetch real and imaginary at this q dumre = bs % selfenergy_real ( jj ,:, j ) dumim = bs % selfenergy_imag ( jj ,:, j ) ! now I know that things are zero at ii, and ok at jj lsintx ( 1 ) = bs % q_axis ( ii ) - lo_sqtol lsintx ( 2 ) = bs % q_axis ( jj ) + lo_sqtol ! Interpolate the missing self-energies at this point do k = 1 , opts % nf ! y-axis for interpolation, imaginary part lsinty ( 1 ) = f0 lsinty ( 2 ) = dumim ( k ) imbuf ( q , k , j ) = lo_linear_interpolation ( lsintx , lsinty , bs % q_axis ( q )) ! y-axis for interpolation, real part lsinty ( 1 ) = 0.0_flyt lsinty ( 2 ) = dumre ( k ) rebuf ( q , k , j ) = lo_linear_interpolation ( lsintx , lsinty , bs % q_axis ( q )) enddo enddo else ! Same thing again, but this time gamma is at the end. ii = path * bs % npts ! loop over the three lowest branches do j = 1 , dr % nb ! skip if omega too large if ( bs % p ( q )% omega ( j ) . gt . dr % omega_min * 0.5_flyt ) cycle jj = ( path - 1 ) * bs % npts + 1 do i = ii ,( path - 1 ) * bs % npts + 1 , - 1 if ( bs % p ( i )% omega ( j ) . gt . dr % omega_min * 0.5_flyt ) then jj = i exit endif enddo ! Fetch real and imaginary at this q dumre = bs % selfenergy_real ( jj ,:, j ) dumim = bs % selfenergy_imag ( jj ,:, j ) ! x-axis for interpolation lsintx ( 2 ) = bs % q_axis ( ii ) - lo_sqtol lsintx ( 1 ) = bs % q_axis ( jj ) + lo_sqtol ! interpolate to missing points do k = 1 , opts % nf ! y-axis for interpolation lsinty ( 2 ) = f0 lsinty ( 1 ) = dumim ( k ) imbuf ( q , k , j ) = lo_linear_interpolation ( lsintx , lsinty , bs % q_axis ( q )) ! y-axis for interpolation lsinty ( 2 ) = 0.0_flyt lsinty ( 1 ) = dumre ( k ) rebuf ( q , k , j ) = lo_linear_interpolation ( lsintx , lsinty , bs % q_axis ( q )) enddo enddo endif if ( mw % talk ) call lo_progressbar ( ' ... fixing tiny q' , q , bs % nptot , walltime () - t0 ) enddo ! Store the self-energies bs % selfenergy_real = rebuf bs % selfenergy_imag = imbuf end block smallq ! Smear the self-energies in q-and energy direction, just a little smearse : block integer :: i , j , band , i1 , i2 , j1 , j2 , ii , jj , iii , jjj , ctr real ( flyt ), dimension ( 5 , 5 ) :: kernel real ( flyt ), dimension ( 2 ) :: v0 ! do i = 1 , 5 do j = 1 , 5 v0 = [ i - 3 , j - 3 ] * 1.0_flyt kernel ( j , i ) = lo_gauss ( norm2 ( v0 ), 0.0_flyt , 2.6_flyt ) enddo enddo kernel = kernel / sum ( kernel ) ! rebuf = 0.0_flyt imbuf = 0.0_flyt ctr = 0 if ( mw % talk ) call lo_progressbar_init () do band = 1 , dr % nb do i = 1 , bs % nptot do j = 1 , opts % nf i1 = max ( 1 , i - 2 ) i2 = min ( i + 2 , bs % nptot ) j1 = max ( 1 , j - 2 ) j2 = min ( opts % nf , j + 2 ) do ii = i1 , i2 do jj = j1 , j2 iii = ii - i + 3 jjj = jj - j + 3 rebuf ( ii , jj , band ) = rebuf ( ii , jj , band ) + kernel ( iii , jjj ) * bs % selfenergy_real ( i , j , band ) imbuf ( ii , jj , band ) = imbuf ( ii , jj , band ) + kernel ( iii , jjj ) * bs % selfenergy_imag ( i , j , band ) enddo enddo enddo ctr = ctr + 1 enddo enddo bs % selfenergy_real = rebuf bs % selfenergy_imag = imbuf end block smearse ! Get the intensities intensities : block real ( flyt ), dimension (:), allocatable :: dum real ( flyt ) :: f0 , f1 integer :: i , j , k ! put something at gamma to make the intensities not weird. f0 = ( seax ( 2 ) - seax ( 1 )) * 0.25_flyt f1 = ( seax ( 2 ) - seax ( 1 )) * opts % minsmear lo_allocate ( dum ( opts % nf )) do i = 1 , bs % nptot do j = 1 , dr % nb if ( bs % p ( i )% omega ( j ) . gt . lo_freqtol ) then call getintensity ( seax , imbuf ( i ,:, j ), rebuf ( i ,:, j ), bs % p ( i )% omega ( j ), inax , dum ) else do k = 1 , opts % nf dum ( k ) = lo_lorentz ( inax ( k ), 0.0_flyt , f0 ) enddo endif bs % intensity ( i ,:) = bs % intensity ( i ,:) + dum / lo_trapezoid_integration ( inax , dum ) enddo enddo bs % faxis = inax ! Also store the linewidth at the harmonic frequencies, as well as ! the shifts do i = 1 , bs % nptot do j = 1 , dr % nb if ( bs % p ( i )% omega ( j ) . gt . lo_freqtol ) then f0 = lo_linear_interpolation ( seax , imbuf ( i ,:, j ), bs % p ( i )% omega ( j )) bs % p ( i )% linewidth ( j ) = f0 else bs % p ( i )% linewidth ( j ) = 0.0_flyt endif enddo enddo end block intensities end subroutine","tags":"","loc":"sourcefile/phonondamping_path.f90.html","title":"phonondamping_path.f90 – TDEP"},{"text":"Subroutines get_intensity_as_dos Source Code phonondamping_dos.f90 Source Code !> calculate things as a density of states subroutine get_intensity_as_dos ( pd , qpd , drd , uc , fc , fct , fcf , qp , dr , opts , mw ) !> phonon density of states type ( lo_phonon_dos ), intent ( out ) :: pd !> q-point mesh class ( lo_qpoint_mesh ), intent ( in ) :: qpd !> harmonic properties on this mesh type ( lo_phonon_dispersions ), intent ( inout ) :: drd !> crystal structure type ( lo_crystalstructure ), intent ( inout ) :: uc !> second order force constant type ( lo_forceconstant_secondorder ), intent ( inout ) :: fc !> third order force constant type ( lo_forceconstant_thirdorder ), intent ( in ) :: fct !> fourth order force constant type ( lo_forceconstant_fourthorder ), intent ( in ) :: fcf !> q-point mesh class ( lo_qpoint_mesh ), intent ( in ) :: qp !> harmonic properties on this mesh type ( lo_phonon_dispersions ), intent ( in ) :: dr !> all settings type ( lo_opts ), intent ( in ) :: opts !> mpi helper type ( lo_mpi_helper ), intent ( inout ) :: mw ! stuff for the DOS mesh real ( flyt ) :: tt0 ! Start the timer init : block tt0 = walltime () ! make space in the dos pd % na = uc % na pd % nb = uc % na * 3 pd % dosmin = 0.0_flyt pd % dosmax = drd % omega_max * opts % maxf pd % ndos = opts % nf pd % enhet = opts % enhet pd % verbosity = opts % verbosity pd % integrationtype =- 1 ! no choice here pd % a = opts % sigma pd % dossmear = drd % default_smearing () lo_allocate ( pd % omega ( pd % ndos )) lo_allocate ( pd % dos ( pd % ndos )) lo_allocate ( pd % pdos_site ( pd % ndos , pd % na )) lo_allocate ( pd % pdos_mode ( pd % ndos , pd % nb )) call lo_linspace ( 0.0_flyt , pd % dosmax , pd % omega ) pd % dos = 0.0_flyt pd % pdos_site = 0.0_flyt pd % pdos_mode = 0.0_flyt end block init ! We can start by calculating the lineshape at all the points we need. lshp : block type ( lo_phonon_selfenergy ) :: se complex ( flyt ), dimension ( 3 ) :: cv0 real ( flyt ), dimension (:,:), allocatable :: lsbuf real ( flyt ), dimension ( uc % na ) :: siteproj real ( flyt ) :: t0 , sigma integer :: i , j , k t0 = walltime () ! Make some space lo_allocate ( lsbuf ( opts % nf , dr % nb )) lsbuf = 0.0_flyt if ( mw % talk ) call lo_progressbar_init () do i = 1 , qpd % nq_irr ! Get the self-energy call se % generate ( qpd % ip ( i ), drd % iq ( i ), uc , fc , fct , fcf , qp , dr , opts , mw ) ! Get the intensity lsbuf = 0.0_flyt do j = 1 , dr % nb ! get the smearing parameter sigma = qpd % smearingparameter ( drd % iq ( i )% vel (:, j ), pd % dossmear , pd % a ) ! the site-projections do k = 1 , uc % na cv0 = drd % iq ( i )% egv ( ( k - 1 ) * 3 + 1 : k * 3 , j ) siteproj ( k ) = abs ( dot_product ( cv0 , conjg ( cv0 ))) enddo ! intensity, smeared by this call getintensity ( pd % omega , se % im_3ph (:, j ) + se % im_iso (:, j ), se % re_3ph (:, j ) + se % re_4ph (:, j ),& drd % iq ( i )% omega ( j ), se % faxis , lsbuf (:, j ), sigma ) ! Add this in the right place pd % pdos_mode (:, j ) = pd % pdos_mode (:, j ) + lsbuf (:, j ) * qpd % ip ( i )% weight do k = 1 , uc % na pd % pdos_site (:, k ) = pd % pdos_site (:, k ) + lsbuf (:, j ) * siteproj ( k ) * qpd % ip ( i )% weight enddo enddo if ( mw % talk ) call lo_progressbar ( ' ... lineshapes across q-mesh' , i , qpd % nq_irr , walltime () - t0 ) enddo end block lshp ! Clean up the dos so that it makes sense cleandos : block real ( flyt ), dimension (:,:), allocatable :: sitebuf real ( flyt ) :: f0 , f1 integer :: i , j , k ! I might have gotten a contribution at 0 frequency due to the smearing. That has to ! be removed. I subtract the line that goes from the dos at 0 to the max frequency. do j = 1 , pd % nb f1 = pd % pdos_mode ( 1 , j ) do i = 1 , pd % ndos f0 = ( pd % ndos - i ) * 1.0_flyt / ( ( pd % ndos - 1 ) * 1.0_flyt ) f0 = f0 ** 2 pd % pdos_mode ( i , j ) = pd % pdos_mode ( i , j ) - f0 * f1 if ( pd % pdos_mode ( i , j ) . lt . 0.0_flyt ) pd % pdos_mode ( i , j ) = 0.0_flyt enddo pd % pdos_mode ( 1 , j ) = 0.0_flyt enddo do j = 1 , pd % na f1 = pd % pdos_site ( 1 , j ) do i = 1 , pd % ndos f0 = ( pd % ndos - i ) * 1.0_flyt / ( ( pd % ndos - 1 ) * 1.0_flyt ) f0 = f0 ** 2 pd % pdos_site ( i , j ) = pd % pdos_site ( i , j ) - f0 * f1 if ( pd % pdos_site ( i , j ) . lt . 0.0_flyt ) pd % pdos_site ( i , j ) = 0.0_flyt enddo pd % pdos_site ( 1 , j ) = 0.0_flyt enddo ! Sum up contributions and normalize things pd % dos = 0.0_flyt do j = 1 , pd % nb f0 = 1.0_flyt / lo_trapezoid_integration ( pd % omega , pd % pdos_mode (:, j )) pd % dos = pd % dos + pd % pdos_mode (:, j ) pd % pdos_mode (:, j ) = pd % pdos_mode (:, j ) * f0 enddo f0 = lo_trapezoid_integration ( pd % omega , pd % dos ) pd % dos = pd % dos * dr % nb / f0 ! Adjust the mode projected so that they sum up to the total do i = 1 , pd % ndos if ( pd % dos ( i ) . gt . lo_tol / lo_twopi / 1 E12_flyt ) then f0 = sum ( pd % pdos_mode ( i ,:)) pd % pdos_mode ( i ,:) = pd % pdos_mode ( i ,:) * pd % dos ( i ) / f0 endif enddo ! Fix the degeneracy of the site-projected lo_allocate ( sitebuf ( pd % ndos , uc % na )) sitebuf = 0.0_flyt do i = 1 , pd % na ! enfore site degeneracy do j = 1 , uc % sym % degeneracy ( i ) k = uc % sym % degenerate_atom ( j , i ) sitebuf (:, i ) = sitebuf (:, i ) + pd % pdos_site (:, k ) / ( 1.0_flyt * uc % sym % degeneracy ( j )) enddo f0 = lo_trapezoid_integration ( pd % omega , sitebuf (:, i )) sitebuf (:, i ) = sitebuf (:, i ) * 3.0_flyt / f0 enddo pd % pdos_site = sitebuf lo_deallocate ( sitebuf ) ! normalize the projections so that they add up to the total do i = 1 , pd % ndos if ( pd % dos ( i ) . gt . lo_tol / lo_twopi / 1 E12_flyt ) then f0 = sum ( pd % pdos_site ( i ,:)) pd % pdos_site ( i ,:) = pd % pdos_site ( i ,:) * pd % dos ( i ) / f0 endif enddo end block cleandos end subroutine","tags":"","loc":"sourcefile/phonondamping_dos.f90.html","title":"phonondamping_dos.f90 – TDEP"},{"text":"Subroutines fourphonon_selfenergy Source Code phonondamping_fourthorder.f90 Source Code !> The fourth order self-energy subroutine fourphonon_selfenergy ( qpoint , ompoint , qp , temperature , dr , uc , fc , fcf , delta , mw , verbosity ) !> qpoint for q type ( lo_qpoint ), intent ( in ) :: qpoint !> harmonic properties for q type ( lo_phonon_dispersions_qpoint ), intent ( in ) :: ompoint !> grid for q',q'',q''' class ( lo_qpoint_mesh ), intent ( in ) :: qp !> harmonic properties for q',q'',q'' type ( lo_phonon_dispersions ), intent ( in ) :: dr !> cyrstal structure type ( lo_crystalstructure ), intent ( in ) :: uc !> second order force constant type ( lo_forceconstant_secondorder ), intent ( in ) :: fc !> third order force constant type ( lo_forceconstant_fourthorder ), intent ( in ) :: fcf !> temperature real ( flyt ), intent ( in ) :: temperature !> real four-phonon self-energy real ( flyt ), dimension (:), intent ( out ) :: delta !> mpi helper type ( lo_mpi_helper ), intent ( in ) :: mw !> how much to talk integer , intent ( in ) :: verbosity complex ( flyt ), dimension (:,:), allocatable :: egv real ( flyt ), dimension (:,:), allocatable :: sebuf real ( flyt ), dimension ( 4 ) :: omega real ( flyt ), dimension ( 3 ) :: qv1 , qv2 , qv3 , qv4 real ( flyt ) :: f0 , fourphonon_prefactor , t0 , omegathres integer :: q , lq , b1 , b2 , b3 , b4 , ctr ! Init some things t0 = walltime () fourphonon_prefactor = 1.0_flyt / ( 8.0_flyt * qp % nq_tot ) omegathres = dr % omega_min * 0.5_flyt lo_allocate ( sebuf ( dr % nb , qp % nq_tot )) lo_allocate ( egv ( dr % nb , 4 )) sebuf = 0.0_flyt egv = 0.0_flyt if ( verbosity . gt . 0 ) call lo_progressbar_init () ctr = 0 ! Get harmonic things at negative q1 do q = 1 , qp % nq_tot do b1 = 1 , dr % nb ! MPI thing ctr = ctr + 1 if ( mod ( ctr , mw % n ) . ne . mw % r ) cycle ! Get the q-vectors qv1 = qpoint % w * lo_twopi qv2 =- qv1 qv3 = qp % ap ( q )% w * lo_twopi qv4 =- qv3 ! and the self-energy, eventually do b3 = 1 , dr % nb b2 = b1 b4 = b3 ! fetch frequencies omega ( 1 ) = ompoint % omega ( b1 ) omega ( 2 ) = ompoint % omega ( b2 ) omega ( 3 ) = dr % aq ( q )% omega ( b3 ) omega ( 4 ) = dr % aq ( q )% omega ( b4 ) ! fetch eigenvectors egv (:, 1 ) = ompoint % egv (:, b1 ) egv (:, 2 ) = conjg ( ompoint % egv (:, b2 )) egv (:, 3 ) = dr % aq ( q )% egv (:, b3 ) egv (:, 4 ) = conjg ( dr % aq ( q )% egv (:, b4 )) ! scatteringrate + selfenergy in one go! if ( minval ( omega ) . gt . omegathres ) then f0 = fcf % scatteringamplitude ( omega , egv , - qv2 , - qv3 , - qv4 ) f0 = f0 * ( 1.0_flyt + lo_planck ( temperature , omega ( 3 )) + lo_planck ( temperature , omega ( 4 )) ) else f0 = 0.0_flyt endif sebuf ( b1 , q ) = sebuf ( b1 , q ) + f0 enddo ! if ( verbosity . gt . 0 ) then if ( lo_trueNtimes ( ctr , 127 , qp % nq_tot * dr % nb ) ) call lo_progressbar ( ' ... fourphonon self-energy' , ctr , dr % nb * qp % nq_tot , walltime () - t0 ) endif ! enddo enddo ! Add it together call mpi_allreduce ( MPI_IN_PLACE , sebuf , dr % nb * qp % nq_tot , MPI_DOUBLE_PRECISION , MPI_SUM , mw % comm , mw % error ) do b1 = 1 , dr % nb delta ( b1 ) = sum ( sebuf ( b1 ,:)) * fourphonon_prefactor enddo if ( verbosity . gt . 0 ) call lo_progressbar ( ' ... fourphonon self-energy' , dr % nb * qp % nq_tot , dr % nb * qp % nq_tot , walltime () - t0 ) ! ! !    ! Dummy array to hold things !    t0=walltime() !    allocate(dum(dr%nb,qp%nq_tot)) !    allocate(ndum(dr%nb,dr%nb,qp%nq_tot)) !    dum=0.0_flyt !    ndum=0.0_flyt !    !$OMP PARALLEL DEFAULT(private) SHARED(dr,fc,fcf,qp,dum,ndum,uc,loto,temperature,qpoint,ompoint) !    omegathres=dr%omega_min*0.2_flyt !    !$OMP CRITICAL !    lo_allocate(dumegv2(dr%nb,dr%nb)) !    lo_allocate(dumegv3(dr%nb,dr%nb)) !    lo_allocate(dumegv4(dr%nb,dr%nb)) !    lo_allocate(dumvel2(3,dr%nb)) !    lo_allocate(dumvel3(3,dr%nb)) !    lo_allocate(dumvel4(3,dr%nb)) !    lo_allocate(dumomega2(dr%nb)) !    lo_allocate(dumomega3(dr%nb)) !    lo_allocate(dumomega4(dr%nb)) !    lo_allocate(D(dr%nb,dr%nb)) !    lo_allocate(Dq(3,dr%nb,dr%nb)) !    ! Get q2 !    dumq2%v=-qpoint%w !    dumq2%w=dumq2%v-uc%bz%gshift(dumq2%v) !    call lo_get_small_group_of_qpoint(dumq2,uc) !    call lo_get_dynamical_matrix(fc,uc,dumq2,loto,D,Dq) !    call lo_get_omega_and_velocities(D,Dq,uc,dumomega2,dumegv2,dumvel2,qpoint=dumq2) !    lo_deallocate(dumq2%invariant_operations) !    ! Some other stuff !    lo_allocate(egv(dr%nb,4)) !    !$OMP END CRITICAL !    ! !    !$OMP DO !    do q1=1,qp%nq_tot !        ! Get the other q-points !        gi3=q1 !        dumq3%v=qp%ap(gi3)%w !        dumq3%w=dumq3%v-uc%bz%gshift(dumq3%v) !        call lo_get_small_group_of_qpoint(dumq3,uc) !        call lo_get_dynamical_matrix(fc,uc,dumq3,loto,D,Dq) !        call lo_get_omega_and_velocities(D,Dq,uc,dumomega3,dumegv3,dumvel3,qpoint=dumq3) !        lo_deallocate(dumq3%invariant_operations) !        dumq4%v=-dumq3%w !        dumq4%w=dumq4%v-uc%bz%gshift(dumq4%v) !        call lo_get_small_group_of_qpoint(dumq4,uc) !        call lo_get_dynamical_matrix(fc,uc,dumq4,loto,D,Dq) !        call lo_get_omega_and_velocities(D,Dq,uc,dumomega4,dumegv4,dumvel4,qpoint=dumq4) !        lo_deallocate(dumq4%invariant_operations) ! !        ! diagonal stuff !        qv1=qpoint%w*lo_twopi !        qv2=-qv1 !        qv3=dumq3%w*lo_twopi !        qv4=-qv3 !        do b1=1,dr%nb !            b2=b1 !            do b3=1,dr%nb !                b4=b3 !                ! And freqencies !                omega(1)=ompoint%omega(b1) !                omega(2)=dumomega2(b2) !                omega(3)=dumomega3(b3) !                omega(4)=dumomega4(b4) !                ! As well as eigenvectors !                egv(:,1)=ompoint%egv(:,b1) !                egv(:,2)=dumegv2(:,b2) !                egv(:,3)=dumegv3(:,b3) !                egv(:,4)=dumegv4(:,b4) !                ! To finally get the scattering rates !                if ( minval(omega) .gt. omegathres ) then !                    c0=real(fcf%scatteringamplitude(omega,egv,qv2,qv3,qv4)) !                    c0=c0*(1.0_flyt+lo_planck(temperature,omega(3))+lo_planck(temperature,omega(4)) ) !                else !                    c0=0.0_flyt !                endif !                dum(b1,q1)=dum(b1,q1)+c0 !real(c0) !            enddo !        enddo ! !        ! Same thing, but non-diagonal !        do b1=1,dr%nb !        do b2=1,dr%nb !            do b3=1,dr%nb !                b4=b3 !                ! And freqencies !                omega(1)=ompoint%omega(b1) !                omega(2)=dumomega2(b2) !                omega(3)=dumomega3(b3) !                omega(4)=dumomega4(b4) !                ! As well as eigenvectors !                egv(:,1)=ompoint%egv(:,b1) !                egv(:,2)=dumegv2(:,b2) !                egv(:,3)=dumegv3(:,b3) !                egv(:,4)=dumegv4(:,b4) !                ! To finally get the scattering rates !                if ( minval(omega) .gt. omegathres ) then !                    c0=fcf%scatteringamplitude(omega,egv,qv2,qv3,qv4) !                    c0=c0*(1.0_flyt+lo_planck(temperature,omega(3))+lo_planck(temperature,omega(4)) ) !                else !                    c0=0.0_flyt !                endif !                ndum(b1,b2,q1)=ndum(b1,b2,q1)+c0 !real(c0) !            enddo !        enddo !        enddo !    enddo !    !$OMP END DO !    lo_deallocate(dumegv2) !    lo_deallocate(dumegv3) !    lo_deallocate(dumegv4) !    lo_deallocate(dumvel2) !    lo_deallocate(dumvel3) !    lo_deallocate(dumvel4) !    lo_deallocate(dumomega2) !    lo_deallocate(dumomega3) !    lo_deallocate(dumomega4) !    lo_deallocate(D) !    lo_deallocate(Dq) !    lo_deallocate(egv) !    !$OMP END PARALLEL ! !    do b1=1,dr%nb !        delta(b1)=sum(real(dum(b1,:))) !    enddo !    do b1=1,dr%nb !    do b2=1,dr%nb !        nddelta(b1,b2)=sum(real(ndum(b1,b2,:))) !    enddo !    enddo !    enhet=lo_hbar_J/8.0_flyt/qp%nq_tot !    delta=delta*enhet !    nddelta=nddelta*enhet !    lo_deallocate(dum) end subroutine","tags":"","loc":"sourcefile/phonondamping_fourthorder.f90.html","title":"phonondamping_fourthorder.f90 – TDEP"},{"text":"Programs lineshape Source Code main.f90 Source Code #include \"precompilerdefinitions\" program lineshape !!{!src/lineshape/manual.md!} use konstanter , only : flyt use type_crystalstructure , only : lo_crystalstructure use type_forceconstant_secondorder , only : lo_forceconstant_secondorder use type_forceconstant_thirdorder , only : lo_forceconstant_thirdorder use type_forceconstant_fourthorder , only : lo_forceconstant_fourthorder use type_qpointmesh , only : lo_qpoint_mesh , lo_generate_qmesh , lo_read_qmesh_from_file , lo_get_small_group_of_qpoint use type_phonon_dispersions , only : lo_phonon_dispersions use type_phonon_dos , only : lo_phonon_dos use type_phonon_bandstructure , only : lo_phonon_bandstructure use helpers , only : open_file , lo_mpi_helper , walltime , lo_chop !use scatteringrates, only: lo_listofscatteringrates use phonondamping use options use io implicit none type ( lo_opts ) :: opts type ( lo_mpi_helper ) :: mw type ( lo_crystalstructure ) :: uc type ( lo_forceconstant_secondorder ) :: fc type ( lo_forceconstant_thirdorder ) :: fct type ( lo_forceconstant_fourthorder ) :: fcf type ( lo_phonon_dispersions ) :: dr , drd type ( lo_phonon_dos ) :: pd class ( lo_qpoint_mesh ), allocatable :: qp , qpd real ( flyt ) :: timer_init , timer_total ! Init MPI! call mw % init () ! Start timers timer_total = walltime () timer_init = walltime () ! some options call opts % parse () ! set up all possible meshes init : block ! only be verbose on the first rank if ( . not . mw % talk ) opts % verbosity = 0 ! Read structure call uc % readfromfile ( 'infile.ucposcar' ) call uc % classify ( 'wedge' , timereversal = . true .) if ( mw % talk ) write ( * , * ) '... using ' , tochar ( mw % n ), ' MPI ranks' if ( mw % talk ) write ( * , * ) '... read unitcell poscar' if ( opts % readiso ) then if ( mw % talk ) write ( * , * ) '... reading isotope distribution from file' call uc % readisotopefromfile () endif ! Read forceconstants call fc % readfromfile ( uc , 'infile.forceconstant' ) if ( mw % talk ) write ( * , * ) '... read second order forceconstant' if ( opts % thirdorder ) then call fct % readfromfile ( uc , 'infile.forceconstant_thirdorder' ) if ( mw % talk ) write ( * , * ) '... read third order forceconstant' endif if ( opts % fourthorder ) then call fcf % readfromfile ( uc , 'infile.forceconstant_fourthorder' ) if ( mw % talk ) write ( * , * ) '... read fourth order forceconstant' endif ! Get a q-mesh for the integrations if ( opts % readqmesh ) then if ( mw % talk ) write ( * , * ) '... getting q-mesh from file' call lo_read_qmesh_from_file ( qp , uc , 'infile.qgrid.hdf5' ) else if ( mw % talk ) write ( * , * ) '... generating q-mesh' select case ( opts % meshtype ) case ( 1 ) call lo_generate_qmesh ( qp , uc , opts % qgrid , 'monkhorst' , verbosity = opts % verbosity , timereversal = opts % timereversal ) case ( 2 ) call lo_generate_qmesh ( qp , uc , opts % qgrid , 'fft' , verbosity = opts % verbosity , timereversal = opts % timereversal ) case ( 3 ) call lo_generate_qmesh ( qp , uc , opts % qgrid , 'wedge' , verbosity = opts % verbosity , timereversal = opts % timereversal ) end select endif ! Dispersions for everyone! call dr % generate ( qp , fc , uc , timereversal = opts % timereversal , verbosity = opts % verbosity , mpi_communicator = mw % comm ) if ( mw % talk ) write ( * , * ) '... got the full dispersion relations' timer_init = walltime () - timer_init end block init ! Now everything is read and set, time to calculate something. Three main modes: single point, ! bandstructure or dos. Only do one of them, gets annoying and confusing otherwise, I think. if ( opts % oneqpoint ) then onepoint : block type ( lo_phonon_dispersions_qpoint ) :: ompoint type ( lo_qpoint ) :: qpoint type ( lo_phonon_selfenergy ) :: se real ( flyt ), dimension ( 3 ) :: v0 ! Do the rest on a single rank. No point in using MPI at all. if ( mw % talk ) then write ( * , * ) '' write ( * , * ) 'Caltulating lineshapes for a single q-point' opts % verbosity = opts % verbosity + 1 endif ! coordinates for this single point if ( trim ( opts % highsymmetrypoint ) . ne . 'none' ) then v0 = uc % coordinate_from_high_symmetry_point_label ( opts % highsymmetrypoint ) else v0 = uc % fractional_to_cartesian ( opts % qpoint , reciprocal = . true .) endif qpoint % v = lo_chop ( v0 , lo_sqtol ) qpoint % w = lo_chop ( v0 - uc % bz % gshift ( v0 + lo_degenvector ), lo_sqtol ) call lo_get_small_group_of_qpoint ( qpoint , uc ) ! harmonic properties at this point call ompoint % generate ( fc , uc , qpoint ) ! get the self-energy call se % generate ( qpoint , ompoint , uc , fc , fct , fcf , qp , dr , opts , mw ) ! dump it to file if ( mw % talk ) then call write_lineshape_to_hdf5 ( se , opts % enhet , opts % temperature , 'outfile.lineshape.hdf5' ) endif end block onepoint endif if ( opts % qpointpath ) then qppath : block type ( lo_phonon_bandstructure ) :: bs type ( lo_phonon_selfenergy ) :: se integer :: npts , i , j if ( mw % talk ) then write ( * , * ) '' write ( * , * ) 'Calculating lineshapes on a path in the BZ.' endif ! Generate the path, and the harmonic things on said path npts = 0 do i = 1 , opts % nq_on_path npts = npts + opts % stride if ( npts . ge . opts % nq_on_path - opts % stride ) exit enddo npts = npts + 1 call bs % generate ( uc , fc , timereversal = opts % timereversal , npts = npts , readpathfromfile = opts % readpathfromfile , verbosity = opts % verbosity , mpi_communicator = mw % comm ) ! Calculate the actual thingy. Quite long, so moved to it's own routine. call spectralfunction_along_path ( bs , uc , fc , fct , fcf , qp , dr , opts , mw ) ! Dump this if ( mw % talk ) then call write_lineshapes_along_path_to_hdf5 ( bs , opts % enhet , 'outfile.sqe.hdf5' ) call bs % write_to_hdf5 ( uc , opts % enhet , 'outfile.dispersion_relations.hdf5' ) endif end block qppath endif if ( opts % phonondos ) then if ( mw % talk ) write ( * , * ) '' if ( mw % talk ) write ( * , * ) 'Calculating the phonon dos' select case ( opts % meshtype ) case ( 1 ) call lo_generate_qmesh ( qpd , uc , opts % qgrid_dos , 'monkhorst' , verbosity = opts % verbosity , timereversal = opts % timereversal ) case ( 2 ) call lo_generate_qmesh ( qpd , uc , opts % qgrid_dos , 'fft' , verbosity = opts % verbosity , timereversal = opts % timereversal ) case ( 3 ) call lo_generate_qmesh ( qpd , uc , opts % qgrid_dos , 'wedge' , verbosity = opts % verbosity , timereversal = opts % timereversal ) end select ! and dispersions on this grid call drd % generate ( qpd , fc , uc , timereversal = opts % timereversal , verbosity = opts % verbosity , mpi_communicator = mw % comm ) ! Get the actual dos call get_intensity_as_dos ( pd , qpd , drd , uc , fc , fct , fcf , qp , dr , opts , mw ) ! Dump the dos to file if ( mw % talk ) then call pd % write_to_file ( uc , opts % enhet , 'outfile.lineshape_phonon_dos' ) endif endif ! All done, print timings if ( mw % talk ) then timer_total = walltime () - timer_total write ( * , * ) ' ' write ( * , * ) ' Timings:' write ( * , * ) '              initialization:' , timer_init write ( * , * ) '                       total:' , timer_total endif ! Kill MPI call mw % destroy () end program","tags":"","loc":"sourcefile/main.f90~7.html","title":"main.f90 – TDEP"},{"text":"Files Dependent On This One sourcefile~~autocell.f90~~AfferentGraph sourcefile~autocell.f90 autocell.f90 sourcefile~main.f90~8 main.f90 sourcefile~autocell.f90->sourcefile~main.f90~8 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \nis dependent upon another if the latter must be compiled before the former\ncan be. Modules autocell Source Code autocell.f90 Source Code #include \"precompilerdefinitions\" module autocell use konstanter , only : flyt , lo_tol , lo_pi use helpers , only : lo_determ use geometryfunctions , only : lo_inscribed_sphere_in_box use type_crystalstructure , only : lo_crystalstructure implicit none private public :: return_supercellmatrix contains !> return a good supercell matrix subroutine return_supercellmatrix ( p , na , supercellmatrix ) !> unitcell type ( lo_crystalstructure ), intent ( in ) :: p !> desired number of atoms integer , intent ( in ) :: na !> fashionable supercell matrix integer , dimension ( 3 , 3 ), intent ( out ) :: supercellmatrix real ( flyt ), dimension ( 3 , 3 ) :: m0 , m1 , m2 , basis , guessm real ( flyt ) :: det , f0 , fillratio , r0 , volumetolerance real ( flyt ) :: perfect_fill , sphvolf , volfactor integer , dimension ( 3 , 3 ) :: guessmatrix integer :: i1 , i2 , i3 , i4 , i5 , i6 , i7 , i8 , i9 , nrep logical :: foundsomething ! Some parameters. First the ideal fill-ratio of a unit sphere in a unit cube. ! if I achieve this, I can cancel the loop or something basis = p % latticevectors volfactor = ( na * 1.0_flyt ) / p % na perfect_fill = 0.523598775598299_flyt sphvolf = 4.0_flyt * lo_pi / 3.0_flyt ! Start by getting a decent guess on how to build a cubic matrix, without regard ! to how many atoms there are and so on. fillratio = 0.0_flyt ! reset the fillratio guessm = 0.0_flyt ! reset the guess matrix ! this is probably really dangerous, but whatever reploop : do nrep = 1 , 4 do i1 = nrep , - nrep , - 1 do i2 = nrep , - nrep , - 1 do i3 = nrep , - nrep , - 1 do i4 = nrep , - nrep , - 1 do i5 = nrep , - nrep , - 1 do i6 = nrep , - nrep , - 1 do i7 = nrep , - nrep , - 1 do i8 = nrep , - nrep , - 1 do i9 = nrep , - nrep , - 1 m0 (:, 1 ) = [ i1 , i2 , i3 ] m0 (:, 2 ) = [ i4 , i5 , i6 ] m0 (:, 3 ) = [ i7 , i8 , i9 ] det = lo_determ ( m0 ) if ( det . lt . lo_tol ) cycle m1 = matmul ( basis , m0 ) ! apply the supercell matrix det = abs ( lo_determ ( m1 )) ! get the volume r0 = lo_inscribed_sphere_in_box ( m1 ) ! radius of inscribed sphere f0 = sphvolf * r0 ** 3 / det ! filling ratio if ( f0 - fillratio . gt . lo_tol ) then fillratio = f0 guessm = m0 if ( fillratio / perfect_fill . gt . 0.96_flyt ) exit reploop endif enddo enddo enddo enddo enddo enddo enddo enddo enddo enddo reploop ! Now I have a decent guess. Adjust this matrix so that it has exactly ! the correct determinant det = lo_determ ( guessm ) m2 = guessm / ( det ** ( 1.0_flyt / 3.0_flyt ) ) m2 = m2 * ( volfactor ** ( 1.0_flyt / 3.0_flyt ) ) ! for the guess, I will round this. guessmatrix = int ( anint ( m2 )) ! Now that I have an approximate supercell matrix, search a bit ! around the guess to find a really good one nrep = 2 ! probably an ok guess fillratio = 0.0_flyt ! reset the fillratio m2 = 0.0_flyt ! reset the guess matrix volumetolerance = volfactor * 0.2_flyt ! initial tolerance for number of atoms foundsomething = . false . do i1 = nrep , - nrep , - 1 do i2 = nrep , - nrep , - 1 do i3 = nrep , - nrep , - 1 do i4 = nrep , - nrep , - 1 do i5 = nrep , - nrep , - 1 do i6 = nrep , - nrep , - 1 do i7 = nrep , - nrep , - 1 do i8 = nrep , - nrep , - 1 do i9 = nrep , - nrep , - 1 m0 (:, 1 ) = [ i1 , i2 , i3 ] m0 (:, 2 ) = [ i4 , i5 , i6 ] m0 (:, 3 ) = [ i7 , i8 , i9 ] m0 = m0 + guessmatrix det = lo_determ ( m0 ) if ( det . lt . volfactor - lo_tol ) cycle if ( abs ( det - volfactor ) . gt . volumetolerance ) cycle m1 = matmul ( basis , m0 ) ! apply the supercell matrix det = abs ( lo_determ ( m1 )) ! get the volume r0 = lo_inscribed_sphere_in_box ( m1 ) ! radius of inscribed sphere f0 = sphvolf * r0 ** 3 / det ! filling ratio if ( f0 - fillratio . gt . lo_tol ) then fillratio = f0 m2 = m0 foundsomething = . true . endif enddo enddo enddo enddo enddo enddo enddo enddo enddo ! Return the results, perhaps? if ( foundsomething ) then supercellmatrix = int ( anint ( m2 )) else write ( * , * ) 'Could not find any supercell. This is easily fixable:' write ( * , * ) 'try with a different number of desired atoms, per default only' write ( * , * ) 'supercells within 20% of this number of atoms are accepted.' stop endif end subroutine end module","tags":"","loc":"sourcefile/autocell.f90.html","title":"autocell.f90 – TDEP"},{"text":"This File Depends On sourcefile~~main.f90~8~~EfferentGraph sourcefile~main.f90~8 main.f90 sourcefile~magneticdisorder.f90 magneticdisorder.f90 sourcefile~magneticdisorder.f90->sourcefile~main.f90~8 sourcefile~autocell.f90 autocell.f90 sourcefile~autocell.f90->sourcefile~main.f90~8 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \nis dependent upon another if the latter must be compiled before the former\ncan be. Programs generate_structure Source Code main.f90 Source Code #include \"precompilerdefinitions\" program generate_structure !!{!src/generate_structure/manual.md!} use konstanter , only : flyt , lo_pi , lo_sqtol use helpers , only : open_file , tochar , lo_determ , lo_mpi_helper , lo_chop , lo_get_axis_angles , lo_seed_random_numbers use geometryfunctions , only : lo_inscribed_sphere_in_box use type_symmetrylist , only : lo_symlist use type_forcemap , only : lo_forcemap use type_crystalstructure , only : lo_crystalstructure use type_sqs , only : lo_sqs use options , only : lo_opts use magneticdisorder , only : lo_magdisorder use autocell , only : return_supercellmatrix implicit none type ( lo_opts ) :: opts type ( lo_crystalstructure ) :: uc , ss , p type ( lo_symlist ) :: sl type ( lo_forcemap ) :: map type ( lo_magdisorder ) :: mag type ( lo_sqs ) :: sqs type ( lo_mpi_helper ) :: mw !real(flyt), dimension(3,3) :: tm !integer :: i,j,u ! Set some options and parse input file init : block call mw % init () call opts % parse () call lo_seed_random_numbers () ! read positions call uc % readfromfile ( 'infile.ucposcar' , verbosity = opts % verbosity ) write ( * , * ) '... read unitcell' end block init ! Create the supercell getsupercell : block real ( flyt ), dimension ( 3 , 3 ) :: tm real ( flyt ), parameter :: perfect_fill = 0.523598775598299_flyt real ( flyt ) :: a , b , c , al , be , gm , fillratio , r0 integer , dimension ( 3 , 3 ) :: supercellmatrix integer :: i , j , u character ( len = 2000 ) :: dumstr ! decide how to build a supercell, a few different routines are provided. if ( sum ( abs ( opts % ndssdim )) . gt . 0.0_flyt ) then ! non-diagonal supercell call uc % build_supercell ( ss , nondiagdimensions = opts % ndssdim ) supercellmatrix = opts % ndssdim elseif ( opts % desired_na . gt . 0 ) then ! number of atoms instead of dimensions are defined call return_supercellmatrix ( uc , opts % desired_na , supercellmatrix ) call uc % build_supercell ( ss , nondiagdimensions = supercellmatrix ) else ! normal, diagonal supercell call uc % build_supercell ( ss , opts % ssdim ) supercellmatrix = 0 do i = 1 , 3 supercellmatrix ( i , i ) = opts % ssdim ( i ) enddo endif ! build a supercell write ( * , * ) '... built supercell' r0 = lo_inscribed_sphere_in_box ( ss % latticevectors ) fillratio = 100 * ( 4 * lo_pi * ( r0 ** 3 ) / ( ss % volume * 3.0_flyt )) / perfect_fill call lo_get_axis_angles ( ss % latticevectors , a , b , c , al , be , gm ) write ( * , * ) ' Supercellmatrix:' do i = 1 , 3 write ( * , * ) tochar ( supercellmatrix (:, i )) enddo write ( * , * ) '    Filling ratio: ' , tochar ( fillratio ), '% of the ideal cube' write ( * , \"(1X,'            a,b,c:',3(2X,F14.7))\" ) a , b , c write ( * , \"(1X,' alpha,beta,gamma:',3(2X,F14.7))\" ) al * 180 / lo_pi , be * 180 / lo_pi , gm * 180 / lo_pi write ( * , * ) '  number of atoms: ' , lo_determ ( supercellmatrix ) * uc % na write ( * , * ) '' select case ( opts % outputformat ) case ( 1 ) ! VASP call ss % writetofile ( 'outfile.ssposcar' , opts % outputformat ) write ( * , * ) '... wrote supercell in VASP format' case ( 2 ) ! Abinit call ss % writetofile ( 'outfile.supercell_abinit' , opts % outputformat ) write ( * , * ) '... wrote supercell in Abinit format' case ( 3 ) ! LAMMPS call ss % writetofile ( 'outfile.supercell_lammps' , opts % outputformat , transformationmatrix = tm ) write ( * , * ) '... wrote supercell in LAMMPS format' uc % latticevectors = matmul ( tm , uc % latticevectors ) ss % latticevectors = matmul ( tm , ss % latticevectors ) call uc % writetofile ( 'outfile.uc_lammps' , 1 ) call ss % writetofile ( 'outfile.ss_lammps' , 1 ) case ( 4 ) ! FHI-Aims call ss % writetofile ( 'outfile.supercell_aims' , opts % outputformat , transformationmatrix = tm ) write ( * , * ) '... wrote supercell in FHI-Aims format' case ( 5 ) ! xyz format, for i-pi ! create that weird comment line that I-PI likes: write ( * , * ) 'FIXME ATOMIC UNITS IPI' stop dumstr = \"# CELL{H}: \" do i = 1 , 3 do j = 1 , 3 dumstr = trim ( dumstr ) // \" \" // tochar ( ss % latticevectors ( j , i ), ndecimals = 10 ) enddo enddo dumstr = trim ( dumstr ) // \" cell{angstrom} positions{angstrom}\" u = open_file ( 'out' , 'outfile.cell_ipi.xyz' ) write ( u , * ) ss % na write ( u , * ) trim ( dumstr ) do i = 1 , ss % na write ( u , \"(2X,A4,4X,3(1X,E19.12))\" ) trim ( ss % atomic_symbol ( ss % species ( i ))), lo_chop ( ss % rcart (:, i ), lo_sqtol ) enddo close ( u ) ! and print the normal output stuff call uc % writetofile ( 'outfile.uc_ipi' , 1 ) call ss % writetofile ( 'outfile.ss_ipi' , 1 ) ! and the lammps file ss % latticevectors = ss % latticevectors ss % inv_latticevectors = ss % inv_latticevectors call ss % writetofile ( 'outfile.supercell_lammps_ipi' , 3 , transformationmatrix = tm ) end select end block getsupercell ! If I want to do something disordered, this is where I generate that. disorderthings : block ! Now stop if there is no alloy stuff going on. if ( uc % info % alloy . or . uc % info % collmag . or . uc % info % noncollmag ) then ! Best to generate a symmetry table if ( opts % cutoff2 . lt . 0 ) opts % cutoff2 = ss % maxcutoff () call sl % generate ( uc , ss , opts % cutoff2 , - 1.0_flyt , - 1.0_flyt , verbosity = opts % verbosity , polar = . false ., wraparound = . true ., magcutoff2 = opts % cutoff2 ) call map % generate ( sl , uc , ss , polarcorrectiontype = 0 , verbosity = opts % verbosity ) else ! If neither an alloy or magnetically disordered, stop here. write ( * , * ) '... done' stop endif ! Generate magnetically disordered things if ( uc % info % collmag . or . uc % info % noncollmag ) then ! Get a bunch of magnetic configurations call mag % generate ( sl , uc , ss ) call mag % optimize ( ss , opts % magnconf , opts % magnbin ) ! Dump them call mag % dump_configurations ( map , uc , ss , 30 ) endif if ( uc % info % alloy ) then ! Generate an sqs, optimize on randomness and so on call sqs % generate ( uc , ss , sl , opts % verbosity ) ! Dump a configuration call sqs % returnstructure ( ss , p , opts % verbosity ) call p % writetofile ( 'outfile.sqs' , 1 ) endif end block disorderthings call mw % destroy () end program","tags":"","loc":"sourcefile/main.f90~8.html","title":"main.f90 – TDEP"},{"text":"Files Dependent On This One sourcefile~~magneticdisorder.f90~~AfferentGraph sourcefile~magneticdisorder.f90 magneticdisorder.f90 sourcefile~main.f90~8 main.f90 sourcefile~magneticdisorder.f90->sourcefile~main.f90~8 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \nis dependent upon another if the latter must be compiled before the former\ncan be. Modules magneticdisorder Source Code magneticdisorder.f90 Source Code #include \"precompilerdefinitions\" module magneticdisorder use konstanter , only : flyt , lo_huge , lo_hugeint , lo_sqtol , lo_tol use helpers , only : tochar , lo_random_int , lo_mean , open_file , lo_random_gaussian_number , lo_sqnorm , lo_chop use geometryfunctions , only : lo_rotation_matrix_from_vector_a_to_b use type_crystalstructure , only : lo_crystalstructure use type_symmetrylist , only : lo_symlist use type_forcemap , only : lo_forcemap , lo_coeffmatrix_magpair_red use type_blas_lapack_wrappers , only : lo_dgesvd implicit none private public :: lo_magdisorder type lo_magdisorder_shell ! How many pairs in the supercell map to this shell? integer :: npair =- lo_hugeint ! indices to the first atom in the pair integer , dimension (:), allocatable :: i1 ! and the second atom integer , dimension (:), allocatable :: i2 end type type lo_magdisorder !> ferromagnetic? logical :: ferromagnetic = . false . !> collinear or noncollinear logical :: coll = . false . !> How many bins of different levels of disorder do we want? integer :: nbin =- lo_hugeint !> How many configurations per bin integer :: nconf =- lo_hugeint !> number of magnetic coordination shells integer :: nshell =- lo_hugeint !> info about the coordination shells type ( lo_magdisorder_shell ), dimension (:), allocatable :: sh !> history of configurations integer , dimension (:,:,:), allocatable :: collhistory real ( flyt ), dimension (:,:,:,:), allocatable :: noncollhistory !> initial configuration integer , dimension (:), allocatable :: initial_collinear_configuration real ( flyt ), dimension (:,:), allocatable :: initial_noncollinear_configuration !> which sites are switchable? integer , dimension (:), allocatable :: sites contains !> create the structure procedure :: generate !> get the correlation function procedure :: correlation_function !> generate magnetic sqs procedure :: optimize !> dump to file procedure :: dump_configurations end type contains !> get a sphericall random unit vector function random_unit_vector () result ( v ) real ( flyt ), dimension ( 3 ) :: v ! integer :: i do i = 1 , 3 v ( i ) = lo_random_gaussian_number ( 0.0_flyt , 1.0_flyt ) enddo v = v / norm2 ( v ) end function !> make sure an AFM configuration has net magnetic moment of 0 subroutine zerosum ( x , rel ) real ( flyt ), dimension (:,:), intent ( inout ) :: x logical , dimension (:), intent ( in ) :: rel ! real ( flyt ), dimension ( 3 ) :: v integer :: i , j , n v = 0.0_flyt n = size ( x , 2 ) j = 0 do i = 1 , n if ( rel ( i ) ) then v = v + x (:, i ) j = j + 1 endif enddo v = v / ( j * 1.0_flyt ) do i = 1 , n if ( rel ( i ) ) then x (:, i ) = x (:, i ) - v x (:, i ) = x (:, i ) / norm2 ( x (:, i )) endif enddo end subroutine subroutine dump_configurations ( mag , map , uc , ss , nsubconf ) !> shells and stuff class ( lo_magdisorder ), intent ( in ) :: mag type ( lo_forcemap ), intent ( in ) :: map type ( lo_crystalstructure ), intent ( in ) :: uc type ( lo_crystalstructure ), intent ( in ) :: ss integer , intent ( in ) :: nsubconf ! real ( flyt ), dimension ( ss % na ) :: moment real ( flyt ) :: f0 , f1 integer , dimension (:), allocatable :: relirr , di integer :: a1 , a2 , sh , i , j , k , l , m , u , ii , ncf , bin , conf , ntheta character ( len = 10000 ) :: dum , fn printbasic : block do i = 1 , ss % na if ( mag % coll ) then moment ( i ) = abs ( ss % mag % collinear_moment ( i )) else moment ( i ) = norm2 ( ss % mag % noncollinear_moment (:, i )) endif enddo ! This is just the normal, random dumps where each configuration is completely uncorrelated ncf = mag % nbin + 1 do i = 1 , ncf fn = 'outfile.magmom_' // tochar ( i ) u = open_file ( 'out' , trim ( fn )) do k = 1 , mag % nconf dum = \"MAGMOM = \" if ( mag % coll ) then do l = 1 , size ( mag % collhistory , 1 ) if ( i . eq . 1 ) then ii = mag % initial_collinear_configuration ( l ) else ii = mag % collhistory ( l , k , i - 1 ) endif ii = ii * int ( anint ( moment ( l ))) dum = trim ( dum ) // \" \" // tochar ( ii ) enddo else do l = 1 , size ( mag % noncollhistory , 2 ) do m = 1 , 3 if ( i . eq . 1 ) then f0 = mag % initial_noncollinear_configuration ( m , l ) else f0 = mag % noncollhistory ( m , l , k , i - 1 ) endif f0 = f0 * moment ( l ) dum = trim ( dum ) // \" \" // tochar ( f0 ) enddo enddo endif write ( u , '(1X,A)' ) trim ( dum ) enddo close ( u ) enddo end block printbasic !    if ( mag%coll .eqv. .false. ) then !    printfancy: block !        integer, parameter :: nflip=12 !        real(flyt), dimension(:,:), allocatable :: baseline,coeffM !        real(flyt), dimension(:,:,:), allocatable :: newconf,oldconf !        real(flyt), dimension(:), allocatable :: Cline,singval !        real(flyt), dimension(3) :: v !        real(flyt) :: cn1,cn2 !        integer, dimension(:), allocatable :: magatoms !        integer, dimension(nflip) :: flipatoms !        integer :: iter !        ! Now do it slightly more sophisticated: In each bin I have decent configurations. Pick one of these !        ! And then flip some spins 180 and 90 degrees to yield a better-conditioned problem to start from? !        ! I only care about the exchange parameters of the magnetic ions, I think. So perhaps filter them a !        ! little. !        lo_allocate(di(map%ntheta_magpair)) !        di=0 !        do a1=1,map%nuc !        do i=1,map%uc(a1)%nmagpair !            a2=map%uc(a1)%magpair(i)%i2 !            if ( mag%coll ) then !                f0=abs(uc%mag%collinear_moment(a1)) !                f1=abs(uc%mag%collinear_moment(a2)) !            else !                f0=norm2(uc%mag%noncollinear_moment(:,a1)) !                f1=norm2(uc%mag%noncollinear_moment(:,a2)) !            endif !            sh=map%uc(a1)%magpair(i)%irreducible_shell !            if ( f0 .gt. lo_tol .and. f1 .gt. lo_tol ) then !                do j=1,map%magpairshell(sh)%ntheta !                    k=map%magpairshell(sh)%thetaind(j) !                    if ( k .gt. 0 ) di(k)=1 !                enddo !            endif !        enddo !        enddo !        ntheta=sum(di) !        lo_allocate(relirr(ntheta)) !        j=0 !        do i=1,size(di) !            if ( di(i) .gt. 0 ) then !                j=j+1 !                relirr(j)=i !            endif !        enddo ! !        ! Get a list of the magnetic atoms !        j=0 !        do i=1,ss%na !            if ( norm2(ss%mag%noncollinear_moment(:,i)) .gt. lo_tol ) j=j+1 !        enddo !        lo_allocate(magatoms(j)) !        j=0 !        do i=1,ss%na !            if ( norm2(ss%mag%noncollinear_moment(:,i)) .gt. lo_tol ) then !                j=j+1 !                magatoms(j)=i !            endif !        enddo ! !        lo_allocate(baseline(3,ss%na)) !        lo_allocate(newconf(3,ss%na,nsubconf)) !        lo_allocate(oldconf(3,ss%na,nsubconf)) !        lo_allocate(coeffM(nsubconf-1,ntheta)) !        lo_allocate(Cline(map%ntheta_magpair)) !        lo_allocate(singval(ntheta)) ! !        do bin=1,1 !ncf !        do conf=1,1 !mag%nconf !            if ( bin .eq. 1 ) then !                baseline=mag%initial_noncollinear_configuration !            else !                baseline=mag%noncollhistory(:,:,conf,bin-1) !            endif ! !            ! Grab the baseline distribution for this configuration !            do i=1,nsubconf !                newconf(:,:,i)=baseline !            enddo !            oldconf=newconf !            cn1=lo_huge !            cn2=0.0_flyt !            do iter=1,5000 ! !                do i=2,nsubconf !                    ! Pick some atoms to flip !                    newconf(:,:,i)=baseline !                    call randomsubset(magatoms,flipatoms) !                    do j=1,nflip !                        newconf(:,flipatoms(j),i)=random_unit_vector() !                    enddo !                    call lo_coeffmatrix_magpair_red(newconf(:,:,i),baseline,Cline,map) !                    coeffM(i-1,:)=Cline(relirr) !                enddo !                ! SVD this matrix !                call lo_dgesvd(coeffM,singval) !                cn2=abs(maxval(singval)/minval(singval)) !write(*,*) iter,singval,cn1 !                if ( cn2 .lt. cn1 ) then !                    oldconf=newconf !                    cn1=cn2 !                endif !                ! !!write(*,*) 'iter:',iter,'ss',tochar(flipatoms) !            enddo ! !        enddo !        enddo !    end block printfancy !    endif contains subroutine randomsubset ( original , subset ) !> list to choose from integer , dimension (:), intent ( in ) :: original !> list to be returned integer , dimension (:), intent ( out ) :: subset ! real ( flyt ) :: f0 , f1 integer :: i , j , n_original , n_remaining , n_needed ! n_original = size ( original , 1 ) n_needed = size ( subset , 1 ) ! sanity check n_needed = max ( n_needed , 1 ) n_needed = min ( n_original , n_needed ) ! n_remaining = n_original j = 0 do i = 1 , n_original f0 = ( 1.0_flyt * n_needed ) / ( 1.0_flyt * n_remaining ) call random_number ( f1 ) if ( f1 . le . f0 ) then j = j + 1 subset ( j ) = original ( i ) n_needed = n_needed - 1 endif n_remaining = n_remaining - 1 if ( n_needed . eq . 0 ) exit enddo end subroutine end subroutine !> calculate the correlation function subroutine correlation_function ( mag , collconf , noncollconf , cf ) !> list of shells and stuff class ( lo_magdisorder ), intent ( in ) :: mag !> current collinear magnetic configuration integer , dimension (:), intent ( in ), optional :: collconf !> current noncollinear magnetic configuration real ( flyt ), dimension (:,:), intent ( in ), optional :: noncollconf !> the correlation function per shell real ( flyt ), dimension (:), intent ( out ) :: cf ! integer :: i , j , l , i1 , i2 real ( flyt ) :: f0 ! if ( mag % coll ) then cf = 0.0_flyt do i = 1 , mag % nshell l = 0 do j = 1 , mag % sh ( i )% npair i1 = mag % sh ( i )% i1 ( j ) i2 = mag % sh ( i )% i2 ( j ) l = l + collconf ( i1 ) * collconf ( i2 ) enddo cf ( i ) = ( l * 1.0_flyt ) / ( mag % sh ( i )% npair * 1.0_flyt ) enddo else cf = 0.0_flyt do i = 1 , mag % nshell f0 = 0.0_flyt do j = 1 , mag % sh ( i )% npair i1 = mag % sh ( i )% i1 ( j ) i2 = mag % sh ( i )% i2 ( j ) f0 = f0 + dot_product ( noncollconf (:, i1 ), noncollconf (:, i2 )) enddo cf ( i ) = ( f0 * 1.0_flyt ) / ( mag % sh ( i )% npair * 1.0_flyt ) enddo endif end subroutine !> generate optimized configuration subroutine optimize ( mag , ss , nconf , nbin ) !> shells and stuff class ( lo_magdisorder ), intent ( inout ) :: mag !> crystal structure type ( lo_crystalstructure ), intent ( in ) :: ss !> how many configurations do I want in each bin? integer , intent ( in ) :: nconf !> how many bins? integer , intent ( in ) :: nbin real ( flyt ), dimension ( mag % nshell ) :: cf real ( flyt ), dimension (:,:), allocatable :: cftargets real ( flyt ), dimension (:), allocatable :: cffactor integer :: bin , i , j ! Space for the history mag % nbin = nbin mag % nconf = nconf if ( mag % coll ) then lo_allocate ( mag % collhistory ( ss % na , nconf , nbin )) mag % collhistory = 0 else lo_allocate ( mag % noncollhistory ( 3 , ss % na , nconf , nbin )) mag % noncollhistory = 0.0_flyt endif ! Set the target correlation functions lo_allocate ( cftargets ( mag % nshell , mag % nbin )) lo_allocate ( cffactor ( mag % nbin )) call mag % correlation_function ( mag % initial_collinear_configuration , mag % initial_noncollinear_configuration , cf ) cftargets = 0.0_flyt do i = 1 , size ( cftargets , 2 ) cffactor ( i ) = lo_chop ( abs (( 1.0_flyt - ( i ) / ( 1.0_flyt * mag % nbin ) )), lo_sqtol ) cftargets (:, i ) = cf * cffactor ( i ) cffactor ( i ) = ( cffactor ( i ) + 2.0_flyt ) / 3.0_flyt enddo ! I have a series of correlation function targets, one minimization for each: do bin = 1 , mag % nbin findonetarget : block real ( flyt ), dimension (:), allocatable :: convcheck real ( flyt ), dimension ( 3 , 3 ) :: m0 real ( flyt ), dimension ( 3 ) :: v0 real ( flyt ) :: cf0 , cf1 , f0 , f1 real ( flyt ) :: temperature , tempinc , tempdec , breaktol real ( flyt ), dimension (:,:,:), allocatable :: noncollhist real ( flyt ), dimension ( 3 , ss % na ) :: ncconf0 , ncconf1 integer , dimension (:,:), allocatable :: collhist integer , dimension ( ss % na ) :: conf0 , conf1 integer :: nouter , ninner , na , histcounter integer :: outiter , initer , nflip cf = 0.0_flyt ! Initial configuration if ( mag % coll ) then conf0 = mag % initial_collinear_configuration conf1 = 0 call mag % correlation_function ( collconf = conf0 , cf = cf ) else ncconf0 = mag % initial_noncollinear_configuration ncconf1 = 0 call mag % correlation_function ( noncollconf = ncconf0 , cf = cf ) endif cf0 = sum ( abs ( cf - cftargets (:, bin ))) / mag % nshell cf1 = 0.0_flyt na = size ( mag % sites , 1 ) ! Some counters for the minimization nouter = 100 ninner = mag % nconf * ss % na temperature = 0.3_flyt tempinc = 1.5_flyt tempdec = 0.5_flyt lo_allocate ( convcheck ( nouter )) convcheck = 0.0_flyt breaktol = 1 E - 2_flyt write ( * , * ) 'Simulated annealing, bin #' // tochar ( bin ) ! Start minimizing outerloop1 : do outiter = 1 , nouter nflip = 0 do initer = 1 , ninner ! Flip a spin, get new correlation function if ( mag % coll ) then conf1 = conf0 if ( mag % ferromagnetic ) then ! Just flip a random spin i = lo_random_int ( na ) conf1 ( mag % sites ( i )) =- 1 * conf1 ( mag % sites ( i )) call mag % correlation_function ( collconf = conf1 , cf = cf ) else ! Change place of two spins so that the total moment is preserved do i = lo_random_int ( na ) j = lo_random_int ( na ) if ( conf1 ( mag % sites ( i )) * conf1 ( mag % sites ( j )) . lt . 0 ) exit enddo conf1 ( mag % sites ( i )) =- 1 * conf1 ( mag % sites ( i )) conf1 ( mag % sites ( j )) =- 1 * conf1 ( mag % sites ( j )) call mag % correlation_function ( collconf = conf1 , cf = cf ) endif else ncconf1 = ncconf0 i = lo_random_int ( na ) if ( mag % ferromagnetic ) then v0 = random_unit_vector () * ( 1.0_flyt - cffactor ( bin )) + cffactor ( bin ) * ncconf1 (:, mag % sites ( i )) v0 = v0 / norm2 ( v0 ) ncconf1 (:, mag % sites ( i )) = v0 !random_unit_vector() else v0 = random_unit_vector () * ( 1.0_flyt - cffactor ( bin )) + cffactor ( bin ) * ncconf1 (:, mag % sites ( i )) v0 = v0 / norm2 ( v0 ) ncconf1 (:, mag % sites ( i )) = v0 !random_unit_vector() call zerosum ( ncconf1 , ss % mag % atom_has_moment ) endif call mag % correlation_function ( noncollconf = ncconf1 , cf = cf ) endif cf1 = sum ( abs ( cf - cftargets (:, bin ))) / mag % nshell ! Add a small bias to ferromagnetic? ! MC compare thingy f0 = exp ( - ( cf1 - cf0 ) / temperature ) call random_number ( f1 ) ! keep? if ( f0 . gt . f1 ) then if ( mag % coll ) then conf0 = conf1 else ncconf0 = ncconf1 endif cf0 = cf1 nflip = nflip + 1 endif enddo if ( mag % coll . eqv . . false . . and . mag % ferromagnetic ) then v0 = 0.0_flyt do i = 1 , na v0 = v0 + ncconf0 (:, i ) enddo v0 = v0 / norm2 ( v0 ) m0 = lo_rotation_matrix_from_vector_a_to_b ( v0 ,[ 1.0_flyt , 0.0_flyt , 0.0_flyt ] ) do i = 1 , na ncconf0 (:, i ) = matmul ( m0 , ncconf0 (:, i )) enddo endif ! check how many flips there were, and maybe adjust the temperature f0 = ( 1.0_flyt * nflip ) / ( 1.0_flyt * ninner ) if ( f0 . lt . 0.02_flyt ) then temperature = temperature * tempinc elseif ( f0 . gt . 0.10_flyt ) then temperature = temperature * tempdec endif ! check for convergence convcheck ( outiter ) = cf0 if ( outiter . ge . 5 ) then f1 = lo_mean ( convcheck ( outiter - 4 : outiter )) else f1 = 1.0_flyt endif if ( f1 . lt . breaktol ) exit outerloop1 ! if ( mag % coll ) then write ( * , '(1X,I8,1X,F10.7,4(1X,F10.7))' ) outiter , cf0 , temperature , real ( f0 ), f1 , sum ( conf0 * 1.0_flyt / na ) else write ( * , '(1X,I8,1X,F10.7,6(1X,F10.7))' ) outiter , cf0 , temperature , real ( f0 ), f1 ,& sum ( ncconf0 ( 1 ,:) * 1.0_flyt / na ), sum ( ncconf0 ( 2 ,:) * 1.0_flyt / na ), sum ( ncconf0 ( 3 ,:) * 1.0_flyt / na ) endif enddo outerloop1 convcheck = 0.0_flyt histcounter = 0 if ( mag % coll ) then lo_allocate ( collhist ( ss % na , mag % nconf )) collhist = 0 else lo_allocate ( noncollhist ( 3 , ss % na , mag % nconf )) noncollhist = 0.0_flyt endif ! Now gather some statistics for the history outerloop2 : do outiter = 1 , nouter nflip = 0 do initer = 1 , ninner ! Flip a spin, get new correlation function if ( mag % coll ) then conf1 = conf0 if ( mag % ferromagnetic ) then ! Just flip a random spin i = lo_random_int ( na ) conf1 ( mag % sites ( i )) =- 1 * conf1 ( mag % sites ( i )) call mag % correlation_function ( collconf = conf1 , cf = cf ) else ! Change place of two spins so that the total moment is preserved do i = lo_random_int ( na ) j = lo_random_int ( na ) if ( conf1 ( mag % sites ( i )) * conf1 ( mag % sites ( j )) . lt . 0 ) exit enddo conf1 ( mag % sites ( i )) =- 1 * conf1 ( mag % sites ( i )) conf1 ( mag % sites ( j )) =- 1 * conf1 ( mag % sites ( j )) call mag % correlation_function ( collconf = conf1 , cf = cf ) endif else ncconf1 = ncconf0 i = lo_random_int ( na ) if ( mag % ferromagnetic ) then v0 = random_unit_vector () * ( 1.0_flyt - cffactor ( bin )) + cffactor ( bin ) * ncconf1 (:, mag % sites ( i )) v0 = v0 / norm2 ( v0 ) ncconf1 (:, mag % sites ( i )) = v0 !random_unit_vector() else v0 = random_unit_vector () * ( 1.0_flyt - cffactor ( bin )) + cffactor ( bin ) * ncconf1 (:, mag % sites ( i )) v0 = v0 / norm2 ( v0 ) ncconf1 (:, mag % sites ( i )) = v0 !random_unit_vector() call zerosum ( ncconf1 , ss % mag % atom_has_moment ) endif call mag % correlation_function ( noncollconf = ncconf1 , cf = cf ) endif cf1 = sum ( abs ( cf - cftargets (:, bin ))) / mag % nshell ! MC compare thingy f0 = exp ( - ( cf1 - cf0 ) / temperature ) call random_number ( f1 ) ! keep? if ( f0 . gt . f1 ) then if ( mag % coll ) then conf0 = conf1 ! Is this a new configuration? j = 0 do i = 1 , histcounter if ( sum ( abs ( conf1 - collhist (:, i ))) . le . 2 ) then j = j + 1 exit endif enddo ! If it is new, keep it if ( j . eq . 0 ) then histcounter = histcounter + 1 collhist (:, histcounter ) = conf1 ! We might be done now! if ( histcounter . eq . mag % nconf ) exit outerloop2 endif else ncconf0 = ncconf1 ! Is this a new configuration? j = 0 do i = 1 , histcounter if ( sum ( abs ( ncconf1 - noncollhist (:,:, i ))) . le . 0.2_flyt ) then j = j + 1 exit endif enddo ! If it is new, keep it! if ( j . eq . 0 ) then histcounter = histcounter + 1 noncollhist (:,:, histcounter ) = ncconf1 ! We might be done now! if ( histcounter . eq . mag % nconf ) exit outerloop2 endif endif ! cf0 = cf1 nflip = nflip + 1 ! endif enddo ! check how many flips there were, and maybe adjust the temperature f0 = ( 1.0_flyt * nflip ) / ( 1.0_flyt * ninner ) if ( f0 . lt . 0.02_flyt ) then temperature = temperature * tempinc elseif ( f0 . gt . 0.10_flyt ) then temperature = temperature * tempdec endif enddo outerloop2 ! And store the history if ( mag % coll ) then mag % collhistory (:,:, bin ) = collhist else ! Rotate all spins such that the average points in the x-direction? do j = 1 , mag % nconf v0 = 0.0_flyt do i = 1 , na v0 = v0 + noncollhist (:, i , j ) enddo v0 = v0 / norm2 ( v0 ) m0 = lo_rotation_matrix_from_vector_a_to_b ( v0 ,[ 1.0_flyt , 0.0_flyt , 0.0_flyt ] ) do i = 1 , na noncollhist (:, i , j ) = matmul ( m0 , noncollhist (:, i , j )) enddo enddo mag % noncollhistory (:,:,:, bin ) = noncollhist endif end block findonetarget enddo end subroutine !> set up all the coordination shells and stuff subroutine generate ( mag , sl , uc , ss ) !> to keep track of all the coordination shells class ( lo_magdisorder ), intent ( out ) :: mag !> a symmetry table, useful for a bunch of stuff type ( lo_symlist ), intent ( in ) :: sl !> unit cell type ( lo_crystalstructure ), intent ( in ) :: uc !> supercell type ( lo_crystalstructure ), intent ( in ) :: ss ! Figure out wether it is ferro or antoferromagnetic! fmorafm : block integer :: i real ( flyt ), dimension ( 3 ) :: v0 , v1 real ( flyt ) :: f0 write ( * , * ) '... figuring out if it is ferro- or antiferromagnetic.' f0 = 0.0_flyt v0 = 0.0_flyt v1 = 0.0_flyt do i = 1 , uc % na ! Only bother with atoms with moments if ( uc % mag % atom_has_moment ( i ) ) then if ( uc % info % collmag ) then v0 = v0 + [ 1 , 1 , 1 ] * uc % mag % collinear_moment ( i ) v1 = v1 + [ 1 , 1 , 1 ] * abs ( uc % mag % collinear_moment ( i )) else v0 = v0 + uc % mag % noncollinear_moment (:, i ) v1 = v1 + abs ( uc % mag % noncollinear_moment (:, i )) endif endif enddo f0 = sum ( abs ( abs ( v0 ) - abs ( v1 ))) if ( f0 . lt . lo_tol ) then mag % ferromagnetic = . true . write ( * , * ) '... suppose it is ferromagnetic' else mag % ferromagnetic = . false . write ( * , * ) '... suppose it is antiferromagnetic' endif end block fmorafm ! Count unique atoms with magnetic moments findrelevantshells : block integer , dimension (:), allocatable :: shelli integer :: i , j , k , l logical , dimension (:), allocatable :: shellmag ! Count number of relevant coordination shells, and create an ! index that maps from shell index to magnetic shell index lo_allocate ( shelli ( sl % npairshells )) lo_allocate ( shellmag ( sl % npairshells )) shelli =- 1 shellmag = . false . l = 0 do i = 1 , sl % npairshells if ( lo_sqnorm ( sl % pairshell ( i )% protpair % v ) . lt . lo_sqtol ) cycle if ( uc % mag % atom_has_moment ( sl % pairshell ( i )% protpair % i1 ) . and . & uc % mag % atom_has_moment ( sl % pairshell ( i )% protpair % i2 ) ) then l = l + 1 shelli ( i ) = l shellmag ( i ) = . true . endif enddo ! initialize the shells mag % nshell = l lo_allocate ( mag % sh ( mag % nshell )) do i = 1 , mag % nshell mag % sh ( i )% npair = 0 enddo ! Count pairs per shell do i = 1 , sl % nss do j = 1 , sl % ss ( i )% npair k = sl % ss ( i )% pair ( j )% unique_shell if ( shellmag ( k ) . eqv . . false . ) cycle if ( sl % ss ( i )% pair ( j )% j1 < sl % ss ( i )% pair ( j )% j2 ) cycle l = shelli ( k ) mag % sh ( l )% npair = mag % sh ( l )% npair + 1 enddo enddo ! make some space do i = 1 , mag % nshell lo_allocate ( mag % sh ( i )% i1 ( mag % sh ( i )% npair )) lo_allocate ( mag % sh ( i )% i2 ( mag % sh ( i )% npair )) mag % sh ( i )% i1 = 0 mag % sh ( i )% i2 = 0 mag % sh ( i )% npair = 0 enddo ! now store all the pairs for each shell do i = 1 , sl % nss do j = 1 , sl % ss ( i )% npair k = sl % ss ( i )% pair ( j )% unique_shell if ( shellmag ( k ) . eqv . . false . ) cycle if ( sl % ss ( i )% pair ( j )% j1 < sl % ss ( i )% pair ( j )% j2 ) cycle l = shelli ( k ) mag % sh ( l )% npair = mag % sh ( l )% npair + 1 mag % sh ( l )% i1 ( mag % sh ( l )% npair ) = sl % ss ( i )% pair ( j )% j1 mag % sh ( l )% i2 ( mag % sh ( l )% npair ) = sl % ss ( i )% pair ( j )% j2 enddo enddo end block findrelevantshells write ( * , * ) '... identified magnetic coordination shells' ! Now set up the starting configuration setupconf : block real ( flyt ), dimension (:), allocatable :: cf integer :: i , j ! collinear or noncollinear? if ( uc % info % collmag ) then mag % coll = . true . else mag % coll = . false . endif ! Get a list of switchable sites j = 0 do i = 1 , ss % na if ( ss % mag % atom_has_moment ( i ) ) then j = j + 1 endif enddo lo_allocate ( mag % sites ( j )) j = 0 do i = 1 , ss % na if ( ss % mag % atom_has_moment ( i ) ) then j = j + 1 mag % sites ( j ) = i endif enddo ! Set up the initial configuration if ( mag % coll ) then lo_allocate ( mag % initial_collinear_configuration ( ss % na )) mag % initial_collinear_configuration = 0 do i = 1 , ss % na if ( ss % mag % atom_has_moment ( i ) ) then mag % initial_collinear_configuration ( i ) = int ( anint ( ss % mag % collinear_moment ( i ) / abs ( ss % mag % collinear_moment ( i )))) endif enddo else lo_allocate ( mag % initial_noncollinear_configuration ( 3 , ss % na )) mag % initial_noncollinear_configuration = 0.0_flyt do i = 1 , ss % na if ( ss % mag % atom_has_moment ( i ) ) then mag % initial_noncollinear_configuration (:, i ) = ss % mag % noncollinear_moment (:, i ) / norm2 ( ss % mag % noncollinear_moment (:, i )) endif enddo endif ! Get the reference correlation function lo_allocate ( cf ( mag % nshell )) if ( mag % coll ) then call mag % correlation_function ( collconf = mag % initial_collinear_configuration , cf = cf ) else call mag % correlation_function ( noncollconf = mag % initial_noncollinear_configuration , cf = cf ) endif end block setupconf write ( * , * ) '... generated initial magnetic configuration' end subroutine end module","tags":"","loc":"sourcefile/magneticdisorder.f90.html","title":"magneticdisorder.f90 – TDEP"},{"text":"main file for canonical configuration Programs canonical_configuration Source Code main.f90 Source Code #include \"precompilerdefinitions\" !! main file for canonical configuration program canonical_configuration !!{!src/canonical_configuration/manual.md!} use konstanter , only : flyt , lo_tol , lo_kb_hartree , lo_bohr_to_A , lo_twopi , lo_frequency_Hartree_to_THz , lo_eV_to_Hartree use helpers , only : lo_mpi_helper , lo_random_int , tochar , lo_seed_random_numbers , walltime use options , only : lo_opts use type_crystalstructure , only : lo_crystalstructure use type_forceconstant_secondorder , only : lo_forceconstant_secondorder use type_jij_secondorder , only : lo_jij_secondorder implicit none type ( lo_opts ) :: opts type ( lo_crystalstructure ) :: ss , uc type ( lo_forceconstant_secondorder ) :: fc , fcss type ( lo_jij_secondorder ) :: jij type ( lo_mpi_helper ) :: mw ! Get the necessary things first init : block ! Get CLI options call opts % parse () call mw % init () ! Seed the random numbers call lo_seed_random_numbers () ! Read structures write ( * , * ) '... reading infiles' call ss % readfromfile ( 'infile.ssposcar' , verbosity = opts % verbosity ) call uc % readfromfile ( 'infile.ucposcar' , verbosity = opts % verbosity ) ! Match the supercell to the unitcell, always a good idea call uc % classify ( 'spacegroup' , timereversal = . true .) call ss % classify ( 'supercell' , uc ) ! get a forceconstant somehow if ( opts % debye_temperature . gt . 0.0_flyt ) then call fc % fake_forceconstant ( uc , ss , debye_temperature = opts % debye_temperature , verbosity = opts % verbosity ) write ( * , * ) '... constructed fake forceconstant corresponding to Td = ' , tochar ( opts % debye_temperature ), 'K' call fc % writetofile ( uc , 'outfile.fakeforceconstant' ) write ( * , * ) '... wrote it to \"outfile.fakeforceconstant\", check that the frequency range is reasonable' elseif ( opts % maximum_frequency . gt . 0.0_flyt ) then call fc % fake_forceconstant ( uc , ss , maximum_frequency = opts % maximum_frequency , verbosity = opts % verbosity ) write ( * , * ) '... constructed fake forceconstant corresponding to max(omega) = ' , tochar ( opts % maximum_frequency * lo_frequency_Hartree_to_THz ), ' THz' call fc % writetofile ( uc , 'outfile.fakeforceconstant' ) write ( * , * ) '... wrote it to \"outfile.fakeforceconstant\", check that dispersions look reasonable' else ! read the forceconstant from file call fc % readfromfile ( uc , 'infile.forceconstant' ) endif ! Create fake magnetic exchange interactions if ( abs ( opts % exchange_J ) . gt . lo_tol ) then ! Convert from the meV in the input to Hartree opts % exchange_J = opts % exchange_J * lo_eV_to_Hartree / 1000 opts % exchange_J = opts % exchange_J / ( opts % mean_moment ** 2 ) call jij % fake_jij ( uc , opts % exchange_J , opts % mean_moment ) call jij % writetofile ( uc , 'outfile.fakejij' ) endif ! Remap force constant to supercell if ( uc % info % alloy ) then write ( * , * ) '... alloy detected' write ( * , * ) 'Not done' stop ! the unitcell is an alloy, now I have to think a little !call sqs%readfromfile('infile.sqs') !call alloy%readfromfile('infile.sqs_alloy_supercell') ! the remapping is a bit different !alloy%r=sqs%r !call fc%remap(uc,alloy,fcss) else ! in normal case just remap it call fc % remap ( uc , ss , fcss ) endif write ( * , * ) '... remapped fc' end block init write ( * , * ) '         ek(K)            ep(K)            <ek/ep>           T(K)            <T>(K)       <msd>(A)' dumpconf : block type ( lo_crystalstructure ) :: p real ( flyt ), dimension (:,:,:,:), allocatable :: polar_fc real ( flyt ) :: ep , ek , temp , avgtemp , avgmsd , msd , ratio , rek , rep , f0 integer :: i , j , a1 , a2 character ( len = 1000 ) :: fname ! Clean copy to work with p = ss ! Get a copy of the polar forceconstant to evaluate potential energy if ( fc % polar ) then lo_allocate ( polar_fc ( 3 , 3 , p % na , p % na )) polar_fc = 0.0_flyt call fc % supercell_longrange_dynamical_matrix_at_gamma ( ss , polar_fc , 1 E - 10_flyt ) endif ratio = 0.0_flyt avgtemp = 0.0_flyt avgmsd = 0.0_flyt rek = 0.0_flyt rep = 0.0_flyt do i = 1 , opts % nconf ! reset the structure p % r = ss % r p % rcart = ss % rcart p % v = 0.0_flyt p % u = 0.0_flyt p % f = 0.0_flyt ! initialize call fcss % initialize_cell ( p , uc , fc , opts % temperature , opts % zpm ,. false ., opts % threshold ) ! dump to file select case ( opts % output_format ) case ( 1 ) ! vasp output fname = 'contcar_conf' // tochar ( i , 4 ) call p % writetofile ( trim ( fname ), opts % output_format , write_velocities = . true .) case ( 2 ) ! abinit output fname = 'abinput_conf' // tochar ( i , 4 ) call p % writetofile ( trim ( fname ), opts % output_format , write_velocities = . true .) case ( 3 ) ! LAMMPS output fname = 'lammps_conf' // tochar ( i , 4 ) call p % writetofile ( trim ( fname ), opts % output_format , write_velocities = . true .) case ( 4 ) ! AIMS output fname = 'aims_conf' // tochar ( i , 4 ) call p % writetofile ( trim ( fname ), opts % output_format , write_velocities = . true .) end select ! just measure some stuff, for no good reason ek = p % kinetic_energy () / ( p % na ) ep = fcss % potential_energy ( p % u ) / ( p % na ) if ( fc % polar ) then f0 = 0.0_flyt do a1 = 1 , p % na do a2 = 1 , p % na f0 = f0 + dot_product ( matmul ( p % u (:, a1 ), polar_fc (:,:, a1 , a2 )), p % u (:, a2 )) * 0.5_flyt enddo enddo ep = ep + f0 / p % na endif rek = rek + ek rep = rep + ep ratio = rek / rep temp = ( ek + ep ) / ( 3 * lo_kb_hartree ) msd = 0 do j = 1 , p % na msd = msd + norm2 ( p % u (:, j )) * lo_bohr_to_A / p % na enddo avgmsd = avgmsd + msd avgtemp = avgtemp + temp write ( * , \"(1X,5(2X,F15.5),2X,F12.8)\" ) ek / lo_kb_hartree / 1.5_flyt , ep / lo_kb_hartree / 1.5_flyt , ratio , temp , avgtemp / i , avgmsd / i enddo end block dumpconf call mw % destroy () end program","tags":"","loc":"sourcefile/main.f90~9.html","title":"main.f90 – TDEP"},{"text":"type, private :: lo_magdisorder_shell Inherited By type~~lo_magdisorder_shell~~InheritedByGraph type~lo_magdisorder_shell lo_magdisorder_shell type~lo_magdisorder lo_magdisorder type~lo_magdisorder_shell->type~lo_magdisorder sh Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial integer, public :: npair = -lo_hugeint integer, public, dimension(:), allocatable :: i1 integer, public, dimension(:), allocatable :: i2","tags":"","loc":"type/lo_magdisorder_shell.html","title":"lo_magdisorder_shell – TDEP "},{"text":"type, public :: lo_magdisorder type~~lo_magdisorder~~InheritsGraph type~lo_magdisorder lo_magdisorder type~lo_magdisorder_shell lo_magdisorder_shell type~lo_magdisorder_shell->type~lo_magdisorder sh Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial logical, public :: ferromagnetic = .false. ferromagnetic? logical, public :: coll = .false. collinear or noncollinear integer, public :: nbin = -lo_hugeint How many bins of different levels of disorder do we want? integer, public :: nconf = -lo_hugeint How many configurations per bin integer, public :: nshell = -lo_hugeint number of magnetic coordination shells type( lo_magdisorder_shell ), public, dimension(:), allocatable :: sh info about the coordination shells integer, public, dimension(:,:,:), allocatable :: collhistory history of configurations real(kind=flyt), public, dimension(:,:,:,:), allocatable :: noncollhistory integer, public, dimension(:), allocatable :: initial_collinear_configuration initial configuration real(kind=flyt), public, dimension(:,:), allocatable :: initial_noncollinear_configuration integer, public, dimension(:), allocatable :: sites which sites are switchable? Type-Bound Procedures procedure, public :: generate create the structure private subroutine generate (mag, sl, uc, ss) set up all the coordination shells and stuff Arguments Type Intent Optional Attributes Name class( lo_magdisorder ), intent(out) :: mag to keep track of all the coordination shells type(lo_symlist), intent(in) :: sl a symmetry table, useful for a bunch of stuff type(lo_crystalstructure), intent(in) :: uc unit cell type(lo_crystalstructure), intent(in) :: ss supercell procedure, public :: correlation_function get the correlation function private subroutine correlation_function (mag, collconf, noncollconf, cf) calculate the correlation function Arguments Type Intent Optional Attributes Name class( lo_magdisorder ), intent(in) :: mag list of shells and stuff integer, intent(in), optional dimension(:) :: collconf current collinear magnetic configuration real(kind=flyt), intent(in), optional dimension(:,:) :: noncollconf current noncollinear magnetic configuration real(kind=flyt), intent(out), dimension(:) :: cf the correlation function per shell procedure, public :: optimize generate magnetic sqs private subroutine optimize (mag, ss, nconf, nbin) generate optimized configuration Arguments Type Intent Optional Attributes Name class( lo_magdisorder ), intent(inout) :: mag shells and stuff type(lo_crystalstructure), intent(in) :: ss crystal structure integer, intent(in) :: nconf how many configurations do I want in each bin? integer, intent(in) :: nbin how many bins? procedure, public :: dump_configurations dump to file private subroutine dump_configurations (mag, map, uc, ss, nsubconf) write( , ) 'iter:',iter,'ss',tochar(flipatoms) Arguments Type Intent Optional Attributes Name class( lo_magdisorder ), intent(in) :: mag shells and stuff type(lo_forcemap), intent(in) :: map type(lo_crystalstructure), intent(in) :: uc type(lo_crystalstructure), intent(in) :: ss integer, intent(in) :: nsubconf","tags":"","loc":"type/lo_magdisorder.html","title":"lo_magdisorder – TDEP "},{"text":"Description Tetrahedron integration weights for isotope scattering, from one q-point subroutine iso_tetrahedron_fft_oneqp(qp, dr, scq, gi1, scsigma, blochlcorrections) Arguments Type Intent Optional Attributes Name class(lo_qpoint_mesh), intent(in) :: qp qpoint mesh type(lo_phonon_dispersions), intent(in) :: dr phonon dispersoins type(lo_iso2), intent(inout) :: scq current q-point integer, intent(in) :: gi1 current grid-index real(kind=flyt), intent(in) :: scsigma baseline smearing parameter logical, intent(in) :: blochlcorrections blochl corrections? Calls proc~~iso_tetrahedron_fft_oneqp~~CallsGraph proc~iso_tetrahedron_fft_oneqp iso_tetrahedron_fft_oneqp lo_sqnorm lo_sqnorm proc~iso_tetrahedron_fft_oneqp->lo_sqnorm lo_stop_gracefully lo_stop_gracefully proc~iso_tetrahedron_fft_oneqp->lo_stop_gracefully lo_allocate lo_allocate proc~iso_tetrahedron_fft_oneqp->lo_allocate lo_deallocate lo_deallocate proc~iso_tetrahedron_fft_oneqp->lo_deallocate lo_integration_weights_for_one_tetrahedron lo_integration_weights_for_one_tetrahedron proc~iso_tetrahedron_fft_oneqp->lo_integration_weights_for_one_tetrahedron lo_stddev lo_stddev proc~iso_tetrahedron_fft_oneqp->lo_stddev Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/iso_tetrahedron_fft_oneqp.html","title":"iso_tetrahedron_fft_oneqp – TDEP"},{"text":"Description Tetrahedron integration weights for threephonon scattering, from one q-point subroutine threephonon_tetrahedron_fft_oneqp(qp, dr, scq, gi1, scsigma, blochlcorrections) Arguments Type Intent Optional Attributes Name class(lo_qpoint_mesh), intent(in) :: qp qpoint mesh type(lo_phonon_dispersions), intent(in) :: dr phonon dispersions type(lo_3phqp2), intent(inout) :: scq q-point in question integer, intent(in) :: gi1 grid-index in question real(kind=flyt), intent(in) :: scsigma baseline smearing logical, intent(in) :: blochlcorrections blochl corrections? Calls proc~~threephonon_tetrahedron_fft_oneqp~~CallsGraph proc~threephonon_tetrahedron_fft_oneqp threephonon_tetrahedron_fft_oneqp fft_third_grid_index fft_third_grid_index proc~threephonon_tetrahedron_fft_oneqp->fft_third_grid_index lo_lv_tetrahedron_weights lo_lv_tetrahedron_weights proc~threephonon_tetrahedron_fft_oneqp->lo_lv_tetrahedron_weights lo_stop_gracefully lo_stop_gracefully proc~threephonon_tetrahedron_fft_oneqp->lo_stop_gracefully lo_allocate lo_allocate proc~threephonon_tetrahedron_fft_oneqp->lo_allocate lo_deallocate lo_deallocate proc~threephonon_tetrahedron_fft_oneqp->lo_deallocate lo_sqnorm lo_sqnorm proc~threephonon_tetrahedron_fft_oneqp->lo_sqnorm lo_integration_weights_for_one_tetrahedron lo_integration_weights_for_one_tetrahedron proc~threephonon_tetrahedron_fft_oneqp->lo_integration_weights_for_one_tetrahedron Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/threephonon_tetrahedron_fft_oneqp.html","title":"threephonon_tetrahedron_fft_oneqp – TDEP"},{"text":"Description count three-phonons scattering events with gaussian smearing subroutine threephonon_gaussian_fft_oneqp(qp, dr, scq, gi1, scsigma, thres, adaptiveparameter, progressbar) Arguments Type Intent Optional Attributes Name class(lo_qpoint_mesh), intent(in) :: qp type(lo_phonon_dispersions), intent(in) :: dr type(lo_3phqp2), intent(inout) :: scq integer, intent(in) :: gi1 real(kind=flyt), intent(in) :: scsigma real(kind=flyt), intent(in) :: thres real(kind=flyt), intent(in), optional :: adaptiveparameter logical, intent(in), optional :: progressbar Calls proc~~threephonon_gaussian_fft_oneqp~~CallsGraph proc~threephonon_gaussian_fft_oneqp threephonon_gaussian_fft_oneqp fft_third_grid_index fft_third_grid_index proc~threephonon_gaussian_fft_oneqp->fft_third_grid_index lo_gauss lo_gauss proc~threephonon_gaussian_fft_oneqp->lo_gauss lo_progressbar lo_progressbar proc~threephonon_gaussian_fft_oneqp->lo_progressbar lo_allocate lo_allocate proc~threephonon_gaussian_fft_oneqp->lo_allocate lo_deallocate lo_deallocate proc~threephonon_gaussian_fft_oneqp->lo_deallocate lo_progressbar_init lo_progressbar_init proc~threephonon_gaussian_fft_oneqp->lo_progressbar_init Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/threephonon_gaussian_fft_oneqp.html","title":"threephonon_gaussian_fft_oneqp – TDEP"},{"text":"Description Gaussian integration weights for isotope scattering, from one q-point subroutine iso_gaussian_fft_oneqp(qp, dr, scq, gi1, scsigma, thres, adaptiveparameter) Arguments Type Intent Optional Attributes Name class(lo_qpoint_mesh), intent(in) :: qp q-point mesh type(lo_phonon_dispersions), intent(in) :: dr phonon dispersions type(lo_iso2), intent(inout) :: scq qpoint in question integer, intent(in) :: gi1 gridindex in question real(kind=flyt), intent(in) :: scsigma baseline smearing real(kind=flyt), intent(in) :: thres threshold to cut of gaussian real(kind=flyt), intent(in), optional :: adaptiveparameter scaling factor for adaptive gaussian Calls proc~~iso_gaussian_fft_oneqp~~CallsGraph proc~iso_gaussian_fft_oneqp iso_gaussian_fft_oneqp lo_gauss lo_gauss proc~iso_gaussian_fft_oneqp->lo_gauss lo_allocate lo_allocate proc~iso_gaussian_fft_oneqp->lo_allocate lo_deallocate lo_deallocate proc~iso_gaussian_fft_oneqp->lo_deallocate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/iso_gaussian_fft_oneqp.html","title":"iso_gaussian_fft_oneqp – TDEP"},{"text":"Description Generate the self-energy at a single q-point\n finalize to ensure that it's reasonable. subroutine generate(se, qpoint, ompoint, uc, fc, fct, fcf, qp, dr, opts, mw) Arguments Type Intent Optional Attributes Name class(lo_phonon_selfenergy), intent(out) :: se self energy class(lo_qpoint), intent(in) :: qpoint qpoint of interest type(lo_phonon_dispersions_qpoint), intent(in) :: ompoint harmonic properties at this q-point type(lo_crystalstructure), intent(in) :: uc crystal structure type(lo_forceconstant_secondorder), intent(inout) :: fc second order force constant type(lo_forceconstant_thirdorder), intent(in) :: fct third order force constant type(lo_forceconstant_fourthorder), intent(in) :: fcf fourth order force constant class(lo_qpoint_mesh), intent(in) :: qp q-point mesh type(lo_phonon_dispersions), intent(in) :: dr harmonic properties on this mesh type(lo_opts), intent(in) :: opts all settings type(lo_mpi_helper), intent(inout) :: mw MPI communicator Calls proc~~generate~~CallsGraph proc~generate generate isotope_imaginary_selfenergy_tetrahedron isotope_imaginary_selfenergy_tetrahedron proc~generate->isotope_imaginary_selfenergy_tetrahedron lo_trapezoid_integration lo_trapezoid_integration proc~generate->lo_trapezoid_integration proc~kramer_kronig_transform_to_get_real_part kramer_kronig_transform_to_get_real_part proc~generate->proc~kramer_kronig_transform_to_get_real_part lo_get_small_group_of_qpoint lo_get_small_group_of_qpoint proc~generate->lo_get_small_group_of_qpoint proc~fourphonon_selfenergy fourphonon_selfenergy proc~generate->proc~fourphonon_selfenergy threephonon_imaginary_selfenergy_tetrahedron threephonon_imaginary_selfenergy_tetrahedron proc~generate->threephonon_imaginary_selfenergy_tetrahedron slightsmearing slightsmearing proc~generate->slightsmearing lo_linspace lo_linspace proc~generate->lo_linspace isotope_imaginary_selfenergy_gaussian isotope_imaginary_selfenergy_gaussian proc~generate->isotope_imaginary_selfenergy_gaussian tochar tochar proc~generate->tochar threephonon_imaginary_selfenergy_gaussian threephonon_imaginary_selfenergy_gaussian proc~generate->threephonon_imaginary_selfenergy_gaussian delta delta proc~generate->delta proc~kramer_kronig_transform_to_get_real_part->lo_trapezoid_integration lo_truentimes lo_truentimes proc~fourphonon_selfenergy->lo_truentimes lo_planck lo_planck proc~fourphonon_selfenergy->lo_planck lo_progressbar lo_progressbar proc~fourphonon_selfenergy->lo_progressbar mpi_allreduce mpi_allreduce proc~fourphonon_selfenergy->mpi_allreduce walltime walltime proc~fourphonon_selfenergy->walltime lo_progressbar_init lo_progressbar_init proc~fourphonon_selfenergy->lo_progressbar_init lo_allocate lo_allocate proc~fourphonon_selfenergy->lo_allocate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/generate.html","title":"generate – TDEP"},{"text":"Description transform the imaginary part to the real part subroutine kramer_kronig_transform_to_get_real_part(se) Arguments Type Intent Optional Attributes Name type(lo_phonon_selfenergy), intent(inout) :: se selfenergy Calls proc~~kramer_kronig_transform_to_get_real_part~~CallsGraph proc~kramer_kronig_transform_to_get_real_part kramer_kronig_transform_to_get_real_part lo_trapezoid_integration lo_trapezoid_integration proc~kramer_kronig_transform_to_get_real_part->lo_trapezoid_integration Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~kramer_kronig_transform_to_get_real_part~~CalledByGraph proc~kramer_kronig_transform_to_get_real_part kramer_kronig_transform_to_get_real_part proc~generate generate proc~generate->proc~kramer_kronig_transform_to_get_real_part Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/kramer_kronig_transform_to_get_real_part.html","title":"kramer_kronig_transform_to_get_real_part – TDEP"},{"text":"Description calculate the intensity along a path subroutine get_thermally_broadened_intensity_along_path(bs, uc, fc, fct, fcf, qp, dr, loto, opts, mw, lsmpi) Arguments Type Intent Optional Attributes Name type(lo_phonon_bandstructure), intent(inout) :: bs the bandstructure type(lo_crystalstructure), intent(inout) :: uc crystal structure type(lo_forceconstant_secondorder), intent(in) :: fc second order force constant type(lo_forceconstant_thirdorder), intent(in) :: fct third order force constant type(lo_forceconstant_fourthorder), intent(in) :: fcf fourth order force constant type(lo_monkhorst_pack_mesh), intent(in) :: qp q-point mesh type(lo_phonon_dispersions), intent(in) :: dr harmonic properties on this mesh type(lo_loto), intent(in) :: loto electrostatic corrections type(lo_opts), intent(in) :: opts all settings type(lo_mpiinfo), intent(in) :: mw mpi communicator type(lo_lsmpi), intent(in) :: lsmpi mpi helper Calls proc~~get_thermally_broadened_intensity_along_path~~CallsGraph proc~get_thermally_broadened_intensity_along_path get_thermally_broadened_intensity_along_path dum dum proc~get_thermally_broadened_intensity_along_path->dum lo_linspace lo_linspace proc~get_thermally_broadened_intensity_along_path->lo_linspace lo_gauss lo_gauss proc~get_thermally_broadened_intensity_along_path->lo_gauss lo_seed_random_numbers lo_seed_random_numbers proc~get_thermally_broadened_intensity_along_path->lo_seed_random_numbers lo_progressbar lo_progressbar proc~get_thermally_broadened_intensity_along_path->lo_progressbar mpi_allreduce mpi_allreduce proc~get_thermally_broadened_intensity_along_path->mpi_allreduce lo_allocate lo_allocate proc~get_thermally_broadened_intensity_along_path->lo_allocate lo_deallocate lo_deallocate proc~get_thermally_broadened_intensity_along_path->lo_deallocate lo_progressbar_init lo_progressbar_init proc~get_thermally_broadened_intensity_along_path->lo_progressbar_init lo_sqnorm lo_sqnorm proc~get_thermally_broadened_intensity_along_path->lo_sqnorm lo_planck lo_planck proc~get_thermally_broadened_intensity_along_path->lo_planck harmonic_things_at_single_q harmonic_things_at_single_q proc~get_thermally_broadened_intensity_along_path->harmonic_things_at_single_q walltime walltime proc~get_thermally_broadened_intensity_along_path->walltime Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/get_thermally_broadened_intensity_along_path.html","title":"get_thermally_broadened_intensity_along_path – TDEP"},{"text":"Description Calculate the spectral function along a path in the BZ subroutine spectralfunction_along_path(bs, uc, fc, fct, fcf, qp, dr, opts, mw) Arguments Type Intent Optional Attributes Name type(lo_phonon_bandstructure), intent(inout) :: bs the bandstructure type(lo_crystalstructure), intent(inout) :: uc crystal structure type(lo_forceconstant_secondorder), intent(inout) :: fc second order force constant type(lo_forceconstant_thirdorder), intent(in) :: fct third order force constant type(lo_forceconstant_fourthorder), intent(in) :: fcf fourth order force constant class(lo_qpoint_mesh), intent(in) :: qp q-point mesh type(lo_phonon_dispersions), intent(in) :: dr harmonic properties on this mesh type(lo_opts), intent(in) :: opts all settings type(lo_mpi_helper), intent(inout) :: mw mpi communicator Calls proc~~spectralfunction_along_path~~CallsGraph proc~spectralfunction_along_path spectralfunction_along_path dumim dumim proc~spectralfunction_along_path->dumim lo_trapezoid_integration lo_trapezoid_integration proc~spectralfunction_along_path->lo_trapezoid_integration lsinty lsinty proc~spectralfunction_along_path->lsinty kernel kernel proc~spectralfunction_along_path->kernel getintensity getintensity proc~spectralfunction_along_path->getintensity lo_gauss lo_gauss proc~spectralfunction_along_path->lo_gauss dum dum proc~spectralfunction_along_path->dum dumre dumre proc~spectralfunction_along_path->dumre y y proc~spectralfunction_along_path->y lo_looptimer lo_looptimer proc~spectralfunction_along_path->lo_looptimer lo_progressbar lo_progressbar proc~spectralfunction_along_path->lo_progressbar x x proc~spectralfunction_along_path->x lsintx lsintx proc~spectralfunction_along_path->lsintx lo_lorentz lo_lorentz proc~spectralfunction_along_path->lo_lorentz walltime walltime proc~spectralfunction_along_path->walltime lo_progressbar_init lo_progressbar_init proc~spectralfunction_along_path->lo_progressbar_init tochar tochar proc~spectralfunction_along_path->tochar lo_linear_interpolation lo_linear_interpolation proc~spectralfunction_along_path->lo_linear_interpolation z z proc~spectralfunction_along_path->z lo_allocate lo_allocate proc~spectralfunction_along_path->lo_allocate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/spectralfunction_along_path.html","title":"spectralfunction_along_path – TDEP"},{"text":"Description calculate things as a density of states subroutine get_intensity_as_dos(pd, qpd, drd, uc, fc, fct, fcf, qp, dr, opts, mw) Arguments Type Intent Optional Attributes Name type(lo_phonon_dos), intent(out) :: pd phonon density of states class(lo_qpoint_mesh), intent(in) :: qpd q-point mesh type(lo_phonon_dispersions), intent(inout) :: drd harmonic properties on this mesh type(lo_crystalstructure), intent(inout) :: uc crystal structure type(lo_forceconstant_secondorder), intent(inout) :: fc second order force constant type(lo_forceconstant_thirdorder), intent(in) :: fct third order force constant type(lo_forceconstant_fourthorder), intent(in) :: fcf fourth order force constant class(lo_qpoint_mesh), intent(in) :: qp q-point mesh type(lo_phonon_dispersions), intent(in) :: dr harmonic properties on this mesh type(lo_opts), intent(in) :: opts all settings type(lo_mpi_helper), intent(inout) :: mw mpi helper Calls proc~~get_intensity_as_dos~~CallsGraph proc~get_intensity_as_dos get_intensity_as_dos lo_trapezoid_integration lo_trapezoid_integration proc~get_intensity_as_dos->lo_trapezoid_integration siteproj siteproj proc~get_intensity_as_dos->siteproj lsbuf lsbuf proc~get_intensity_as_dos->lsbuf getintensity getintensity proc~get_intensity_as_dos->getintensity lo_progressbar lo_progressbar proc~get_intensity_as_dos->lo_progressbar lo_linspace lo_linspace proc~get_intensity_as_dos->lo_linspace walltime walltime proc~get_intensity_as_dos->walltime lo_deallocate lo_deallocate proc~get_intensity_as_dos->lo_deallocate sitebuf sitebuf proc~get_intensity_as_dos->sitebuf lo_progressbar_init lo_progressbar_init proc~get_intensity_as_dos->lo_progressbar_init lo_allocate lo_allocate proc~get_intensity_as_dos->lo_allocate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/get_intensity_as_dos.html","title":"get_intensity_as_dos – TDEP"},{"text":"Description The fourth order self-energy subroutine fourphonon_selfenergy(qpoint, ompoint, qp, temperature, dr, uc, fc, fcf, delta, mw, verbosity) Arguments Type Intent Optional Attributes Name type(lo_qpoint), intent(in) :: qpoint qpoint for q type(lo_phonon_dispersions_qpoint), intent(in) :: ompoint harmonic properties for q class(lo_qpoint_mesh), intent(in) :: qp grid for q',q'',q''' real(kind=flyt), intent(in) :: temperature temperature type(lo_phonon_dispersions), intent(in) :: dr harmonic properties for q',q'',q'' type(lo_crystalstructure), intent(in) :: uc cyrstal structure type(lo_forceconstant_secondorder), intent(in) :: fc second order force constant type(lo_forceconstant_fourthorder), intent(in) :: fcf third order force constant real(kind=flyt), intent(out), dimension(:) :: delta real four-phonon self-energy type(lo_mpi_helper), intent(in) :: mw mpi helper integer, intent(in) :: verbosity how much to talk Calls proc~~fourphonon_selfenergy~~CallsGraph proc~fourphonon_selfenergy fourphonon_selfenergy lo_truentimes lo_truentimes proc~fourphonon_selfenergy->lo_truentimes lo_planck lo_planck proc~fourphonon_selfenergy->lo_planck lo_progressbar lo_progressbar proc~fourphonon_selfenergy->lo_progressbar mpi_allreduce mpi_allreduce proc~fourphonon_selfenergy->mpi_allreduce walltime walltime proc~fourphonon_selfenergy->walltime lo_progressbar_init lo_progressbar_init proc~fourphonon_selfenergy->lo_progressbar_init lo_allocate lo_allocate proc~fourphonon_selfenergy->lo_allocate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~fourphonon_selfenergy~~CalledByGraph proc~fourphonon_selfenergy fourphonon_selfenergy proc~generate generate proc~generate->proc~fourphonon_selfenergy Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/fourphonon_selfenergy.html","title":"fourphonon_selfenergy – TDEP"},{"text":"Description write( , ) 'bb',beta1,beta2 write( , ) hessian public subroutine histfit(sim) Arguments Type Intent Optional Attributes Name type(lo_mdsim), intent(inout) :: sim force-displacement data Calls proc~~histfit~~CallsGraph proc~histfit histfit lo_trapezoid_integration lo_trapezoid_integration proc~histfit->lo_trapezoid_integration lo_linspace lo_linspace proc~histfit->lo_linspace y y proc~histfit->y par0 par0 proc~histfit->par0 open_file open_file proc~histfit->open_file lo_identitymatrix lo_identitymatrix proc~histfit->lo_identitymatrix lo_allocate lo_allocate proc~histfit->lo_allocate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/histfit.html","title":"histfit – TDEP"},{"text":"Description remove longrange interactions public subroutine subtract_longrange_interactions(sim, map, uc, ss) Arguments Type Intent Optional Attributes Name type(lo_mdsim), intent(inout) :: sim force-displacement data type(lo_forcemap), intent(in) :: map forcemap type(lo_crystalstructure), intent(inout) :: uc unitcell type(lo_crystalstructure), intent(inout) :: ss supercell Calls proc~~subtract_longrange_interactions~~CallsGraph proc~subtract_longrange_interactions subtract_longrange_interactions lo_truentimes lo_truentimes proc~subtract_longrange_interactions->lo_truentimes lo_frobnorm lo_frobnorm proc~subtract_longrange_interactions->lo_frobnorm lo_progressbar lo_progressbar proc~subtract_longrange_interactions->lo_progressbar lo_allocate lo_allocate proc~subtract_longrange_interactions->lo_allocate lo_progressbar_init lo_progressbar_init proc~subtract_longrange_interactions->lo_progressbar_init walltime walltime proc~subtract_longrange_interactions->walltime Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/subtract_longrange_interactions.html","title":"subtract_longrange_interactions – TDEP"},{"text":"public subroutine test_forceconstant_constraints(map, fc1, fc2, fc3, fc4, uc) Arguments Type Intent Optional Attributes Name type(lo_forcemap), intent(in) :: map all the forceconstant metadata type(lo_forceconstant_firstorder), intent(in) :: fc1 firstorder forceconstant type(lo_forceconstant_secondorder), intent(in) :: fc2 secondorder forceconstant type(lo_forceconstant_thirdorder), intent(in) :: fc3 thirdorder forceconstant type(lo_forceconstant_fourthorder), intent(in) :: fc4 fourthorder forceconstant type(lo_crystalstructure), intent(in) :: uc crystal structure Calls proc~~test_forceconstant_constraints~~CallsGraph proc~test_forceconstant_constraints test_forceconstant_constraints di di proc~test_forceconstant_constraints->di lo_sqnorm lo_sqnorm proc~test_forceconstant_constraints->lo_sqnorm r r proc~test_forceconstant_constraints->r lo_deallocate lo_deallocate proc~test_forceconstant_constraints->lo_deallocate m0 m0 proc~test_forceconstant_constraints->m0 tochar tochar proc~test_forceconstant_constraints->tochar m1 m1 proc~test_forceconstant_constraints->m1 lo_allocate lo_allocate proc~test_forceconstant_constraints->lo_allocate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/test_forceconstant_constraints.html","title":"test_forceconstant_constraints – TDEP"},{"text":"Description return a good supercell matrix public subroutine return_supercellmatrix(p, na, supercellmatrix) Arguments Type Intent Optional Attributes Name type(lo_crystalstructure), intent(in) :: p unitcell integer, intent(in) :: na desired number of atoms integer, intent(out), dimension(3,3) :: supercellmatrix fashionable supercell matrix Calls proc~~return_supercellmatrix~~CallsGraph proc~return_supercellmatrix return_supercellmatrix lo_inscribed_sphere_in_box lo_inscribed_sphere_in_box proc~return_supercellmatrix->lo_inscribed_sphere_in_box lo_determ lo_determ proc~return_supercellmatrix->lo_determ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/return_supercellmatrix.html","title":"return_supercellmatrix – TDEP"},{"text":"Description get a sphericall random unit vector private function random_unit_vector() result(v) Arguments None Return Value real(kind=flyt),\n  dimension(3) Calls proc~~random_unit_vector~~CallsGraph proc~random_unit_vector random_unit_vector lo_random_gaussian_number lo_random_gaussian_number proc~random_unit_vector->lo_random_gaussian_number Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~random_unit_vector~~CalledByGraph proc~random_unit_vector random_unit_vector proc~optimize optimize proc~optimize->proc~random_unit_vector Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/random_unit_vector.html","title":"random_unit_vector – TDEP"},{"text":"Description make sure an AFM configuration has net magnetic moment of 0 private subroutine zerosum(x, rel) Arguments Type Intent Optional Attributes Name real(kind=flyt), intent(inout), dimension(:,:) :: x logical, intent(in), dimension(:) :: rel Called By proc~~zerosum~~CalledByGraph proc~zerosum zerosum proc~optimize optimize proc~optimize->proc~zerosum Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/zerosum.html","title":"zerosum – TDEP"},{"text":"Description write( , ) 'iter:',iter,'ss',tochar(flipatoms) private subroutine dump_configurations(mag, map, uc, ss, nsubconf) Arguments Type Intent Optional Attributes Name class( lo_magdisorder ), intent(in) :: mag shells and stuff type(lo_forcemap), intent(in) :: map type(lo_crystalstructure), intent(in) :: uc type(lo_crystalstructure), intent(in) :: ss integer, intent(in) :: nsubconf Calls proc~~dump_configurations~~CallsGraph proc~dump_configurations dump_configurations tochar tochar proc~dump_configurations->tochar open_file open_file proc~dump_configurations->open_file Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/dump_configurations.html","title":"dump_configurations – TDEP"},{"text":"Description calculate the correlation function private subroutine correlation_function(mag, collconf, noncollconf, cf) Arguments Type Intent Optional Attributes Name class( lo_magdisorder ), intent(in) :: mag list of shells and stuff integer, intent(in), optional dimension(:) :: collconf current collinear magnetic configuration real(kind=flyt), intent(in), optional dimension(:,:) :: noncollconf current noncollinear magnetic configuration real(kind=flyt), intent(out), dimension(:) :: cf the correlation function per shell","tags":"","loc":"proc/correlation_function.html","title":"correlation_function – TDEP"},{"text":"Description generate optimized configuration private subroutine optimize(mag, ss, nconf, nbin) Arguments Type Intent Optional Attributes Name class( lo_magdisorder ), intent(inout) :: mag shells and stuff type(lo_crystalstructure), intent(in) :: ss crystal structure integer, intent(in) :: nconf how many configurations do I want in each bin? integer, intent(in) :: nbin how many bins? Calls proc~~optimize~~CallsGraph proc~optimize optimize proc~zerosum zerosum proc~optimize->proc~zerosum convcheck convcheck proc~optimize->convcheck lo_rotation_matrix_from_vector_a_to_b lo_rotation_matrix_from_vector_a_to_b proc~optimize->lo_rotation_matrix_from_vector_a_to_b lo_chop lo_chop proc~optimize->lo_chop conf1 conf1 proc~optimize->conf1 lo_mean lo_mean proc~optimize->lo_mean lo_random_int lo_random_int proc~optimize->lo_random_int noncollhist noncollhist proc~optimize->noncollhist lo_allocate lo_allocate proc~optimize->lo_allocate ncconf1 ncconf1 proc~optimize->ncconf1 tochar tochar proc~optimize->tochar collhist collhist proc~optimize->collhist proc~random_unit_vector random_unit_vector proc~optimize->proc~random_unit_vector ncconf0 ncconf0 proc~optimize->ncconf0 lo_random_gaussian_number lo_random_gaussian_number proc~random_unit_vector->lo_random_gaussian_number Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/optimize.html","title":"optimize – TDEP"},{"text":"Description set up all the coordination shells and stuff private subroutine generate(mag, sl, uc, ss) Arguments Type Intent Optional Attributes Name class( lo_magdisorder ), intent(out) :: mag to keep track of all the coordination shells type(lo_symlist), intent(in) :: sl a symmetry table, useful for a bunch of stuff type(lo_crystalstructure), intent(in) :: uc unit cell type(lo_crystalstructure), intent(in) :: ss supercell Calls proc~~generate~2~~CallsGraph proc~generate~2 generate shelli shelli proc~generate~2->shelli lo_allocate lo_allocate proc~generate~2->lo_allocate lo_sqnorm lo_sqnorm proc~generate~2->lo_sqnorm shellmag shellmag proc~generate~2->shellmag Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/generate~2.html","title":"generate – TDEP"},{"text":"Uses: konstanter helpers type_crystalstructure type_forceconstant_secondorder type_forcemap type_mdsim quadratures_stencils module~~dipole~~UsesGraph module~dipole dipole type_forcemap type_forcemap type_forcemap->module~dipole type_mdsim type_mdsim type_mdsim->module~dipole helpers helpers helpers->module~dipole quadratures_stencils quadratures_stencils quadratures_stencils->module~dipole konstanter konstanter konstanter->module~dipole type_crystalstructure type_crystalstructure type_crystalstructure->module~dipole type_forceconstant_secondorder type_forceconstant_secondorder type_forceconstant_secondorder->module~dipole Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule or program unit using it. module~~dipole~~UsesGraph module~dipole dipole type_forcemap type_forcemap type_forcemap->module~dipole type_mdsim type_mdsim type_mdsim->module~dipole helpers helpers helpers->module~dipole quadratures_stencils quadratures_stencils quadratures_stencils->module~dipole konstanter konstanter konstanter->module~dipole type_crystalstructure type_crystalstructure type_crystalstructure->module~dipole type_forceconstant_secondorder type_forceconstant_secondorder type_forceconstant_secondorder->module~dipole Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule or program unit using it. Subroutines public subroutine histfit (sim) write( , ) 'bb',beta1,beta2 Arguments Type Intent Optional Attributes Name type(lo_mdsim), intent(inout) :: sim force-displacement data public subroutine subtract_longrange_interactions (sim, map, uc, ss) remove longrange interactions Arguments Type Intent Optional Attributes Name type(lo_mdsim), intent(inout) :: sim force-displacement data type(lo_forcemap), intent(in) :: map forcemap type(lo_crystalstructure), intent(inout) :: uc unitcell type(lo_crystalstructure), intent(inout) :: ss supercell","tags":"","loc":"module/dipole.html","title":"dipole – TDEP"},{"text":"Uses: konstanter helpers type_crystalstructure type_forceconstant_firstorder type_forceconstant_secondorder type_forceconstant_thirdorder type_forceconstant_fourthorder type_forcemap module~~test_forceconstant_symmetry~~UsesGraph module~test_forceconstant_symmetry test_forceconstant_symmetry type_forcemap type_forcemap type_forcemap->module~test_forceconstant_symmetry helpers helpers helpers->module~test_forceconstant_symmetry type_forceconstant_fourthorder type_forceconstant_fourthorder type_forceconstant_fourthorder->module~test_forceconstant_symmetry konstanter konstanter konstanter->module~test_forceconstant_symmetry type_forceconstant_firstorder type_forceconstant_firstorder type_forceconstant_firstorder->module~test_forceconstant_symmetry type_crystalstructure type_crystalstructure type_crystalstructure->module~test_forceconstant_symmetry type_forceconstant_thirdorder type_forceconstant_thirdorder type_forceconstant_thirdorder->module~test_forceconstant_symmetry type_forceconstant_secondorder type_forceconstant_secondorder type_forceconstant_secondorder->module~test_forceconstant_symmetry Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule or program unit using it. module~~test_forceconstant_symmetry~~UsesGraph module~test_forceconstant_symmetry test_forceconstant_symmetry type_forcemap type_forcemap type_forcemap->module~test_forceconstant_symmetry helpers helpers helpers->module~test_forceconstant_symmetry type_forceconstant_fourthorder type_forceconstant_fourthorder type_forceconstant_fourthorder->module~test_forceconstant_symmetry konstanter konstanter konstanter->module~test_forceconstant_symmetry type_forceconstant_firstorder type_forceconstant_firstorder type_forceconstant_firstorder->module~test_forceconstant_symmetry type_crystalstructure type_crystalstructure type_crystalstructure->module~test_forceconstant_symmetry type_forceconstant_thirdorder type_forceconstant_thirdorder type_forceconstant_thirdorder->module~test_forceconstant_symmetry type_forceconstant_secondorder type_forceconstant_secondorder type_forceconstant_secondorder->module~test_forceconstant_symmetry Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule or program unit using it. Subroutines public subroutine test_forceconstant_constraints (map, fc1, fc2, fc3, fc4, uc) Arguments Type Intent Optional Attributes Name type(lo_forcemap), intent(in) :: map all the forceconstant metadata type(lo_forceconstant_firstorder), intent(in) :: fc1 firstorder forceconstant type(lo_forceconstant_secondorder), intent(in) :: fc2 secondorder forceconstant type(lo_forceconstant_thirdorder), intent(in) :: fc3 thirdorder forceconstant type(lo_forceconstant_fourthorder), intent(in) :: fc4 fourthorder forceconstant type(lo_crystalstructure), intent(in) :: uc crystal structure","tags":"","loc":"module/test_forceconstant_symmetry.html","title":"test_forceconstant_symmetry – TDEP"},{"text":"Uses: konstanter helpers geometryfunctions type_crystalstructure module~~autocell~~UsesGraph module~autocell autocell konstanter konstanter konstanter->module~autocell type_crystalstructure type_crystalstructure type_crystalstructure->module~autocell helpers helpers helpers->module~autocell geometryfunctions geometryfunctions geometryfunctions->module~autocell Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule or program unit using it. module~~autocell~~UsesGraph module~autocell autocell konstanter konstanter konstanter->module~autocell type_crystalstructure type_crystalstructure type_crystalstructure->module~autocell helpers helpers helpers->module~autocell geometryfunctions geometryfunctions geometryfunctions->module~autocell Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule or program unit using it. Subroutines public subroutine return_supercellmatrix (p, na, supercellmatrix) return a good supercell matrix Arguments Type Intent Optional Attributes Name type(lo_crystalstructure), intent(in) :: p unitcell integer, intent(in) :: na desired number of atoms integer, intent(out), dimension(3,3) :: supercellmatrix fashionable supercell matrix","tags":"","loc":"module/autocell.html","title":"autocell – TDEP"},{"text":"Uses: konstanter helpers geometryfunctions type_crystalstructure type_symmetrylist type_forcemap type_blas_lapack_wrappers module~~magneticdisorder~~UsesGraph module~magneticdisorder magneticdisorder type_forcemap type_forcemap type_forcemap->module~magneticdisorder geometryfunctions geometryfunctions geometryfunctions->module~magneticdisorder helpers helpers helpers->module~magneticdisorder konstanter konstanter konstanter->module~magneticdisorder type_symmetrylist type_symmetrylist type_symmetrylist->module~magneticdisorder type_blas_lapack_wrappers type_blas_lapack_wrappers type_blas_lapack_wrappers->module~magneticdisorder type_crystalstructure type_crystalstructure type_crystalstructure->module~magneticdisorder Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule or program unit using it. module~~magneticdisorder~~UsesGraph module~magneticdisorder magneticdisorder type_forcemap type_forcemap type_forcemap->module~magneticdisorder geometryfunctions geometryfunctions geometryfunctions->module~magneticdisorder helpers helpers helpers->module~magneticdisorder konstanter konstanter konstanter->module~magneticdisorder type_symmetrylist type_symmetrylist type_symmetrylist->module~magneticdisorder type_blas_lapack_wrappers type_blas_lapack_wrappers type_blas_lapack_wrappers->module~magneticdisorder type_crystalstructure type_crystalstructure type_crystalstructure->module~magneticdisorder Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule or program unit using it. Derived Types type, private :: lo_magdisorder_shell Components Type Visibility Attributes Name Initial integer, public :: npair = -lo_hugeint integer, public, dimension(:), allocatable :: i1 integer, public, dimension(:), allocatable :: i2 type, public :: lo_magdisorder Components Type Visibility Attributes Name Initial logical, public :: ferromagnetic = .false. ferromagnetic? logical, public :: coll = .false. collinear or noncollinear integer, public :: nbin = -lo_hugeint How many bins of different levels of disorder do we want? integer, public :: nconf = -lo_hugeint How many configurations per bin integer, public :: nshell = -lo_hugeint number of magnetic coordination shells type( lo_magdisorder_shell ), public, dimension(:), allocatable :: sh info about the coordination shells integer, public, dimension(:,:,:), allocatable :: collhistory history of configurations real(kind=flyt), public, dimension(:,:,:,:), allocatable :: noncollhistory integer, public, dimension(:), allocatable :: initial_collinear_configuration initial configuration real(kind=flyt), public, dimension(:,:), allocatable :: initial_noncollinear_configuration integer, public, dimension(:), allocatable :: sites which sites are switchable? Type-Bound Procedures procedure, public :: generate create the structure procedure, public :: correlation_function get the correlation function procedure, public :: optimize generate magnetic sqs procedure, public :: dump_configurations dump to file Functions private function random_unit_vector () result(v) get a sphericall random unit vector Arguments None Return Value real(kind=flyt),\n  dimension(3) Subroutines private subroutine zerosum (x, rel) make sure an AFM configuration has net magnetic moment of 0 Arguments Type Intent Optional Attributes Name real(kind=flyt), intent(inout), dimension(:,:) :: x logical, intent(in), dimension(:) :: rel private subroutine dump_configurations (mag, map, uc, ss, nsubconf) write( , ) 'iter:',iter,'ss',tochar(flipatoms) Arguments Type Intent Optional Attributes Name class( lo_magdisorder ), intent(in) :: mag shells and stuff type(lo_forcemap), intent(in) :: map type(lo_crystalstructure), intent(in) :: uc type(lo_crystalstructure), intent(in) :: ss integer, intent(in) :: nsubconf private subroutine correlation_function (mag, collconf, noncollconf, cf) calculate the correlation function Arguments Type Intent Optional Attributes Name class( lo_magdisorder ), intent(in) :: mag list of shells and stuff integer, intent(in), optional dimension(:) :: collconf current collinear magnetic configuration real(kind=flyt), intent(in), optional dimension(:,:) :: noncollconf current noncollinear magnetic configuration real(kind=flyt), intent(out), dimension(:) :: cf the correlation function per shell private subroutine optimize (mag, ss, nconf, nbin) generate optimized configuration Arguments Type Intent Optional Attributes Name class( lo_magdisorder ), intent(inout) :: mag shells and stuff type(lo_crystalstructure), intent(in) :: ss crystal structure integer, intent(in) :: nconf how many configurations do I want in each bin? integer, intent(in) :: nbin how many bins? private subroutine generate (mag, sl, uc, ss) set up all the coordination shells and stuff Arguments Type Intent Optional Attributes Name class( lo_magdisorder ), intent(out) :: mag to keep track of all the coordination shells type(lo_symlist), intent(in) :: sl a symmetry table, useful for a bunch of stuff type(lo_crystalstructure), intent(in) :: uc unit cell type(lo_crystalstructure), intent(in) :: ss supercell","tags":"","loc":"module/magneticdisorder.html","title":"magneticdisorder – TDEP"},{"text":"Short description The main algorithm of the TDEP method. Starting with a symmetry analysis, this code finds the irreducible representation of interatomic forceconstants and extracts them from position and force data. Command line options: Optional switches: --secondorder_cutoff value , -rc2 value default value 5.0 Cutoff for the second order force constants --thirdorder_cutoff value , -rc3 value default value -1\n    mutually exclude \"--thirdorder_njump\" Cutoff for the third order force constants --fourthorder_cutoff value , -rc4 value default value -1\n    mutually exclude \"--fourthorder_njump\" Cutoff for the fourth order force constants --stride value , -s value default value 1 Use every N configuration instead of all. Useful for long MD simulations with linearly dependent configurations. --firstorder default value .false. Include the first order force constants. These can be used to find the finite temperature equilibrium structure. --residualfit default value .false. Fit the second order first, then the higher orders to the residual. --readforcemap default value .false. Read infile.forcemap.hdf5 from file instead of calculating all symmetry relations. Useful for sets of calculations with the same structure. --readirreducible default value .false. Read the irreducible forceconstants from infile.irrifc_* instead of solving for them. This option requires an infile.forcemap.hdf5 , as above. --potential_energy_differences , -U0 default value .false. Calculate the difference in potential energy from the simulation and the forceconstants to determine U0. As referenced in the thermodynamics section of phonon dispersion relations this is the renormalized baseline for the TDEP free energy: U_0= \\left\\langle U&#94;{\\textrm{BO}}(t)-\\frac{1}{2} \\sum_{ij}\\sum_{\\alpha\\beta} \\Phi_{ij}&#94;{\\alpha\\beta} \\mathbf{u}&#94;{\\alpha}_i(t) \\mathbf{u}&#94;{\\beta}_j(t) \\right\\rangle This number should be added to the appropriate phonon free energy. --printforcemap default value .false. Print outfile.forcemap.hdf5 for reuse. --polar default value .false. Add dipole-dipole corrections for polar materials. --polarcorrectiontype value , -pc value , value in: 1,2,3 default value 3 What kind of polar correction to use. --help , -h Print this help message --version , -v Print version Examples extract_forceconstants -rc2 5.1 extract_forceconstants -rc2 4.5 -rc3 3.21 Longer summary Calculations of the interatomic force constants are the most important part of any lattice dynamics calculation as they are used to calculate many micro and macroscopic properties of the system, e.g. phonon, thermodynamic, and transport properties, etc. This codes takes sets of displacements and forces, and uses these to fit the coefficients in an effective lattice dynamical Hamiltonian. This is by no means a new idea. 1 The main advantage of the TDEP method is in the implementation: it is numerically robust, well tested and general. It is not limited in order, nor limited to simple ordered systems. Lattice dynamics and interatomic force constants A quick recap of lattice dynamical theory: 2 a displacement $\\mathbf{u}$ of an atom $i$ from its ideal lattice position changes the potential energy of the lattice. Temperature disorders the lattice, causing all atoms to be displaced from their equilibrium positions; this effect can be modeled as a Taylor expansion of the potential energy contribution of the instantaneous positions of the atoms in the system, i.e. $U=U({ \\mathbf{r} })$. It is convenient to define the atomic positions as displacements $\\mathbf{u}$ from their equilibrium positions $\\mathbf{R}_i+\\boldsymbol{\\tau}_i$. \n\\begin{equation}\n\\textbf{r}_i=\\mathbf{R}_i+\\boldsymbol{\\tau}_i+\\mathbf{u}_i.\n\\end{equation}\n $\\mathbf{R}_i$ is a lattice vector and $\\boldsymbol{\\tau}_i$ is the position in the unit cell. We can then expand the potential energy in terms of displacements as: \n\\begin{equation}\n\\begin{split}\nU(\\{\\textbf{u}\\})=& U_0+\n\\sum_{i}\\sum_\\alpha\n\\Phi&#94;\\alpha_{i} u&#94;\\alpha_{i} +\n\\frac{1}{2!} \\sum_{ij} \\sum_{\\alpha\\beta} \\Phi&#94;{\\alpha\\beta}_{ij} u&#94;\\alpha_{i} u&#94;\\beta_{j} + \\\\\n + & \\frac{1}{3!} \\sum_{ijk} \\sum_{\\alpha\\beta\\gamma} \\Phi&#94;{\\alpha\\beta\\gamma}_{ijk} u&#94;\\alpha_{i} u&#94;\\beta_{j} u&#94;\\gamma_{k}+\n\\frac{1}{4!} \\sum_{ijkl} \\sum_{\\alpha\\beta\\gamma\\delta} \\Phi&#94;{\\alpha\\beta\\gamma\\delta}_{ijkl} u&#94;\\alpha_{i} u&#94;\\beta_{j} u&#94;\\gamma_{k} u&#94;\\delta_{l} + \\ldots\n \\end{split}\n\\end{equation}\n Here, $\\alpha\\beta\\gamma\\delta$ are Cartesian indices and $U_0$ is the potential energy of the static lattice. The coefficients of the Taylor expansion are the derivatives of the potential energy with respect to displacement and are called the Born-von Kàrmàn force constants, which can be expressed as tensors of increasing rank: \n\\begin{align}\n\\Phi&#94;\\alpha_i & = \\left. \\frac{\\partial U}{\\partial u_i&#94;\\alpha} \\right|_{u=0} = 0 \\\\\n\\Phi&#94;{\\alpha\\beta}_{ij} & = \\left. \\frac{\\partial&#94;2 U}{\\partial u_i&#94;\\alpha \\partial u_j&#94;\\beta} \\right|_{u=0} \\\\\n\\Phi&#94;{\\alpha\\beta\\gamma}_{ijk} & = \\left. \\frac{\\partial&#94;3 U}{\\partial u_i&#94;\\alpha \\partial u_j&#94;\\beta \\partial u_k&#94;\\gamma} \\right|_{u=0} \\\\\n\\Phi&#94;{\\alpha\\beta\\gamma\\delta}_{ijkl} & = \\left. \\frac{\\partial&#94;4 U}{\\partial u_i&#94;\\alpha \\partial u_j&#94;\\beta \\partial u_k&#94;\\gamma \\partial u_l&#94;\\delta} \\right|_{u=0}\n\\end{align}\n By increasing rank, the force constants of rank $n$ represent $n$-body interactions, as illustrated in the diagram below: Force constant symmetries Symmetry analysis allows us to greatly reduce the number of values needed to express the force constants (by multiple orders of magnitude, discussed more below) and is therefore crucial for generalizing the TDEP to include higher order terms in the potential energy surface. The symmetries of the force constants are deduced from rotational and translational invariance of the system, in addition to the symmetries of the crystal itself. We start with the transposition symmetries, which is an invariance under the permutation of the indices: 4 3 \n\\begin{align}\n\\Phi_{ij}&#94;{\\alpha\\beta} & = \\Phi_{ji}&#94;{\\beta\\alpha} \\\\\n\\Phi_{ijk}&#94;{\\alpha\\beta\\gamma} & = \\Phi_{jik}&#94;{\\beta\\alpha\\gamma} = \\ldots \\\\\n\\Phi_{ijkl}&#94;{\\alpha\\beta\\gamma\\delta} & = \\Phi_{jikl}&#94;{\\alpha\\beta\\gamma\\delta} = \\ldots\n\\end{align}\n All lattices belong to one of the 230 lattice space groups. The force constants should be invariant under these symmetry operations. If two tensors are related by symmetry operation $S$ their components are related as follows: \n\\begin{align}\n\\Phi_{ij}&#94;{\\alpha\\beta} &=\n\\sum_{\\mu\\nu}\\Phi_{kl}&#94;{\\mu\\nu}\nS&#94;{\\mu\\alpha}S&#94;{\\nu\\beta}  \\\\\n\\Phi_{ijk}&#94;{\\alpha\\beta\\gamma} &=\n\\sum_{\\mu\\nu\\xi}\\Phi_{mno}&#94;{\\mu\\nu\\xi}\nS&#94;{\\mu\\alpha} S&#94;{\\nu\\beta} S&#94;{\\xi\\gamma}\\\\\n\\Phi_{ijkl}&#94;{\\alpha\\beta\\gamma\\delta} &=\n\\sum_{\\mu\\nu\\xi\\kappa}\\Phi_{mnop}&#94;{\\mu\\nu\\xi\\kappa}\nS&#94;{\\mu\\alpha} S&#94;{\\nu\\beta} S&#94;{\\xi\\gamma} S&#94;{\\kappa\\delta} \\,.\\\\\n\\end{align}\n where $S&#94;{\\alpha\\beta}$ is the proper or improper rotation matrix of the symmetry operation $S$. Naturally, this will also enforce the periodic nature of the lattice. Force constants also obey the translational invariance (acoustic sum rules): \n\\begin{align}\n\\sum_j \\mathbf{\\Phi}_{ij} & =0 \\quad \\forall\\, i \\\\\n\\sum_k \\mathbf{\\Phi}_{ijk} & =0 \\quad \\forall\\, i,j \\\\\n\\sum_l \\mathbf{\\Phi}_{ijkl} & =0 \\quad \\forall\\, i,j,k\n\\end{align}\n The rotational invariance gives \n\\begin{align}\n\\sum_i \\Phi_i&#94;\\alpha r_i&#94;\\beta & = \\sum_i \\Phi_i&#94;\\beta r_i&#94;\\alpha \\quad \\forall \\, \\alpha,\\beta \\\\\n\\sum_j \\Phi_{ij}&#94;{\\alpha\\beta} r_j&#94;\\gamma + \\Phi_i&#94;\\beta \\delta_{\\alpha\\gamma} & =\n\\sum_j \\Phi_{ij}&#94;{\\alpha\\gamma} r_j&#94;\\beta + \\Phi_i&#94;\\gamma \\delta_{\\alpha\\beta}\n\\quad \\forall \\, \\alpha,\\beta,\\gamma \\\\\n\\sum_k \\Phi_{ijk}&#94;{\\alpha\\beta\\gamma}r_k&#94;\\lambda +  \\Phi_{ij}&#94;{\\gamma\\beta} \\delta_{\\alpha\\lambda} + \\Phi_{ij}&#94;{\\alpha\\gamma} \\delta_{\\beta\\lambda} &=\n\\sum_k \\Phi_{ijk}&#94;{\\alpha\\beta\\lambda}r_k&#94;\\gamma +  \\Phi_{ij}&#94;{\\lambda\\beta} \\delta_{\\alpha\\gamma} + \\Phi_{ij}&#94;{\\alpha\\lambda} \\delta_{\\beta\\gamma}\n\\quad \\forall \\, \\alpha,\\beta,\\gamma,\\lambda \\\\\n\\end{align}\n And finally, the Huang invariances \n\\begin{align}\n[\\alpha\\beta,\\gamma\\lambda] & = \\sum_{ij} \\Phi_{ij}&#94;{\\alpha\\beta} r_{ij}&#94;\\gamma r_{ij}&#94;\\lambda \\\\\n[\\alpha\\beta,\\gamma\\lambda] & = [\\gamma\\lambda,\\alpha\\beta]\n\\end{align}\n ensure that the second order forceconstants, when taken to the long-wavelength limit, result in the correct number of elastic constants. For low-symmetry crystals the Hermitian character of the dynamical matrix is enforced: 9 8 \n\\begin{equation}\n    \\sum_{j \\ne i} \\Phi&#94;{\\alpha\\beta}_{ij} = \\sum_{j \\ne i} \\Phi&#94;{\\beta\\alpha}_{ij} \\quad \\forall\\, i\n\\end{equation}\n All the symmetry relations above are naturally satisfied by the force constants produced by this code. Effective Hamiltonian The traditional lattice dynamical Hamiltonian described above has severe limitations, in that it's deduced from the derivatives of zero temperature configuration of the crystal. The form of the Hamiltonian is however beneficial: the second order forceconstants produce an exactly solvable Hamiltonian and with phonon quasiparticles, and the higher order terms can be treated as perturbations. To extend the usefulness of this Hamiltonian, we give up the constraint that the force constants are derivatives of the zero temperature configurations. Instead, the force constant tensors are just parameters in an effective Hamiltonian that are left to be determined. Schematically, self-consistent or effective phonon theories can be split into two parts: the first part is revolves around how to sample the Born-Oppenheimer surface, the second part around how to use that data to produce an effective Hamiltonian. Sampling phase space The most straightforward way to sample the Born-Oppenheimer surface is to use molecular dynamics. This can be costly, although I provided some tools to make it faster: parallelizing over different random seeds combined with selective upsampling certainly makes it feasible. For systems with significant nuclear quantum effects, path integral molecular dynamics is preferred. The cost of these can be quite significant, but similar acceleration techniques can be used. If you care predominantly about speed, stochastic sampling might be preferred. The way the Born-Oppenheimer surface is sampled does not influence the TDEP algorithms in any way. I even consider stochastic sampling using the zero-point the preferred way of calculating the true zero temperature force constants. The only thing required of the sampling is that it provides a set of forces, $\\mathbf{f}&#94;{\\textrm{BO}}$, and displacements $\\mathbf{u}$. Obtaining an effective Hamiltonian The basic premise is to use a model Hamiltonian (where orders beyond pair interactions are optional) given by \n\\begin{equation}\\label{eq:hamiltonian}\n\\hat{H}= U_0+\\sum_i \\frac{\\textbf{p}_i&#94;2}{2m_i}+\n\\frac{1}{2!}\\sum_{ij} \\sum_{\\alpha\\beta}\\Phi_{ij}&#94;{\\alpha\\beta}\nu_i&#94;\\alpha u_j&#94;\\beta +\\frac{1}{3!}\n\\sum_{ijk} \\sum_{\\alpha\\beta\\gamma}\\Phi_{ijk}&#94;{\\alpha\\beta\\gamma}\nu_i&#94;\\alpha u_j&#94;\\beta u_k&#94;\\gamma \\ldots\n\\end{equation}\n and match the forces of the model, $\\mathbf{f}&#94;{\\textrm{M}}$ to $\\mathbf{f}&#94;{\\textrm{BO}}$. 7 , 6 , 5 A brute force minimization is certainly possible, but the current implementation is a bit more sophisticated. The forces of the model Hamiltonian are given by \n\\begin{equation}\nf&#94;{\\mathrm{M}}_{i\\alpha}=\n-\\sum_{j\\beta}\\Phi_{ij}&#94;{\\alpha\\beta}u_j&#94;\\beta\n-\\frac{1}{2}\\sum_{jk\\beta\\gamma}\\Phi_{ijk}&#94;{\\alpha\\beta\\gamma}u_j&#94;\\beta u_k&#94;\\gamma + \\ldots\n\\end{equation}\n To exploit the symmetry relations, we populate each tensor component with a symbolic variable, called $\\theta$. The index $k$ runs from 1 to the total number of components in all tensors. We include all tensors within a cutoff radius $\\textbf{r}_c$ (the maximum cutoff is determined by the simulation cell size). Using symmetries we figure out which tensor components are unique by accounting for those components that are either 0 or equal to another tensor component. This drastically reduces the number of values that have to be determined. With the symmetry irreducible representation at hand, we express the forces in the model Hamiltonian: \n\\begin{equation}\nf&#94;{\\mathrm{M}}_{i\\alpha}=\n\\sum_k \\theta_k c_k&#94;{i\\alpha}(\\mathbf{U}).\n\\end{equation}\n Here $c_k&#94;{i\\alpha}(\\mathbf{U})$, the coefficient for each $\\theta_k$ is a polynomial function of all displacements within $\\textbf{R}_c$. The form of this function depends on the crystal at hand (see the minimal example below). For a given supercell, we can express the vector of all forces in the cell as a matrix product: \n\\begin{equation}\n\\underbrace{\\mathbf{F}&#94;{\\mathrm{M}}}_{3N_a \\times 1}=\n\\underbrace{\\mathbf{C}(\\mathbf{u})}_{3N_a \\times N_{\\theta}}\n\\underbrace{\\mathbf{\\Theta}}_{N_{\\theta} \\times 1}\n\\end{equation}\n where the underbraces denote size of the matrices. The coefficient matrix $\\mathbf{C}$ is a function of all the displacements in the supercell. $\\mathbf{\\Theta}$ is a vector holding all the $\\theta_k$. Then we seek the $\\mathbf{\\Theta}$ that minimizes the difference between the model system and the ab initio one: \n\\begin{equation}\n\\begin{split}\n\\min_{\\Theta}\\Delta \\mathbf{F} & =\n\\frac{1}{N_c} \\sum_{c=1}&#94;{N_c}  \\left| \\mathbf{F}_c&#94;{\\textrm{BO}}-\\mathbf{F}_c&#94;{\\textrm{M}} \\right|&#94;2= \\\\\n& =\\frac{1}{N_c} \\sum_{c=1}&#94;{N_c} \\left| \\mathbf{F}_c&#94;{\\textrm{BO}}-\\mathbf{C}(\\mathbf{u}_{c})\\mathbf{\\Theta} \\right|&#94;2 = \\\\\n& = \\frac{1}{N_c} \\left\\Vert\n\\begin{pmatrix} \\mathbf{F}_1&#94;{\\textrm{BO}} \\\\  \\vdots \\\\ \\mathbf{F}_{N_c}&#94;{\\textrm{BO}} \\end{pmatrix}-\n\\begin{pmatrix} \\mathbf{C}(\\mathbf{u}_1) \\\\ \\vdots \\\\ \\mathbf{C}(\\mathbf{u}_{N_c}) \\end{pmatrix}\n\\mathbf{\\Theta}\n\\right\\Vert\n\\end{split}\n\\end{equation}\n Here $N_c$ is the number of supercell configurations used to sample the Born-Oppenheimer surface. A least squares solution, \n\\begin{equation}\n\\mathbf{\\Theta}=\n\\begin{pmatrix}\n\\mathbf{C}(\\mathbf{u}_1) \\\\\n\\vdots \\\\\n\\mathbf{C}(\\mathbf{u}_{N_c})\n\\end{pmatrix}&#94;{+}\n\\begin{pmatrix}\n\\mathbf{F}&#94;{\\textrm{BO}}_1 \\\\\n\\vdots \\\\\n\\mathbf{F}&#94;{\\textrm{BO}}_{N_c}\n\\end{pmatrix}\n\\end{equation}\n gives the $\\mathbf{\\Theta}$ that minimizes these forces. Then, with a simple substitution back into \\mathbf{\\Phi}_{ij} and $\\mathbf{\\Phi}_{ijk}$ we determine the quadratic and cubic force constants. Note all orders of force constants are extracted from the same set of displacements and forces, simultaneously.","tags":"","loc":"program/extract_forceconstants.html","title":"\n    \n        extract forceconstants – TDEP\n    \n"},{"text":"Short description This code serves as a diagnostic tool to check that symmetry heuristics are working as they should. The code prints which Bravais lattice was identified, which high symmetry points in the BZ are inequivalent, and so on. The Brillouin zone and its irreducible wedges are printed to files as polyhedra for manual inspection, and the symmetry operations of the lattice can be printed. Command line options: Optional switches: --printsymmetry default value .false. Also prints the symmetry operations --help , -h Print this help message --version , -v Print version Examples crystal_structure_info crystal_structure_info --printsymmetry Long summary This is mainly a diagnostic tool, to make sure that my heuristics are working as they should. For example, if you want to calculate fcc Al, and things look strange, run this code to make sure that the symmetry detection actually identifies it as fcc. As a bonus, the Brillouin zone and the irreducible wedge is printed to file, so that you can make figures like the one below. Input files infile.ucposcar Output files outfile.brillouin_zone.hdf5 This contains the information to produce the plot above. I did it with the following matlab snippet: % read all the stuff fn = 'outfile.brillouin_zone.hdf5' ; zone_nodes = h5read ( fn , '/zone_nodes' ) ' ; wedge_nodes = h5read ( fn , '/wedge_nodes' ) ' ; nf = h5readatt ( fn , '/' , 'number_of_zone_faces' ); for i = 1 : nf zone_faces { i }= h5read ( fn ,[ '/zone_face_' num2str ( i )]); end nf = h5readatt ( fn , '/' , 'number_of_wedge_faces' ); for i = 1 : nf wedge_faces { i }= h5read ( fn ,[ '/wedge_face_' num2str ( i )]); end labels = strsplit ( h5readatt ( fn , '/' , 'wedge_node_labels' )); figure ( 1 ); clf ; hold on ; axis equal off ; view ( 3 ); camlight ; i = drawPolyhedron ( zone_nodes , zone_faces ); set ( i , 'facealpha' , 0.3 ) j = drawPolyhedron ( wedge_nodes , wedge_faces ); set ( j , 'facealpha' , 0.3 , 'facecolor' , 'blue' ) for i = 1 : length ( labels ) text ( wedge_nodes ( i , 1 ), wedge_nodes ( i , 2 ), wedge_nodes ( i , 3 ), labels { i }) end This requires the Geom3D package. outfile.qpoints_dispersion This is a prototype version of infile.qpoints_dispersion , so that you don't have to start from nothing when changin the path. It can look like this: FCC                         ! Bravais lattice type\n  100                       ! Number of points on each path\n    4                       ! Number paths between special points\nGM  X                       ! Starting and ending special point\nX   U                       !\nK   GM                      !\nGM  L                       ! It might not agree with my canonical form. Find the primitive cell reduce a set of lattice vectors to canonical form","tags":"","loc":"program/crystal_structure_info.html","title":"\n    \n        crystal structure info – TDEP\n    \n"},{"text":"Short description Calculate phonon dispersions and related quantities. Per default, only the dispersions along a default path will be calculated. Options are available for calculating mode gruneisen parameters, phonon density of states projected in a variety of ways, thermodynamic quantities and pure data dumps. Command line options: Optional switches: --unit value , value in: thz,mev,icm default value thz Choose the output unit. The options are terahertz (in frequency, not angular frequency), inverse cm or meV. --nq_on_path value , -nq value default value 100 Number of q-points between each high symmetry point --readpath , -rp default value .false. Read the q-point path from infile.qpoints_dispersion . Use crystal structure into to generate an example. --dos default value .false. Calculate the phonon DOS --qpoint_grid value#1 value#2 value#3 , -qg value#1 value#2 value#3 default value 26 26 26 Density of q-point mesh for Brillouin zone integrations. --meshtype value , value in: 1,2,3 default value 1 Type of q-point mesh. 1 Is a Monkhorst-Pack mesh, 2 an FFT mesh and 3 my fancy wedge-based mesh with approximately the same density the grid-based meshes. --sigma value default value 1.0 Global scaling factor for the Gaussian/adaptive Gaussian smearing. The default is determined procedurally, and scaled by this number. --readqmesh default value .false. Read the q-point mesh from file. To generate a q-mesh file, see the genkpoints utility. --integrationtype value , -it value , value in: 1,2,3,4 default value 2 Type of integration for the phonon DOS. 1 is Gaussian, 2 adaptive Gaussian and 3 Tetrahedron. --dospoints value default value 400 Number of points on the frequency axis of the phonon dos. --temperature value default value -1 Evaluate thermodynamic phonon properties at a single temperature. --temperature_range value#1 value#2 value#3 default value -1 -1 -1 Evaluate thermodynamic phonon properties for a series of temperatures, specify min, max and the number of points. --gruneisen default value .false. Use third order force constants to calculate mode Gruneisen parameters. --dumpgrid default value .false. Write files with q-vectors, frequencies, eigenvectors and group velocities for a grid. --help , -h Print this help message --version , -v Print version Examples phonon_dispersion_relations phonon_dispersion_relations --dos -qgrid 24 24 24 -loto --integrationtype 2 This code calculates the phonon dispersions, $ \\omega(\\mathbf{q}) $. It can output dispersions along a line in the Brillouin zone, output frequencies on a grid, or calculate the phonon DOS. In addition it can calculate the mode Grüneisen parameters. By default, minimal input is needed, but many options to tailor the output exist. Equations of motion in a harmonic crystal As detailed in extract forceconstants we have mapped the Born-Oppenheimer to an effective potential. A model Hamiltonian truncated at the second order (a harmonic Hamiltonian) is given by 1 \n\\begin{equation}\n\\hat H=\\sum_{\\kappa} \\frac{\\mathbf{p}_{\\kappa}&#94;2}{2m_{\\kappa}} + \\frac{1}{2} \\sum_{\\kappa\\lambda}\\sum_{\\alpha\\beta}  \\Phi_{\\kappa\\lambda}&#94;{\\alpha\\beta} u&#94;{\\alpha}_{\\kappa} u&#94;{\\beta}_{\\lambda}\\,\n\\end{equation}\n Where $\\kappa,\\lambda$ are indices to atoms, $\\alpha,\\beta$ Cartesian indices and $\\mathbf{u}$ a displacement from equilibrium positions. To clarify, the instantaneous position of an atom is given by \n\\begin{equation}\n\\mathbf{r}_{\\kappa} = \\mathbf{R}_{\\mu} + \\boldsymbol{\\tau}_{i} + \\mathbf{u}\n\\end{equation}\n such that $\\mathbf{R} +\\boldsymbol{\\tau}$ denote the equilibrium position of the atom. The lattice vector $\\mathbf{R}$ locate the unit cell, $\\boldsymbol{\\tau}$ locate the atom in the unit cell, and $\\mathbf{u}$ how far the atom has moved from the reference positions. Ignoring surface effects, we can write the equations of motion: \n\\begin{equation}\n\\ddot{\\mathbf{u}}_{\\mu i} m_{\\mu i} =\n-\\sum_{\\nu j} \\mathbf{\\Phi}_{\\mu i,\\nu j}\\mathbf{u}_{\\nu j} \\,.\n\\end{equation}\n Here we expanded the atom index $\\kappa$ to the double index indicating cell $\\mu$ and position $i$. Since we deal with infinite crystals with periodic boundary conditions, the equations of motion will not depend on cell index $\\mu$, and that index can be dropped. \n\\begin{equation}\\label{eq:eqmotion1}\n\\ddot{\\mathbf{u}}_{i} m_{i} =\n-\\sum_{\\nu j} \\mathbf{\\Phi}_{\\mu i,\\nu j}\\mathbf{u}_{\\nu j}.\n\\end{equation}\n I prefer a truncated notation: \n\\begin{equation}\n\\ddot{\\mathbf{u}}_{i} m_{i} =\n-\\sum_{\\mathbf{R}} \\mathbf{\\Phi}_{ij}\\left( \\mathbf{R} \\right)\\mathbf{u}_{j}.\n\\end{equation}\n Where $\\mathbf{R}$ implies the cell index corresponding to atom $j$. To solve these equations of motion, we can use a plane-wave ansatz: \n\\begin{equation}\n\\mathbf{u}_{i}=\\frac{1}{\\sqrt{m_i}} \\sum_{\\mathbf{q}} A_{\\mathbf{q}} \\boldsymbol{\\epsilon}_{\\mathbf{q}}&#94;{i} e&#94;{ i \\left(\\mathbf{q} \\cdot \\mathbf{R} - \\omega t \\right) }.\n\\end{equation}\n Here the displacements are expressed as a sum of plane waves, or normal modes, each with wave vector $\\mathbf{q}$ and frequency $\\omega$. $\\boldsymbol{\\epsilon}$ is a polarisation vector, and $A_{\\mathbf{q}}$ the normal mode amplitude. Substituting this into $\\eqref{eq:eqmotion1}$ and exploiting the orthogonality of planes waves gives, \n\\begin{split}\n\\sqrt{m_i}\\sum_{\\mathbf{q}} \\omega&#94;2 A_{\\mathbf{q}} \\boldsymbol{\\epsilon}_{\\mathbf{q}}&#94;{i} e&#94;{ i \\left(\\mathbf{q} \\cdot \\mathbf{R}_i - \\omega t \\right) }\n= &\n\\sum_{\\mathbf{R}}\\sum_{\\mathbf{q}}\n\\frac{A_{\\mathbf{q}} \\boldsymbol{\\epsilon}_{\\mathbf{q}}&#94;{i}}{\\sqrt{m_j}}\n\\mathbf{\\Phi}_{ij}\\left( \\mathbf{R}_j \\right)\ne&#94;{ i \\left(\\mathbf{q} \\cdot \\mathbf{R}_j - \\omega t \\right) } \\\\\n%\n%\n\\sum_{\\mathbf{q}} \\omega&#94;2 A_{\\mathbf{q}} \\boldsymbol{\\epsilon}_{\\mathbf{q}}&#94;{i} e&#94;{ i \\mathbf{q} \\cdot \\mathbf{R}_i }\n= &\n\\sum_{\\mathbf{R}}\\sum_{\\mathbf{q}}\n\\frac{A_{\\mathbf{q}} \\boldsymbol{\\epsilon}_{\\mathbf{q}}&#94;{i}}{\\sqrt{m_i m_j}}\n\\mathbf{\\Phi}_{ij}\\left( \\mathbf{R}_j \\right)\ne&#94;{ i \\mathbf{q} \\cdot \\mathbf{R}_j } \\\\\n%\n%\n\\sum_{\\mathbf{q}'} \\omega&#94;2 A_{\\mathbf{q}'} \\boldsymbol{\\epsilon}_{\\mathbf{q}'}&#94;{i} e&#94;{ i \\mathbf{q}' \\cdot \\mathbf{R}_i }\ne&#94;{ -i \\mathbf{q} \\cdot \\mathbf{R}_i }\n= &\n\\sum_{\\mathbf{R}}\\sum_{\\mathbf{q}'}\n\\frac{A_{\\mathbf{q}'} \\boldsymbol{\\epsilon}_{\\mathbf{q}'}&#94;{i}}{\\sqrt{m_i m_j}}\n\\mathbf{\\Phi}_{ij}\\left( \\mathbf{R}_j \\right)\ne&#94;{ i \\mathbf{q}' \\cdot \\mathbf{R}_j }\ne&#94;{ -i \\mathbf{q} \\cdot \\mathbf{R}_i } \\\\\n%\n%\n\\omega&#94;2 A_{\\mathbf{q}} \\boldsymbol{\\epsilon}_{\\mathbf{q}}&#94;{i}\n= &\nA_{\\mathbf{q}} \\boldsymbol{\\epsilon}_{\\mathbf{q}}&#94;{i}\n\\sum_{\\mathbf{R}}\n\\frac{\\mathbf{\\Phi}_{ij}\\left( \\mathbf{R}_j \\right)}{\\sqrt{m_i m_j}}\ne&#94;{ i \\mathbf{q} \\cdot \\mathbf{R}_j } \\\\\n%\n%\n\\omega&#94;2_{\\mathbf{q}} \\boldsymbol{\\epsilon}_{\\mathbf{q}}= & \\mathbf{\\Phi}(\\mathbf{q}) \\boldsymbol{\\epsilon}_{\\mathbf{q}}\\,,\n\\end{split}\n where the periodic boundary conditions limit the choices of $\\mathbf{q}$ to a wave vector $\\mathbf{q}$ in the first Brillouin zone. The dynamical matrix $\\mathbf{\\Phi}(\\mathbf{q})$ is given by \n\\begin{equation}\n\\mathbf{\\Phi}(\\mathbf{q})=\n\\begin{pmatrix}\n\\mathbf{\\Phi}_{11}(\\mathbf{q}) & \\cdots & \\mathbf{\\Phi}_{N 1}(\\mathbf{q}) \\\\\n\\vdots & \\ddots & \\vdots \\\\\n\\mathbf{\\Phi}_{1N}(\\mathbf{q}) & \\cdots & \\mathbf{\\Phi}_{N N}(\\mathbf{q}) \\\\\n\\end{pmatrix}\n\\end{equation}\n This is the Fourier transform of the mass-weighted force constant matrix, where each $3 \\times 3$ submatrix of the full $3N \\times 3N$ is given by \n\\begin{equation}\n\\mathbf{\\Phi}_{ij}(\\mathbf{q})=\n\\sum_{\\mathbf{R}}\n\\frac{ \\mathbf{\\Phi}_{ij}(\\mathbf{R}) }{\\sqrt{m_i m_j}}  \ne&#94;{i\\mathbf{q}\\cdot \\mathbf{R}} \\,.\n\\end{equation}\n The eigenvalues $\\omega&#94;2_{\\mathbf{q}s}$ and eigenvectors $\\boldsymbol{\\epsilon}_{\\mathbf{q}s}$ of the dynamical matrix denote the possible normal mode frequencies and polarizations of the system. The eigenvalues have the same periodicity as the reciprocal lattice; hence it is convenient to limit the solution to all vectors $\\mathbf{q}$ in the first Brillouin zone. It is also worth defining the partial derivatives of the dynamical matrix: \n\\begin{equation}\n\\frac{\\partial \\mathbf{\\Phi}_{ij}(\\mathbf{q})}{\\partial q_\\alpha}\n=\n\\sum_{\\mathbf{R}}\niR_\\alpha\n\\frac{ \\mathbf{\\Phi}_{ij}(\\mathbf{R}) }{\\sqrt{m_i m_j}}  \ne&#94;{i\\mathbf{q}\\cdot \\mathbf{R}}.\n\\end{equation}\n By calculating the eigenvalues and eigenvectors of the dynamical matrix over the Brillouin zone, all thermodynamic quantities involving the atomic motions can be determined, as far as the harmonic approximation is valid. If you are curious where the amplitudes of the normal modes disappeared, see canonical configuration . Long-ranged interactions in polar materials When determining the dynamical matrix, the sum over lattice vectors $\\mathbf{R}$ should in principle be carried out over all pairs. In practice, we assume that the interactions are zero beyond some cutoff (see extract forceconstants option -rc2 ), and truncate the sum. This is not a valid approach when dealing with polar material where the induced dipole-dipole interactions are essentially infinite-ranged. See for example Gonze & Lee. 5 6 When dealing with these long-ranged electrostatics we start by defining the Born effective charge tensor: \nZ_{i}&#94;{\\alpha\\beta} = \\frac{\\partial&#94;2 U}{\\partial \\varepsilon&#94;{\\alpha} \\partial u_{i}&#94;{\\beta}}\n That is the mixed derivative of the energy with respect to electric field $\\varepsilon$ and displacement $\\mathbf{u}$. Displacing an atom from its equilibrium position induces a dipole, given by \n\\mathbf{d}_{i} = \\mathbf{Z}_{i}\\mathbf{u}_{i}\n The pairwise dipole-dipole interactions can be expressed as forceconstants: \n\\begin{align}\n\\Phi&#94;{\\textrm{dd}}|&#94;{\\alpha\\beta}_{ij} & = \\sum_{\\gamma\\delta} Z_{i}&#94;{\\alpha\\gamma}Z_{j}&#94;{\\beta\\delta} \\widetilde{\\Phi}&#94;{\\gamma\\delta}_{ij} \\\\\n\\widetilde{\\Phi}&#94;{\\alpha\\beta}_{ij} & =\n\\frac{1}{4\\pi\\epsilon_0}\n\\frac{1}{\\sqrt{\\det \\epsilon}}\n\\left(\n    \\frac\n    { \\widetilde{\\epsilon}&#94;{\\alpha\\beta} }\n    {|\\Delta_{ij}|_{\\epsilon}&#94;{3}}\n    -3 \\frac\n    {\\Delta_{ij}&#94;{\\alpha}\\Delta_{ij}&#94;{\\beta}}\n    {|\\Delta_{ij}|_{\\epsilon}&#94;{5}}\n\\right)\n\\end{align}\n Here $\\boldsymbol{\\epsilon}$ is the dielectric tensor, $\\widetilde{\\boldsymbol{\\epsilon}}=\\boldsymbol{\\epsilon}&#94;{-1}$ its inverse and $\\Delta$ realspace distances using the dielectric tensor as a metric: \n\\begin{align}\n\\mathbf{r}_{ij} & = \\mathbf{R}_{j}+\\mathbf{\\tau}_j-\\mathbf{\\tau}_i \\\\\n\\mathbf{\\Delta}_{ij} & =\\widetilde{\\boldsymbol{\\epsilon}}\\mathbf{r}_{ij} \\\\\n|\\Delta_{ij}|_{\\epsilon} & = \\sqrt{\\mathbf{\\Delta}_{ij} \\cdot \\mathbf{r}_{ij}}\n\\end{align}\n This poses an issue when calculating the dynamical matrix: the interactions die off as $~1/r&#94;{3}$ which makes it necessary to extend the sum over lattice vectors to infinity. This is remedied with the usual Ewald technique: \n\\widetilde{\\mathbf{\\Phi}}_{ij} (\\mathbf{q})=\n\\widetilde{\\mathbf{\\Phi}}&#94;\\textrm{r}+\\widetilde{\\mathbf{\\Phi}}&#94;\\textrm{q}+\\widetilde{\\mathbf{\\Phi}}&#94;\\textrm{c}\n Dividing the sum into a realspace part, a reciprocal part and a connecting part. The realspace part is given by \n\\begin{align}\n\\widetilde{\\mathbf{\\Phi}}&#94;\\textrm{r}_{ij} & =\n-\\frac{\\Lambda&#94;3}{4\\pi\\epsilon_0\\sqrt{\\det \\epsilon}}\n\\sum_{\\mathbf{R}}\n\\mathbf{H}(\\Lambda \\Delta_{ij},\\Lambda|\\Delta_{ij}|_{\\epsilon})\ne&#94;{i \\mathbf{q} \\cdot \\mathbf{R}} \\\\\n%%\n\\frac{\\partial \\widetilde{\\mathbf{\\Phi}}&#94;\\textrm{r}_{ij}}{\\partial q_\\alpha}  & =\n-\\frac{\\Lambda&#94;3}{4\\pi\\epsilon_0\\sqrt{\\det \\epsilon}}\n\\sum_{\\mathbf{R}}\niR_\\alpha\n\\mathbf{H}(\\Lambda \\Delta_{ij},\\Lambda|\\Delta_{ij}|_{\\epsilon})\ne&#94;{i \\mathbf{q} \\cdot \\mathbf{R}}\n\\end{align}\n where \nH_{\\alpha\\beta}(\\mathbf{x},y) = \\frac{x_{\\alpha}x_{\\beta} }{y&#94;2}\n\\left[\n\\frac{3\\,\\textrm{erfc}\\,y}{y&#94;3}\n+\n\\frac{2 e&#94;{-y&#94;2}}{\\sqrt{\\pi}}\\left(\\frac{3}{y&#94;2}+2 \\right)\n\\right]\n-\\widetilde{\\epsilon}_{\\alpha\\beta}\n\\left[\n\\frac{\\textrm{erfc}\\,y}{y&#94;3} + \\frac{2 e&#94;{-y}}{\\sqrt{\\pi} y&#94;2 }\n\\right]\\,.\n In reciprocal space we have \n\\begin{align}\n%\n% Not derivative\n%\n    \\widetilde{\\Phi}_\\textrm{q}|_{ij}\n    &=\n    \\sum_{\\mathbf{K}=\\mathbf{G}+\\mathbf{q}}\n    \\chi_{ij}(\\mathbf{K},\\Lambda)\n    \\left( \\mathbf{K}\\otimes\\mathbf{K} \\right) \\\\\n%\n% X-direction\n%\n    \\frac{\\partial}{\\partial q_x} \\widetilde{\\Phi}_\\textrm{q}|_{ij}\n    %\n    &=\n    \\sum_{\\mathbf{K}=\\mathbf{G}+\\mathbf{q}}\n    \\chi_{ij}(\\mathbf{K},\\Lambda)\n    \\left( \\mathbf{K}\\otimes\\mathbf{K} \\right)\n    %\n    \\left(\n    i\\tau&#94;x_{ij} - \\left[\\sum_{\\alpha} K_\\alpha \\epsilon_{\\alpha x}\n    \\right]\n    \\left[ \\frac{1}{\\|\\mathbf{K}\\|_{\\epsilon}}+\\frac{1}{4\\Lambda&#94;2} \\right]\n    \\right) +\n    %\n    \\chi_{ij}(\\mathbf{K},\\Lambda)\n    \\begin{pmatrix}\n    2K_x & K_y & K_z \\\\\n    K_y & 0 & 0 \\\\\n    K_z & 0 & 0\n    \\end{pmatrix} \\\\\n%\n% Y-direction\n%\n    \\frac{\\partial}{\\partial q_y} \\widetilde{\\Phi}_\\textrm{q}|_{ij}\n    %\n    &=\n    \\sum_{\\mathbf{K}=\\mathbf{G}+\\mathbf{q}}\n    \\chi_{ij}(\\mathbf{K},\\Lambda)\n    \\left( \\mathbf{K}\\otimes\\mathbf{K} \\right)\n    %\n    \\left(\n    i\\tau&#94;y_{ij} - \\left[\\sum_{\\alpha} K_\\alpha \\epsilon_{\\alpha y}\n    \\right]\n    \\left[ \\frac{1}{\\|\\mathbf{K}\\|_{\\epsilon}}+\\frac{1}{4\\Lambda&#94;2} \\right]\n    \\right) +\n    %\n    \\chi_{ij}(\\mathbf{K},\\Lambda)\n    \\begin{pmatrix}\n    0 & K_x & 0 \\\\\n    K_y & 2K_y & K_z \\\\\n    0 & K_z & 0\n    \\end{pmatrix}\\\\\n%\n% Z-direction\n%\n    \\frac{\\partial}{\\partial q_z} \\widetilde{\\Phi}_\\textrm{q}|_{ij}\n    %\n    &=\n    \\sum_{\\mathbf{K}=\\mathbf{G}+\\mathbf{q}}\n    \\chi_{ij}(\\mathbf{K},\\Lambda)\n    \\left( \\mathbf{K}\\otimes\\mathbf{K} \\right)\n    %\n    \\left(\n    i\\tau&#94;z_{ij} - \\left[\\sum_{\\alpha} K_\\alpha \\epsilon_{\\alpha z}\n    \\right]\n    \\left[ \\frac{1}{\\|\\mathbf{K}\\|_{\\epsilon}}+\\frac{1}{4\\Lambda&#94;2} \\right]\n    \\right) +\n    %\n    \\chi_{ij}(\\mathbf{K},\\Lambda)\n    \\begin{pmatrix}\n    0 & 0 & K_x \\\\\n    0 & 0 & K_y \\\\\n    K_z & K_y & 2K_z\n    \\end{pmatrix}\n\\end{align}\n where \n\\begin{align}\n\\chi_{ij}(\\mathbf{K},\\Lambda) &  =\n\\frac{1}{\\Omega\\epsilon_0}\n\\frac{\n\\exp\\left(i \\mathbf{q} \\cdot \\mathbf{\\tau}_{ij} \\right)\n\\exp\\left( -\\frac{\\|\\mathbf{K}\\|_{\\epsilon}}{4\\Lambda&#94;2}  \\right)\n}\n{\\|\\mathbf{K}\\|_{\\epsilon}} \\\\\n%%\n\\|\\mathbf{K}\\|_{\\epsilon} & =\\sum_{\\alpha\\beta}\\epsilon_{\\alpha\\beta}K_\\alpha K_\\beta\n\\end{align}\n and finally a connecting part given by \n\\widetilde{\\mathbf{\\Phi}}_\\textrm{c}|_{ij}=\n\\delta_{ij}\n\\frac{\\Lambda&#94;3}{3 \\epsilon_0 \\pi&#94;{3/2} \\sqrt{ \\det \\boldsymbol{\\epsilon} } }\n\\widetilde{\\boldsymbol{\\epsilon}}\n This expression is invariant for any $\\Lambda>0$, which is chosen to make the real and reciprocal sums converge with as few terms as possible. Note that the Born charges are factored out from $\\widetilde{\\mathbf{\\Phi}}$, and have to by multiplied in as described above. The derivatives with respect to $q$ are reproduced because they are useful when calculating the gradient of the dynamical matrix, needed when determining group velocities. In the long-wavelength limit, $\\mathbf{q}\\rightarrow 0$, the dipole-dipole dynamical matrix reduces to the familiar non-analytical term: \n\\lim_{\\mathbf{q}\\rightarrow 0} \\mathbf{\\Phi}(\\mathbf{q}) =\n\\frac{1}{\\Omega\\epsilon_0}\n\\frac{\n\\left(\\mathbf{Z}_i\\mathbf{q}\\right) \\otimes \\left(\\mathbf{Z}_j\\mathbf{q}\\right)\n}{\\mathbf{q}&#94;T\\boldsymbol{\\epsilon}\\mathbf{q}}\n This package implements three different ways of dealing with these long-ranged interactions. For historical reasons, the so-called mixed-space approach is available, but it should not be used except as an example of what not to do. The technical issue is that the forces from a DFT calculation are not separated cleanly into \"electrostatic longrange\" and \"everything else\" components. The TDEP approach allows for two variants to separate this: Separation approach 1 This is the approach proposed by Gonze & Lee 6 , only slightly adjusted since they assumed you start with reciprocal space dynamical matrices, whereas I start with realspace forceconstants. Algorithmically, it works like this: Define a $N_a \\times N_b \\times N_c$ suprecell, large enough that it snugly fits your realspace forceconstants. Calculate the electrostatic dynamical matrices on a $N_a \\times N_b \\times N_c$ $q$-mesh. Inverse fourier transform the electrostatic dynamical matrices to realspace forceconstants:\n\n\\mathbf{\\Phi}&#94;{\\textrm{dd}}_{ij}(\\mathbf{R}) =\\frac{ \\sqrt{m_i m_j} }{N_a N_b N_c} \\sum_{\\mathbf{q}}  \\Phi&#94;{\\textrm{dd}}_{ij}(\\mathbf{q}) e&#94;{-i\\mathbf{q} \\cdot \\mathbf{R}}\n Subtract these from the realspace forceconstants:\n\n\\hat{\\mathbf{\\Phi}}_{ij}(\\mathbf{R})=\n\\mathbf{\\Phi}_{ij}(\\mathbf{R})-\n\\mathbf{\\Phi}&#94;{\\textrm{dd}}_{ij}(\\mathbf{R})\n Calculate the dynamical matrix as a sum of the short- and long-ranged contributions:\n\n\\mathbf{\\Phi}_{ij}(\\mathbf{q}) = \\hat{\\mathbf{\\Phi}}_{ij}(\\mathbf{R}) + \\Phi&#94;{\\textrm{dd}}_{ij}(\\mathbf{q})\n At $\\mathbf{q}=0$ the non-analytcal contribution has to be added as well. This approach is reasonably robust, and works well in most materials. However, there are some aliasing contributions added since the realspace forceconstants are truncated by distance, and I propose a slight variation of this scheme: Separation approach 2 This idea is similar in spirit, but does the separation into long- and short-ranged interactions at an earlier stage. Todo Fill this in once published. Mixed-space approach This is implemented for historical reasons and for comparison, but disabled by default. It should not be used for anything, it is incorrect, and doing it right cost nothing. Harmonic thermodynamics In the previous section, we treated the vibrations of atoms classically, by solving Newton's equations of motion. Quantum-mechanically, vibrational normal modes can be represented as quasi-particles called phonons, quanta of thermal energy. We note that our normal mode transformation is a sum over eigenfunctions of independent harmonic oscillators. This allows us to write the position and momentum operators in terms of creation and annihilation operators (without loss of generality, we can contract the notation for phonon mode $s$ at wave vector $\\mathbf{q}$ to a single index $\\lambda$): \n\\begin{align}\n\\hat{u}_{i\\alpha} = & \\sqrt{ \\frac{\\hbar}{2N m_\\alpha} }\n\\sum_\\lambda \\frac{\\epsilon_\\lambda&#94;{i\\alpha}}{ \\sqrt{ \\omega_\\lambda} }\ne&#94;{i\\mathbf{q}\\cdot\\mathbf{r}_i}\n\\left( \\hat{a}&#94;{\\mathstrut}_\\lambda + \\hat{a}&#94;\\dagger_\\lambda \\right) \\\\\n%\n\\hat{p}_{i\\alpha} = & \\sqrt{ \\frac{\\hbar m_\\alpha}{2N} }\n\\sum_\\lambda \\sqrt{ \\omega_\\lambda } \\epsilon_\\lambda&#94;{i\\alpha}\ne&#94;{i\\mathbf{q}\\cdot\\mathbf{r}_i-\\pi/2}\n\\left( \\hat{a}&#94;{\\mathstrut}_\\lambda - \\hat{a}&#94;\\dagger_\\lambda \\right)\n%\n\\end{align}\n and their inverse \n\\begin{align}\n\\hat{a}&#94;{\\mathstrut}_{\\lambda} = & \\frac{1}{\\sqrt{2N\\hbar}}\n\\sum_{i\\alpha} \\epsilon_\\lambda&#94;{i\\alpha}\ne&#94;{-i\\mathbf{q}\\cdot\\mathbf{r}_i} \\left( \\sqrt{m_i \\omega_\\lambda} \\hat{u}_{i\\alpha}-i \\frac{\\hat{p}_{i\\alpha}}{ \\sqrt{ m_i \\omega_\\lambda }} \\right) \\\\\n%\n\\hat{a}&#94;\\dagger_{\\lambda} = & \\frac{1}{\\sqrt{2N\\hbar}}\n\\sum_{i\\alpha} \\epsilon_\\lambda&#94;{i\\alpha}\ne&#94;{i\\mathbf{q}\\cdot\\mathbf{r}_i} \\left( \\sqrt{m_i \\omega_\\lambda} \\hat{u}_{i\\alpha}-i \\frac{\\hat{p}_{i\\alpha}}{ \\sqrt{ m_i \\omega_\\lambda }} \\right)\n\\end{align}\n In terms of these operators, the vibrational Hamiltonian can be written as \n\\begin{equation}\n\\hat{H}=\\sum_{\\lambda}\\hbar\\omega_\\lambda \\left( \\hat{a}&#94;\\dagger_\\lambda \\hat{a}&#94;{\\mathstrut}_\\lambda + \\frac{1}{2}\\right)\\,.\n\\end{equation}\n Since $\\hat{a}&#94;\\dagger_\\lambda \\hat{a}&#94;{\\mathstrut}_\\lambda$ are commutative operators, the Hamiltonian is that of a sum of uncoupled harmonic quantum oscillators, each having the partition function \n\\begin{equation}\nZ_{\\lambda}=\\sum_{n=0}&#94;{\\infty}e&#94;{-\\beta (n +\\frac{1}{2})\\hbar\\omega_{\\lambda} } =\n\\frac{ e&#94;{-\\beta \\hbar\\omega_{\\lambda}/2 } }{1-e&#94;{-\\beta \\hbar\\omega_{\\lambda}}}\n\\end{equation}\n that gives the total \n\\begin{equation}\nZ=\\prod_{\\lambda} \\frac{ e&#94;{-\\beta \\hbar\\omega_{\\lambda}/2 } }{1-e&#94;{-\\beta \\hbar\\omega_{\\lambda}}}.\n\\end{equation}\n From this we can get the Helmholtz (phonon) free energy: \n\\begin{equation}\nF_{\\textrm{ph}}= -k_B T \\ln Z = \\sum_{\\lambda} \\frac{\\hbar \\omega_{\\lambda}}{2}+k_B T%\n\\ln \\left( 1- \\exp \\left( -\\frac{\\hbar \\omega_{\\lambda}}{k_B T} \\right) \\right)\n\\end{equation}\n In the conventional quasiharmonic approximation, the total free energy of the system (not considering any terms pertaining to magnetic or configurational degrees of freedom) can be expressed as \n\\begin{equation}\n    F = F_{\\textrm{el}} + F_{\\textrm{ph}}\\,.\n\\end{equation}\n In the TDEP formalism it is not quite that simple. Determining the free energy with TDEP In the TDEP formalism, 4 , 3 , 2 with effective force constants, the phonon quasiparticles are different at each temperature. At fix temperature, they behave just like normal bosons, obeying Bose-Einstein statistics and so on. But changing the temperature will change both the occupation numbers and the states that are occupied. Moreover, in the harmonic approximation the baseline energy (with all atoms at their equilibrium positions) is that of the static lattice. With an effective Hamiltonian this baseline is a free parameter. The baseline shift is illustrated in the diagram below: The density depicts the phase space samples used to fit the effective Hamiltonian. The reference energy, or baseline, has been shifted with respect to zero temperature. This baseline is determined by matching the potential energies of the samples of the Born-Oppenheimer surface, $U_{BO}$, and the potential energy of the TDEP model Hamiltonian: \n\\begin{equation}\n\\begin{split}\n    \\left\\langle U_{\\textrm{BO}} - U_{\\textrm{TDEP}} \\right\\rangle & =\n    \\left\\langle U_{\\textrm{BO}} - U_0 -\\frac{1}{2} \\sum_{ij} \\sum_{\\alpha\\beta} \\Phi_{ij}&#94;{\\alpha\\beta} u&#94;{\\alpha}_i u&#94;{\\beta}_j  \\right\\rangle = 0 \\\\\n    U_0 & = \\left\\langle U_{\\textrm{BO}} - \\frac{1}{2} \\sum_{ij} \\sum_{\\alpha\\beta} \\Phi_{ij}&#94;{\\alpha\\beta} u&#94;{\\alpha}_i u&#94;{\\beta}_j \\right\\rangle\n\\end{split}\n\\end{equation}\n Intuitively, this can be interpreted as that the TDEP force constants are determined by matching forces between the real and model system, in a similar manner we match the energies as well. The new baseline is conveniently expressed as a shift: \n\\begin{equation}\n    \\Delta U = U_0-U_{\\textrm{stat}}\n\\end{equation}\n Where $U_{\\textrm{stat}}$ is the energy of the perfect lattice at 0K. The free energy is then (excluding configurational entropy, magnetic entropy etc.) \n\\begin{equation}\n    F = F_{\\textrm{el}} + F_{\\textrm{ph}} + \\Delta U_0\\,.\n\\end{equation}\n The entropy and heat capacity is not accessible from a single simulation. Since both the phonon free energy and baseline shift have non-trivial temperature dependencies, a series of calculations for different temperatures are needed, so that the entropy can be calculated via \n\\begin{equation}\n    S = -\\left.\\frac{dF}{dT}\\right|_V\n\\end{equation}\n A series of calculations on a volume-temperature grid is required to calculate Gibbs free energy, with pressure explicitly calculated as \n\\begin{equation}\n    P = -\\left.\\frac{dF}{dV}\\right|_T\n\\end{equation}\n Other dispersive properties We determine group velocities via the Hellman-Feynmann theorem: \n\\begin{equation}\n    \\nabla_{\\mathbf{q}} \\omega&#94;2_s = \\left\\langle \\epsilon_s(\\mathbf{q}) \\right| \\nabla_{\\mathbf{q}} \\Phi(\\mathbf{q})  \\left| \\epsilon_s(\\mathbf{q}) \\right\\rangle\n\\end{equation}\n where the derivatives of the dynamical matrix are defined above, and \n\\begin{equation}\n\\mathbf{v}_{\\mathbf{q}s} = \\nabla_{\\mathbf{q}} \\omega_s(\\mathbf{q})=\n\\frac{1}{2\\omega_s} \\nabla_{\\mathbf{q}} \\omega_s&#94;2(\\mathbf{q})\n\\end{equation}\n The only complications in using this expression is at wave vectors with degenerate frequencies, in those cases one has to average over the small group of the wave vector to obtain consistent group velocities. The mode Grüneisen parameters are a measure of the sensitivity of the vibrational frequencies to volume changes. They are given by \n\\begin{equation}\n\\gamma_{\\mathbf{q}s}=-\\frac{V}{\\omega_{\\mathbf{q}s}}\\frac{\\partial \\omega_{\\mathbf{q}s}}{\\partial V}\n\\end{equation}\n where $V$ is the volume and $\\omega_{\\mathbf{q}s}$ is the frequency of mode $s$ at wave vector $\\mathbf{q}$. $\\gamma_{\\mathbf{q}s}$ can be obtained either by numerical differentiation of the phonon dispersion relations or from the third order force constants based on a perturbation approach: \n\\begin{equation}\n\\gamma_{\\mathbf{q}s}=-\\frac{1}{6\\omega_{\\mathbf{q}s}&#94;2}\\sum_{ijk\\alpha\\beta\\gamma}\n\\frac{\\epsilon&#94;{i\\alpha\\dagger}_{\\mathbf{q}s} \\epsilon&#94;{j\\beta}_{\\mathbf{q}s}}\n{\\sqrt{m_i m_j}}\nr_k&#94;\\gamma \\Phi_{ijk}&#94;{\\alpha\\beta\\gamma}e&#94;{i\\mathbf{q}\\cdot\\ \\mathbf{r}_j}\n\\end{equation}\n Here $\\epsilon_{i\\alpha}&#94;{\\mathbf{q}s}$ is component $\\alpha$ associated eigenvector $\\epsilon$ for atom $i$. $m_i$ is the mass of atom $i$, and $\\mathbf{r}_i$ is the vector locating its position. Density of states Using --dos or --projected_dos_* will calculate the phonon density of states, given by \ng_s(\\omega) = \\frac{(2\\pi)&#94;3}{V} \\int_{\\mathrm{BZ}} \\delta( \\omega - \\omega_{\\mathbf{q}s}) d\\mathbf{q}\n per mode $s$, summing those up yields the total. The site projected density of states for site $i$ is given by \ng_i(\\omega) = \\frac{(2\\pi)&#94;3}{V} \\sum_{s} \\int_{\\mathrm{BZ}} \\left|\\epsilon&#94;i_{\\mathbf{q}s}\\right|&#94;2 \\delta( \\omega -  \\omega_{\\mathbf{q}s}) d\\mathbf{q}\n that, also sums to the total density of states. Input files infile.ucposcar infile.forceconstant Optional files: infile.qpoints_dispersion (to specify a path for the phonon dispersions) infile.lotosplitting (including the electrostatic corrections) infile.forceconstant_thirdorder (for the Grüneisen parameter) Output files Depending on options, the set of output files may differ. We start with the basic files that are written after running this code. outfile.dispersion_relations This file contains a list of $q$ points (in 1/Å) according to the chosen path (default or specified by the user in infile.qpoints_dispersions ) and the frequencies per mode (in the specified units via --unit ) for the corresponding points. Row Description 1  q_1 \\qquad \\omega_1 \\qquad \\omega_2 \\qquad \\ldots \\qquad \\omega_{3N_a}  2  q_2 \\qquad \\omega_1 \\qquad \\omega_2 \\qquad \\ldots \\qquad \\omega_{3N_a}  ... ... Not that the first column is for plotting purposes only. It serves to ensure that each line segment is scaled properly, since each segment contains a fix number of points. outfile.group_velocities This file contains the norm of the group velocities as a function of q. Format is identical to that of the dispersions: Row Description 1  q_1 \\qquad |v_1| \\qquad |v_2| \\qquad \\ldots \\qquad |v_{3N_a}|  2  q_2 \\qquad |v_1| \\qquad |v_2| \\qquad \\ldots \\qquad |v_{3N_a}|  ... ... The units are in km/s. outfile.mode_gruneisen_parameters In case you used --gruneisen , the mode Grüneisen parameters will be written, in a format similar to the dispersions and group velocities: Row Description 1 $ q_1 \\qquad \\gamma_1 \\qquad \\gamma_2 \\qquad \\ldots \\qquad \\gamma_{3N_a} $ 2 $ q_2 \\qquad \\gamma_1 \\qquad \\gamma_2 \\qquad \\ldots \\qquad \\gamma_{3N_a} $ ... ... The units are in km/s. outfile.phonon_dos The first column is the list of frequencies and the second column in the density of states for this frequency, given in arbitrary units. Note that integrated density of states is normalized. One can calculate partial density of states ( --projected_dos_mode ); if the user specifies this option, an extra column will be added into the outfile.phonon_dos file for each type of atom. With --projected_dos_site the same thing happens but with an extra column for each atom in the unit cell. Row Description 1 $ \\omega_1 \\qquad g(\\omega_1) \\qquad g_1(\\omega_1) \\qquad \\ldots \\qquad g_{N}(\\omega_1) $ 2 $ \\omega_2 \\qquad g(\\omega_2) \\qquad g_1(\\omega_2) \\qquad \\ldots \\qquad g_{N}(\\omega_2) $ ... ... The units are in states per energy unit, depending on choice of --unit . The total DOS normalizes to 3N independent of choice of unit. outfile.free_energy If one chooses the option --temperature_range or --temperature then this file will display a list of temperatures with corresponding temperatures, vibrational free energies, vibrational entropies and heat capacities. Row Description 1 $ T_1 \\qquad F_{\\textrm{vib}} \\qquad S_{\\textrm{vib}} \\qquad C_v $ 2 $ T_2 \\qquad F_{\\textrm{vib}} \\qquad S_{\\textrm{vib}} \\qquad C_v $ ... ... Temperature is given in K,  F_{\\textrm{vib}}  in eV/atom,  S_\\textrm{vib}  in eV/K/atom and heat capacity in eV/K/atom. outfile.mode_vibentropies Using --modevib gives the mode-projected vibrational entropies: Row Description 1  T_1 \\qquad S_{1} \\qquad S_{2} \\qquad \\ldots \\qquad S_{3N_a}  2  T_1 \\qquad S_{1} \\qquad S_{2} \\qquad \\ldots \\qquad S_{3N_a}  ... ... Where all entropies are in eV/K/atom. outfile.site_vibentropies Using --sitevib gives the site-projected vibrational entropies: Row Description 1  T_1 \\qquad S_{1} \\qquad S_{2} \\qquad \\ldots \\qquad S_{N_a}  2  T_1 \\qquad S_{1} \\qquad S_{2} \\qquad \\ldots \\qquad S_{N_a}  ... ... The first column is the temperature, followed by one column per atom. All entropies are in eV/K/atom. outfile.grid_dispersions.hdf5 Using option --dumpgrid writes all phonon properties for a grid in the BZ to an hdf5 file, that is self-documented. Born, M., & Huang, K. (1964). Dynamical theory of crystal lattices. Oxford: Oxford University Press. ↩ Hellman, O., Abrikosov, I. A., & Simak, S. I. (2011). Lattice dynamics of anharmonic solids from first principles. Physical Review B, 84(18), 180301. ↩ Hellman, O., & Abrikosov, I. A. (2013). Temperature-dependent effective third-order interatomic force constants from first principles. Physical Review B, 88(14), 144301. ↩ Hellman, O., Steneteg, P., Abrikosov, I. A., & Simak, S. I. (2013). Temperature dependent effective potential method for accurate free energy calculations of solids. Physical Review B, 87(10), 104111. ↩ Gonze, X., Charlier, J.-C., Allan, D. C. & Teter, M. P. Interatomic force constants from first principles: The case of α-quartz. Phys. Rev. B 50, 13035–13038 (1994). ↩ Gonze, X. & Lee, C. Dynamical matrices, Born effective charges, dielectric permittivity tensors, and interatomic force constants from density-functional perturbation theory. Phys. Rev. B 55, 10355–10368 (1997). ↩ ↩","tags":"","loc":"program/phonon_dispersion_relations.html","title":"\n    \n        phonon dispersion relations – TDEP\n    \n"},{"text":"Short description Calculates properties of the atomic distribution from molecular dynamics, such as mean square displacement, pair distribution function, vector distribution functions and probability densities. Useful for analysing simulations close to instabilities/phase transitions to have some idea where the atoms are. Command line options: Optional switches: --cutoff value , -r value default value 5.0 Consider pairs up to this distance, in A. --nbins value , -n value default value 200 Number of bins in each dimension. --notransform default value .false. Do no rotate the coordinate systems of the vector distribution. By default, the coordinate system is aligned with the positive x-direction in the direction of the bond. --bintype value , value in: 1,2,3 default value 1 Select the binning type for the vector distribution. 1 is straight binning (fastest), 2 is binning with a Gaussian, 3 is binning with a gaussian, but without the subpixel resolution. --stride value , -s value default value 1 Use every N configuration instead of all. --help , -h Print this help message --version , -v Print version Examples atomic_distribution --cutoff 4.3 atomic_distribution --cutoff 4.3 --notransform Long description When using molecular dynamics, there are several ways to analyse the trajectories. This code implements a few of them. The TDEP method was originally meant to deal with dynamically unstable systems. It turns out the the most common problem for users was that the atoms did something during the simulation: what they thought was bcc Ti was no longer bcc Ti, but some halfway phase on it's way to transition to something. So, before trying to get phonons and free energies and other things, it it useful to make sure that what is in your simulation box actually is what you think it is. A number of diagnostics is provided here. Some background The easiest measure is the mean square displacement: \n\\textrm{msd}(t) = \\frac{1}{N} \\sum_i \\left| \\mathbf{r}_i(t)-\\mathbf{r}_i(0) \\right|&#94;2\n where $\\mathbf{r}_i(t)$ is the position of atom $i$ at time $t$. \nHaving established that the system is at least still a solid we can look at the radial distribution function (or pair correlation function), defined as \ng(r) = \\frac{ n(r) }{\\rho 4 \\pi r&#94;2 dr}\n where $\\rho$ is the mean particle density, and $n(r)$ the number of particles in an infinitesimal shell of width $dr$. Usually, this is averaged over all atoms in the system. In this code, I project it onto symmetrically equivalent pairs, yielding a projected pair distribution: \ng_i(r) = {\\rho 4 \\pi r&#94;2 dr} \\sum_i \\delta\\left( \\left|r_i\\right|-r \\right)\n where the index $i$ corresponds to a coordination shell. The coordination shell is defined from the ideal lattice as set of pairs that can transform to each other via a spacegroup operation. Naturally, the sum over all projected PDFs yield the total. Above is an example for ScF 3 . The peaks are well defined per pair, indicating that the system is still crystalline. In the projected picture, each coordination shell contributes one peak. Should on peak deviate strongly from a gaussian, it probably means that the system has undergone some internal shifts of the coordinates, altering the symmetry. This code also calculates the vector distribution function, essentially three-dimensionsonal histograms of pair vectors. Schematically, it works like this: first I identify the symmetry inequivalent pair coordination shells (turqoise and blue arrows below). Each pair in the simulation cell gets a transformation associated with it (dashed lines) that takes them to the prototype vectors (connecting the dark blue atoms) With these transformation rules, every pair from every timestep gets transformed, and binned in a histogram. The histogram is attached to the ideal bond, so that the origin coincides with the equilibrium pair vector. The coordinate system is also rotated such that the positive $z$-direction coincides with the pair vector, see the sketch below. The blue dots represent samples from pairs associated with blue vectors above, same for the green dots. This results in three-dimensional distributions of pair vectors, one for each symmetry-distinct pair. This is a measure related to the pair correlation functions, but spatially resolved. If the distribution is given by $n(\\mathbf{r})$, integrating this over spherical shells gives the pair correlation function described above. Using the same example as above, ScF 3 , isosurfaces of the distribution look like this for the nearest neighbour Sc-F pair: Input files infile.ucposcar infile.ssposcar infile.meta infile.stat infile.positions infile.forces Output files outfile.mean_square_displacement.hdf5 The hdf file is self-explainatory. In addition, a plain-text outfile.mean_square_displacement is written with Row Description 1  t_1 \\qquad \\textrm{msd}(t_1) \\qquad \\textrm{msd}_1(t_1) \\qquad \\ldots \\qquad \\textrm{msd}_{N_a}(t_1)  2  t_2 \\qquad \\textrm{msd}(t_2) \\qquad \\textrm{msd}_1(t_2) \\qquad \\ldots \\qquad \\textrm{msd}_{N_a}(t_2)  ... ... Where the columns are time (in fs), mean square displacement (in Å 2 ), followed by the partial mean square displacement per unique atom. outfile.pair_distribution_function.hdf5 The hdf file is self-explainatory. Below is a matlab snippet that produces the plot above clear all ; % filename fn = 'outfile.pair_distribution_function.hdf5' ; % number of unique atoms na = h5readatt ( fn , '/' , 'number_unique_atoms' ); % the total x = h5read ( fn , '/r_axis' ); y = h5read ( fn , '/radial_pair_distribution_function' ); % the projected for i = 1 : na xx { i }= h5read ( fn ,[ '/projected_r_axis_' num2str ( i )]); yy { i }= h5read ( fn ,[ '/projected_pair_distribution_function_atom_' num2str ( i )]); end figure ( 1 ); clf ; hold on ; box on ; % plot the total plot ( x , y ) % plot the projected for i = 1 : na for j = 1 : size ( xx { i }, 1 ) plot ( xx { i }( j ,:), yy { i }( j ,:)) end end set ( gca , 'xminortick' , 'on' , 'yminortick' , 'on' ) xlabel ( 'Distance (A)' ) ylabel ( 'g(r)' ) and an equivalent snippet using matplotlib: import matplotlib.pyplot as plt import numpy as np import h5py as h5 # open the sqe file f = h5 . File ( 'outfile.pair_distribution_function.hdf5' , 'r' ) # the total x = np . array ( f . get ( 'r_axis' )) y = np . array ( f . get ( 'radial_pair_distribution_function' )) plt . plot ( x , y ) # the projected na = f . attrs . get ( 'number_unique_atoms' ) for i in range ( na ): x = np . array ( f . get ( 'projected_r_axis_' + str ( i + 1 ))) y = np . array ( f . get ( 'projected_pair_distribution_function_atom_' + str ( i + 1 ))) for j in range ( x . shape [ 1 ]): plt . plot ( x [:, j ], y [:, j ]) plt . xlabel ( \"Distance (A)\" ) plt . ylabel ( \"g(r)\" ) plt . show () outfile.vector_distribution.hdf5 This file contains all the vector distribution histograms, the prototype vectors, the transformations to the correct coordinate systems and so on. The file is self-documented. The following is the matlab snippet used to create the plot above: % file fn = 'outfile.vector_distribution.hdf5' ; % focus on one distribution, get the histogram gv = h5read ( fn , '/distribution_atom_1_shell_2' ); % and the coordinates for the bin-centers x = h5readatt ( fn , '/distribution_atom_1_shell_2' , 'bincenters' ); % grids for plotting (always uniform) [ gx , gy , gz ]= meshgrid ( x , x , x ); figure ( 1 ); clf ; hold on ; % number of isosurfaces niv = 6 ; % values for the isosurfaces iv = exp ( linspace ( log ( 0.01 ), log ( 1.5 ), niv ) ); subplot ( 1 , 2 , 1 ); hold on ; for i = 1 : niv p = patch ( isosurface ( gx , gy , gz , gv , iv ( i ))); isonormals ( gx , gy , gz , gv , p ) p . FaceColor = [ 0.7 0.1 0.1 ]; p . EdgeColor = 'none' ; alpha ( p , 0.25 ); end daspect ([ 1 1 1 ]) view ([ 0 1 ]) camlight ; lighting phong xlabel ( 'x' ) ylabel ( 'y' ) zlabel ( 'z' ) subplot ( 1 , 2 , 2 ); hold on ; for i = 1 : length ( iv ) p = patch ( isosurface ( gx , gy , gz , gv , iv ( i ))); isonormals ( gx , gy , gz , gv , p ) p . FaceColor = [ 0.7 0.1 0.1 ]; p . EdgeColor = 'none' ; alpha ( p , 0.25 ); end daspect ([ 1 1 1 ]) view ([ 0 0 1 ]) camlight ; lighting phong xlabel ( 'x' ) ylabel ( 'y' ) zlabel ( 'z' ) Note I could not figure out an easy way to get decent-looking isosurfaces in matplotlib. Please tell me if you manage.","tags":"","loc":"program/atomic_distribution.html","title":"\n    \n        atomic distribution – TDEP\n    \n"},{"text":"Short description Calculates the lattice thermal conductivity from the iterative solution of the phonon Boltzmann equation. In addition, cumulative plots and raw data dumps of intermediate values are available. Command line options: Optional switches: --readiso default value .false. Read the isotope distribution from infile.isotopes . The format is specified here . --qpoint_grid value#1 value#2 value#3 , -qg value#1 value#2 value#3 default value 26 26 26 Density of q-point mesh for Brillouin zone integrations. --integrationtype value , -it value , value in: 1,2,3,4 default value 2 Type of integration for the phonon DOS. 1 is Gaussian, 2 adaptive Gaussian and 3 Tetrahedron. --sigma value default value 1.0 Global scaling factor for adaptive Gaussian smearing. --threshold value default value 4.0 Consider a Gaussian distribution to be 0 after this many standard deviations. --readqmesh default value .false. Read the q-point mesh from file. To generate a q-mesh file, see the genkpoints utility. --temperature value default value -1 Evaluate thermal conductivity at a single temperature. --temperature_range value#1 value#2 value#3 default value 100 300 5 Series of temperatures for thermal conductivity. Specify min, max and the number of points. --logtempaxis default value .false. Space the temperature points logarithmically instead of linearly. --tau_boundary value default value -1 Add a constant boundary scattering term to the lifetimes. --max_mfp value default value -1 Add a limit on the mean free path as an approximation of domain size. --dumpgrid default value .false. Write files with q-vectors, frequencies, eigenvectors and group velocities for a grid. --thinfilm default value .false. Calculate the suppression of kappa from in a thin film. --noisotope default value .false. Do not consider isotope scattering. --correctionlevel value default value 6 How agressively things are corrected due to broken symmetries. --scftol value default value 1E-5 What tolerance to converge the self-consistent cycle to. --help , -h Print this help message --version , -v Print version Examples mpirun thermal_conductivity --temperature 300 mpirun thermal_conductivity -qg 15 15 15 --temperature_range 200 600 50 mpirun thermal_conductivity --integrationtype 2 -qg 30 30 30 --max_mfp 1E-6 Longer summary Heat transport can be determined by solving the inelastic phonon Boltzmann equation. By applying a temperature gradient $\\nabla T_\\alpha$ in direction $\\alpha$, the heat current is given by the group velocities of phonon mode $\\lambda$ and non-equilibrium phonon distribution function $\\tilde{n}_\\lambda$: 2 \n\\begin{equation}\nJ_{\\alpha}=\\frac{1}{V}\\sum_\\lambda\n\\hbar \\omega_\\lambda v_{\\lambda\\alpha} \\tilde{n}_{\\lambda\\alpha}.\n\\end{equation}\n Assuming the thermal gradient is small, the non-equilibrium distribution function can be linearised as, \n\\tilde{n}_{\\lambda\\alpha} \\approx n_{\\lambda}-\nv_{\\lambda\\alpha}\n\\tau_{\\lambda\\alpha}\n\\frac{d n_{\\lambda}}{d T}\n\\frac{d T}{d \\alpha} \\, ,\n That is a linear deviation from the equilibrium distribution function $n_{\\lambda}$. Inserting this into the equation 1, and exploiting the fact that the equilibrium occupation carries no heat, we arrive at, \nJ_{\\alpha}=\\frac{1}{V}\\sum_{\\lambda}\n\\hbar \\omega_{\\lambda}\n\\frac{d n_{\\lambda}}{d T}\nv_{\\lambda\\alpha}\nv_{\\lambda\\alpha}\n\\tau_{\\lambda\\alpha}\n\\frac{d T}{d \\alpha}.\n Utilizing Fourier's law, $J=\\kappa \\nabla T$, and identifying the phonon heat capacity, \nc_{\\lambda}=\n\\hbar \\omega_\\lambda\n\\frac{d n_{\\lambda}}{d T},\n we arrive at, \n\\kappa_{\\alpha\\beta}=\\frac{1}{V} \\sum_{\\lambda}\nc_{\\lambda}\nv_{\\alpha \\lambda}v_{\\beta \\lambda} \\tau_{\\beta \\lambda},\n which can be interpreted as follows: the heat transported by each phonon will depend on how much heat it carries, how fast it travels, and how long it lives. The phonon-phonon induced lifetime can be determined from the self-energy $\\Gamma_{\\lambda}$. In addition, one must consider the scattering with mass impurities (isotopes), and the boundaries of the sample. Lifetimes With the third order force constants we can calculate the phonon lifetimes needed as input to the thermal conductivity calculations. The lifetime due to phonon-phonon scattering is related to the imaginary part of the phonon self energy ( $\\Sigma=\\Delta+i\\Gamma$ ). \n\\frac{1}{\\tau_{\\lambda}}=2 \\Gamma_{\\lambda},\n where $\\tau_{\\lambda}$ is the lifetime phonon mode $\\lambda$, and \n\\begin{split}\n\\Gamma_{\\lambda}=& \\frac{\\hbar \\pi}{16} % _{\\lambda'}\n\\sum_{\\lambda'\\lambda''}\n\\left|\\Phi_{\\lambda\\lambda'\\lambda''}\\right|&#94;2\n\\bigl[(n_{\\lambda'}+n_{\\lambda''}+1)\n\\delta(\\omega_{\\lambda}-\\omega_{\\lambda'}-\\omega_{\\lambda''}) \\\\\n+ & 2(n_{\\lambda'}-n_{\\lambda''})\n\\delta(\\omega_{\\lambda}-\\omega_{\\lambda'}+\\omega_{\\lambda''}) \\bigr]\n\\end{split}\n $n_{\\lambda}$ is the equilibrium occupation number. The sum is over momentum conserving three-phonon processes, $\\textbf{q}+\\textbf{q}'+\\textbf{q}''=\\textbf{G}$, and the deltafunctions in frequency ensure energy conservation. The three-phonon matrix elements are given by \n\\Phi_{\\lambda\\lambda'\\lambda''} =\n\\sum_{ijk}\n\\sum_{\\alpha\\beta\\gamma}\n\\frac{\n\\epsilon_{\\lambda}&#94;{i \\alpha}\n\\epsilon_{\\lambda'}&#94;{j \\beta}\n\\epsilon_{\\lambda''}&#94;{k \\gamma}\n}{\n\\sqrt{m_{i}m_{j}m_{j}}\n\\sqrt{\n    \\omega_{\\lambda}\n    \\omega_{\\lambda'}\n    \\omega_{\\lambda''}}\n}\n\\Phi&#94;{\\alpha\\beta\\gamma}_{ijk}\ne&#94;{i \\mathbf{q}\\cdot\\mathbf{r}_i + i \\mathbf{q}'\\cdot\\mathbf{r}_j+i \\mathbf{q}''\\cdot\\mathbf{r}_k}\n where $m_i$ is the mass of atom $i$, $\\epsilon_{\\lambda}&#94;{\\alpha i}$ is component $\\alpha$ of the eigenvector for mode $\\lambda$ and atom $i$ and $\\textbf{r}_i$ is the lattice vector associated with atom $i$. Mass disorder, in the form of natural isotope distributions also cause thermal resistance. According to Tamura 5 , if the isotopes are randomly distributed on the lattice sites then the strength of the isotope scattering can be given by a mass variance parameter $g$: \ng_i=\\sum_j c_{i}&#94;j \\left(\\frac{m_i&#94;j-\\bar{m_i}}{\\bar{m_i}}\\right)&#94;2\n where $\\bar{m_i}$ is the average isotopic mass( $\\bar{m_i}=\\sum_j c_i&#94;j m_i&#94;j$ ), $m&#94;j_i$ is the mass of isotope $j$ of atom $i$ and $c&#94;j_i$ is its concentration. The contribution to the imaginary part of the self-energy is \n\\Gamma&#94;{\\textrm{iso}}_{\\lambda}=\n\\frac{\\pi}{4} \\sum_{\\lambda'}\n\\underbrace{\\omega_{\\lambda}\\omega_{\\lambda'} \\sum_i g_i \\left| \\epsilon_{\\lambda}&#94;{i \\dagger} \\epsilon_{\\lambda'}&#94;{i} \\right|&#94;2}_{\\Lambda_{\\lambda\\lambda'}}\n\\delta(\\omega_{\\lambda}-\\omega_{\\lambda'})\n Per default, the isotope distribution will be the natural distribution. In case some other distribution is desired, this can be specified. Scattering by domain boundaries is implemented as \n\\Gamma&#94;{\\textrm{boundary}}_{\\lambda} = \\frac{ v_{\\lambda} }{2d}\n Where $d$ is a characteristic domain size. Beyond the relaxation time approximation So far we have have considered the phonon heat conduction as an elastic process, whereas it is inelastic. This can be treated by iteratively solving the phonon boltzmann equation, formulated in terms of the (linear) deviations from equilibrium occupation numbers. 1 , 6 , 7 , 8 , 9","tags":"","loc":"program/thermal_conductivity.html","title":"\n    \n        thermal conductivity – TDEP\n    \n"},{"text":"Short description Choose representative uncorrelated samples from an MD simulation. The samples are chosen to be approximately evenly spaced, and reproduce the average potential energy, average kinetic energy have the same standard deviation of potential and kinetic energy. Command line options: Optional switches: --nsamples value , -n value default value 50 Number of samples --output_format value , -of value , value in: 1,2,3 default value 1 Output format. 1 is VASP, 2 Abinit, 3 LAMMPS. --help , -h Print this help message --version , -v Print version Examples samples_from_md -n 100 Longer summary Ab initio molecular dynamics are expensive calculations. There will be a tradeoff between numerical precision and the number of timesteps. To work around this, you can run the MD with rather low precision and gather statistics. Then, from the long simulation, choose a set of uncorrelated configurations and recalculate these with high precision. From these low accuracy calculations we choose a set of $n$ uncorrelated samples and correct scalar parameter $a$ as \n\\begin{equation}\na = <a&#94;l> + \\frac{1}{n}\\sum_{i=1}&#94;n a&#94;h_i-a_i&#94;l,\n\\end{equation}\n where $a&#94;l$ are the low accuracy calculations and $a&#94;h$ are calculations done with high accuracy. This exploits the fact that most omissions of numerical accuracy, such as basis set and k-point selection, lead to additive errors. This technique is well suited to determine the interatomic force constants and resulting thermodynamic/transport properties with high accuracy. This code selects a choice of uncorrelated samples from BOMD via a Monte-Carlo algorithm, assuring the selection is not biased. We start with a calculation of average potential $E_p$, kinetic energies $E_k$, and their standard deviation. We check the distance between samples assuring that chosen samples are not temporally adjacent. The results of this procedure is written in output files ( outfile.stat_sample ). The average values and distance between selected points depend on the number of desired samples. Input files infile.ucposcar infile.ssposcar infile.meta infile.stat infile.positions infile.forces Output files This code will generate a series of structures given in VASP POSCAR format with positions in fractional coordinates and velocities in Å/fs.","tags":"","loc":"program/samples_from_md.html","title":"\n    \n        samples from md – TDEP\n    \n"},{"text":"Short description Calculate the frequency-dependent self-energy and phonon spectral function from many-body perturbation theory. Command line options: Optional switches: --unit value , value in: thz,mev,icm default value thz Choose the output unit. The options are terahertz (in frequency, not angular frequency), inverse cm or meV. --temperature value default value 300 Temperature used in the occupation numbers. Should be the same as the temperature the force constants where determined at. --n_energies value , -ne value default value 1200 Number of energies for the energy-dependent self-energy. --qpoint_grid value#1 value#2 value#3 , -qg value#1 value#2 value#3 default value 26 26 26 Density of q-point mesh for Brillouin zone integrations. --integrationtype value , -it value , value in: 1,2,3 default value 2 Type of integration for the phonon DOS. 1 is Gaussian, 2 adaptive Gaussian and 3 Tetrahedron. --sigma value default value 1.0 Global scaling factor for the Gaussian/adaptive Gaussian smearing. The default is determined procedurally, and scaled by this number. --path default value .false. Calculate the self-energy and spectral function on a path through the BZ. --readpath , -rp default value .false. Read the q-point path from infile.qpoints_dispersion . Use crystal structure into to generate an example. --nq_on_path value , -nq value default value 100 Number of q-points between each high symmetry point --dos default value .false. Calculate the broadened and shifted phonon DOS. --dos_qpoint_grid value#1 value#2 value#3 default value -1 -1 -1 Interpolate to a (preferrably) denser q-mesh when calculating the DOS. --qpoint value#1 value#2 value#3 default value 0 0 0 Calculate the self-energy at a single q-point, input in fractional coordinates. --highsymmetrypoint value default value none Samy as above, but you can specify the label of a high-symmetry point instead, e.g. \"X\" or \"L\". --max_energy value default value 1.4 Maximum energy where the output is cut off, in multiples of the maximum harmonic frequency. --no_isotope_scattering default value .false. Switch off isotope (mass disorder) scattering --no_thirdorder_scattering default value .false. Switch of three-phonon scattering --readiso default value .false. Read the isotope distribution from file --meshtype value , value in: 1,2,3 default value 1 Type of q-point mesh. 1 Is a Monkhorst-Pack mesh, 2 an FFT mesh and 3 my fancy wedge-based mesh with approximately the same density the grid-based meshes. --readqmesh default value .false. Read the q-point mesh from file. To generate a q-mesh file, see the genkpoints utility. --help , -h Print this help message --version , -v Print version Examples mpirun lineshape --highsymmetrypoint X --temperature 500 mpirun lineshape --path -qg 10 10 10 --noisotope mpirun lineshape --dos -qg 10 10 10 --dos_qpoint_grid 24 24 24 Long summary This code calculates the energy-dependent self energy from three-phonon scattering, as well as the contributions from mass imperfections and four-phonon scattering. It can produce nice figures like this: Background It is nowadays routine to calculate e.g. lattice thermal conductivity using perturbation theory. At that level of approximation, you calculate the phonon lifetime via the imaginary part of the phonon self-energy at the harmonic frequencies. In general, however, the picture with a well defined phonon, shifted by a small energy $ \\Delta $ and broadened by $ \\Gamma $ is not enough. In general, the phonon self-energy is energy-dependent, 1 , 2 \n\\begin{equation}\n\\Sigma(\\Omega) = \\Delta(\\Omega) + i\\Gamma(\\Omega) \\,,\n\\end{equation}\n where we use $ \\Omega $ to distinguish this energy from the eigenvalues of the dynamical matrix, $ \\omega&#94;2 $. Inelastic neutron measurements sometimes show scattering cross sections that deviate strongly from a Lorentzian. To reproduce this computationally, start by noting that in an idealised experiment the one-phonon neutron cross section would be measured as 1 , 2 \n\\begin{equation}\n\\sigma_{\\lambda}(\\Omega) \\propto\n\\frac{\n  2 \\omega_{\\lambda}\\Gamma_{\\lambda}(\\Omega)\n}{\n  \\left[\\Omega&#94;2-\\omega&#94;2_{\\lambda}-2\\omega_{\\lambda}\n  \\Delta_{\\lambda}(\\Omega)\\right]&#94;2+4\\omega&#94;2_{\\lambda}\\Gamma_{\\lambda}&#94;2(\\Omega)}\\,.\n\\end{equation}\n Here $\\omega&#94;2_{\\lambda}$ are the eigenvalues of the dynamical matrix, $\\Delta_{\\lambda}(\\Omega)$ and $\\Gamma_{\\lambda}(\\Omega)$ are the real and imaginary parts of the frequency dependent self-energy, and $\\hbar\\Omega$ is a probing energy. This is the quantity referred to as the lineshape. If you let $\\Delta$ and $\\Gamma$ go to a small constant, this reduces to a Lorentzian as expected. The energy axis is the probing energy, and the intensity represents the likelihood of exciting a phonon with energy $\\hbar\\Omega$ and momentum $\\textbf{q}$. We can interpret the cross section, or phonon lineshape, as the broadened and shifted phonon frequencies. The term \"broadening\" is used in the sense of a spectral representation: non-interaction quasiparticles are represented as Dirac $\\delta$-functions, but in the interacting case these are replaced by distributions with finite widths. Given the third order force constants, the imaginary part of the phonon self-energy can be calculated: 1 , 2 , 4 \n\\begin{equation}\n\\begin{split}\n\\Gamma_{\\lambda}(\\Omega) & =  \\frac{\\hbar\\pi}{16}\n%\\frac{V}{(2\\pi)&#94;3}\n\\sum_{\\lambda'\\lambda''}\n\\left|\n\\Phi_{\\lambda\\lambda'\\lambda''}\n\\right|&#94;2\n\\big{\\{}(n_{\\lambda'}+n_{\\lambda''}+1)\n\\delta(\\Omega-\\omega_{\\lambda'}-\\omega_{\\lambda''})+\n\\\\& +(n_{\\lambda'}-n_{\\lambda''})\n\\left[\n\\delta(\\Omega-\\omega_{\\lambda'}+\\omega_{\\lambda''}) -\n\\delta(\\Omega+\\omega_{\\lambda'}-\\omega_{\\lambda''})\n\\right]\n\\big{\\}}\n\\end{split}\n\\end{equation}\n The imaginary part of the self energy is a sum over all possible three-phonon interactions $ \\lambda \\lambda' \\lambda''$, $n_{\\lambda}$ are the Bose-Einstein thermal occupation factors counting the number of phonons in each mode. The expression for the self-energy is then an integral over the allowed processes (conserving energy and momentum), weighted by how many phonons are in each of the different modes, with the scattering strength determined by the three-phonon matrix element: \n\\begin{equation}\n\\Phi_{\\lambda\\lambda'\\lambda''} =\n\\sum_{ijk}\n\\sum_{\\alpha\\beta\\gamma}\n\\frac{\n\\epsilon_{\\lambda}&#94;{i \\alpha}\n\\epsilon_{\\lambda'}&#94;{j \\beta}\n\\epsilon_{\\lambda''}&#94;{k \\gamma}\n}{\n\\sqrt{m_{i}m_{j}m_{j}}\n\\sqrt{\n    \\omega_{\\lambda}\n    \\omega_{\\lambda'}\n    \\omega_{\\lambda''}}\n}\n\\Phi&#94;{\\alpha\\beta\\gamma}_{ijk}\ne&#94;{i \\mathbf{q}\\cdot\\mathbf{r}_i + i \\mathbf{q}'\\cdot\\mathbf{r}_j+i \\mathbf{q}''\\cdot\\mathbf{r}_k}\n\\end{equation}\n The real part is conveniently calculated via a Kramers-Kronig transform (it can of course be expressed in a similar way as the imaginary part: 1 , 2 , 4 \n\\begin{equation}\n\\Delta(\\Omega)=\\frac{1}{\\pi}\\int\\frac{\\Gamma(\\omega)}{\\omega-\\Omega}\\mathrm{d}\\omega\\,.\n\\end{equation}\n A significant deviation from Lorentzian lineshapes indicates anharmonic effects and can be checked by considering phonon spectral representation $\\sigma_{\\lambda}$. Mass disorder The mass disorder term is also included, stemming from the natural distribution of isotopes. According to Tamura 5 , if the isotopes are randomly distributed on the lattice sites then the strength of the isotope effects can be given by a mass variance parameter $g$: \n\\begin{equation}\ng_i=\\sum_j c_{i}&#94;j \\left(\\frac{m_i&#94;j-\\bar{m_i}}{\\bar{m_i}}\\right)&#94;2\n\\end{equation}\n where $\\bar{m_i}$ is the average isotopic mass( $\\bar{m_i}=\\sum_j c_i&#94;j m_i&#94;j$ ), $m&#94;j_i$ is the mass of isotope $j$ of atom $i$ and $c&#94;j_i$ is its concentration. We can write an expression for the imaginary part of the isotope self-energy: \n\\begin{equation}\n\\Gamma_{\\lambda}(\\Omega)=\n\\frac{\\pi}{4} \\sum_{\\lambda'}\n\\Lambda_{\\lambda\\lambda'} \\delta(\\Omega-\\omega_{\\lambda}')\n\\end{equation}\n where \n\\begin{equation}\n\\Lambda_{\\lambda\\lambda'}=\n\\omega_{\\lambda}\\omega_{\\lambda'} \\sum_i g_i \\left| \\epsilon_{\\lambda}&#94;{i \\dagger} \\epsilon_{\\lambda'}&#94;{i} \\right|&#94;2\n\\end{equation}\n Per default, the isotope distribution will be the natural distribution. In case some other distribution is desired, this can be specified. Input files Required files: infile.ucposcar infile.forceconstant infile.forceconstant_thirdorder Optional files: infile.lotosplitting (for long-range corrections) infile.qpoints_dispersion (to specify the q-point path) infile.isotopes (for non-natural isotope distribution) Output files There are three possible modes for this code: the lineshape at a single q-point (default), along a path in the BZ ( --path ) or over the full BZ as a phonon DOS ( --dos ). The output files will differ. For lineshape at a single q, you get outfile.lineshape.hdf5 This file is self-documented. You can produce plots like this: For this plot, I used the following matlab snippet: % read everything from file fn =( 'outfile.lineshape.hdf5' ); % lineshape things x1 = h5read ( fn , '/intensity_axis' ); y1 = h5read ( fn , '/intensity' ); % self-energies x2 = h5read ( fn , '/selfenergy_axis' ); z1 = h5read ( fn , '/imaginary_threephonon_selfenergy' ); z2 = h5read ( fn , '/imaginary_isotope_selfenergy' ); z3 = h5read ( fn , '/real_threephonon_selfenergy' ); % and the unit and bare harmonic frequencies energyunit = h5readatt ( fn , '/selfenergy_axis' , 'unit' ); omega = h5read ( fn , '/harmonic_frequencies' ); % create a legend for i = 1 : length ( omega ) lgd { i }=[ 'band ' num2str ( i ) ', \\omega = ' num2str ( omega ( i ), '%10.5f' ) energyunit ]; end figure ( 1 ); clf ; hold on ; subplot ( 2 , 1 , 1 ); hold on ; box on ; plot ( x1 , y1 ) title ( 'Lineshape' ) xlabel ([ '\\omega (' energyunit ')' ]) ylabel ([ 'states/' energyunit ]) set ( gca , 'xminortick' , 'on' , 'yminortick' , 'on' , 'xlim' ,[ 0 max ( omega ) * 1.4 ]) legend ( lgd , 'edgecolor' , 'none' ) subplot ( 2 , 2 , 3 ); hold on ; box on ; plot ( x2 , z1 + z2 ) title ( 'Imaginary self-energy' ) xlabel ([ '\\omega (' energyunit ')' ]) ylabel ([ '\\Gamma (' energyunit ')' ]) set ( gca , 'xminortick' , 'on' , 'yminortick' , 'on' , 'xlim' ,[ 0 max ( omega ) * 1.4 ]) subplot ( 2 , 2 , 4 ); hold on ; box on ; plot ( x2 , z3 ) title ( 'Real self-energy' ) xlabel ([ '\\omega (' energyunit ')' ]) ylabel ([ '\\Delta (' energyunit ')' ]) set ( gca , 'xminortick' , 'on' , 'yminortick' , 'on' , 'xlim' ,[ 0 max ( omega ) * 1.4 ]) outfile.sqe.hdf5 These files represent the properties calculated as a function of \\textbf{q} along high symmetry directions in the Brillouin zone, such as the plot at the top of this page. The file is self-documented. An example how to produce decent-looking plots can be found here . outfile.dos_lineshape Is identical to this . Maradudin, A. A., & Fein, A. (1962). Scattering of Neutrons by an Anharmonic Crystal. Physical Review, 128(6), 2589–2608. ↩ ↩ ↩ ↩ Cowley, R. A. (1968). Anharmonic crystals. Reports on Progress in Physics, 31(1), 123–166. ↩ ↩ ↩ ↩ Leibfried, G., & Ludwig, W. (1961). Theory of Anharmonic Effects in Crystals. Solid State Physics - Advances in Research and Applications, 12(C), 275–444. ↩ Wallace, D. C. (1998). Thermodynamics of crystals. Dover Publications, Incorporated. ↩ ↩ Tamura, S. (1983). Isotope scattering of dispersive phonons in Ge. Physical Review B, 27(2), 858–866. ↩","tags":"","loc":"program/lineshape.html","title":"\n    \n        lineshape – TDEP\n    \n"},{"text":"Short description Builds supercells, diagonal and non-diagonal. Also has the capability to find the optimal supercells for a given lattice, very handy when you have complicated structures. Command line options: Optional switches: --dimensions value#1 value#2 value#3 , -d value#1 value#2 value#3 default value 5 5 5 Dimensions of supercell. --nondiagonal_dimensions value#1 value#2 value#3 value#4 value#5 value#6 value#7 value#8 value#9 , -nd value#1 value#2 value#3 value#4 value#5 value#6 value#7 value#8 value#9 default value 0 0 0 0 0 0 0 0 0 Non-diagonal dimensions of supercell. --output_format value , -of value , value in: 1,2,3,4,5 default value 1 Output format. 1 is VASP, 2 Abinit, 3 LAMMPS, 4 xyz-files for i-pi, 5 FHI-Aims --magnetic_bins value , -mb value default value 5 Number of bins in correlation functions, from order to disorder. --magnetic_configurations value , -mc value default value 10 Number of magnetic configurations per bin --desired_na value , -na value default value -1 Desired number of atoms in supercell. Will try to choose a cell as cubic as possible. --help , -h Print this help message --version , -v Print version Examples generate_structure -dim 4 3 5 Longer summary This code builds a supercell with user-specified dimensions from the unit cell given in infile.ucposcar . All positions are in fractional coordinates. The code handles diagonal and non-diagonal cells. The diagonal cells are simple repetitions of the unit cell, making it $N_1 \\times N_2 \\times N_3$ larger. The non-diagonal cells can be useful when the unit cell has an awkward shape. The supercell will have the lattice vectors \n\\begin{pmatrix}\n\\mathbf{A}_1 \\\\\n\\mathbf{A}_2 \\\\\n\\mathbf{A}_3 \\\\\n\\end{pmatrix}\n= \\mathbf{M}\n\\begin{pmatrix}\n\\mathbf{a}_1 \\\\\n\\mathbf{a}_2 \\\\\n\\mathbf{a}_3\n\\end{pmatrix}\n where $\\det( \\mathbf{M} )$ is a positive integer. Some useful transformations are, for example, with -nd -n1 n1 n1 n2 -n2 n2 n3 n3 -n3 , from a primitive fcc lattice to the conventional cubic \n\\begin{pmatrix}\nn_1 a & 0 & 0 \\\\\n0 & n_2 a & 0 \\\\\n0 & 0 & n_3 a\n\\end{pmatrix}\n=\\begin{pmatrix}\n-n_1 & n_1 & n_1 \\\\\nn_2 & -n_2 & n_2 \\\\\nn_3 & n_3 & -n_3\n\\end{pmatrix}\n\\begin{pmatrix}\n0 & a/2 & a/2 \\\\\na/2 & 0 & a/2 \\\\\na/2 & a/2 & 0\n\\end{pmatrix}\n Similarly, from a primitive bcc to conventional cubic: \n\\begin{pmatrix}\nn_1 a & 0 & 0 \\\\\n0 & n_2 a & 0 \\\\\n0 & 0 & n_3 a\n\\end{pmatrix}\n=\\begin{pmatrix}\n0 & n_1 & n_1 \\\\\nn_2 & 0 & n_2 \\\\\nn_3 & n_3 & 0\n\\end{pmatrix}\n\\begin{pmatrix}\n-a/2 & a/2 & a/2 \\\\\na/2 & -a/2 & a/2 \\\\\na/2 & a/2 & -a/2\n\\end{pmatrix}\n There are some non-obvious ones as well, such as converting a hexagonal lattice to an orthorhombic: \n\\begin{pmatrix}\nn_1 a & 0 & 0 \\\\\n0 & \\sqrt{3} n_2 a  & 0 \\\\\n0 & 0 & n_3 c\n\\end{pmatrix}\n=\\begin{pmatrix}\nn_1 & n_1 & 0 \\\\\n-n_2 & n_2 & 0 \\\\\n0 & 0 & n_3\n\\end{pmatrix}\n\\begin{pmatrix}\na/2 & -a\\sqrt{3}/2 & 0 \\\\\na/2 & a \\sqrt{3}/2 & 0 \\\\\n0 & 0 & c\n\\end{pmatrix}\n or rhombohedral (lattice parameter $a$, angle $\\alpha$) to hexagonal: \n\\begin{equation*}\n\\begin{split}\n\\begin{pmatrix}\n0 & n_1 a \\sqrt{2-2 \\cos\\alpha} & 0  \\\\\n-n_2 a\\sqrt{ \\frac{2-2 \\cos\\alpha}{3} } & -n_2 a \\sqrt{2-2 \\cos\\alpha}  & 0 \\\\\n0 & 0 & n_3 a \\sqrt{3+6\\cos\\alpha}\n\\end{pmatrix}\n= \\\\ \\\\ \\begin{pmatrix}\nn_1 & n_1 & 0 \\\\\n-n_2 & n_2 & 0 \\\\\n0 & 0 & n_3\n\\end{pmatrix}\n\\begin{pmatrix}\na\\sqrt{2-2\\cos\\alpha} & 0 & a\\sqrt{\\frac{1+2\\cos\\alpha}{3}} \\\\\n-a\\sqrt{\\frac{1-\\cos\\alpha}{2}} & a\\sqrt{3\\frac{1-\\cos\\alpha}{2}} & a\\sqrt{\\frac{1+2\\cos\\alpha}{3}} \\\\\n-a\\sqrt{\\frac{1-\\cos\\alpha}{2}} & -a\\sqrt{3\\frac{1-\\cos\\alpha}{2}} & a\\sqrt{\\frac{1+2\\cos\\alpha}{3}}\n\\end{pmatrix}\n\\end{split}\n\\end{equation*}\n There are too many ways to build supercells to list here. The examples are suggestions so that you can pick a supercell that is as cubic as possible. Converging results with respect to supercell size goes approximately as the size of the largest sphere you can fit in the cell. Automatic generation The option -na will try to determine a non-diagonal supercell that is as cubic as possible, with the number of atoms close to the specified value. It does it by generating a massive amount of possible supercell transformation matrices, and comparing the ratio of the cell volume and the volume of the inscribed sphere. By optimizing with respect to this ratio, a reasonably cubic cell should be the result. Very useful when you have a unitcell with a tricky shape and it's non-trivial to figure out a meaningful transformation matrix. To clarify, a cell defined by vectors $\\mathbf{a}$, $\\mathbf{b}$ and $\\mathbf{c}$ will have the volume \nV=\\left|\\det\n\\begin{pmatrix}\n  a_x & a_y & a_z \\\\\n  b_x & b_y & b_z \\\\\n  c_x & c_y & c_z\n\\end{pmatrix}\\right|\n In the same cell, the radius largest sphere that can be inscribed is given by \n2r=\\min\\left\\{\n\\left|\\frac{ \\mathbf{b} \\times \\mathbf{c} }{\\left| \\mathbf{b} \\times \\mathbf{c} \\right|}\\cdot \\mathbf{a}\\right| \\,,\\quad\n\\left|\\frac{ \\mathbf{a} \\times \\mathbf{b} }{\\left| \\mathbf{a} \\times \\mathbf{b} \\right|}\\cdot \\mathbf{c}\\right| \\,,\\quad\n\\left|\\frac{ \\mathbf{a} \\times \\mathbf{c} }{\\left| \\mathbf{a} \\times \\mathbf{c} \\right|}\\cdot \\mathbf{b}\\right|\n\\right\\}  \n I define the ratio \nf&#94;3 = \\frac{r&#94;3 4 \\pi}{3V} \\le 1\n As the function to be maximized (it is the ratio of the filling ratio of a cell and the filling ratio of a cube with the same volume, a value of 1 indicates a perfect cube). The algorithm works by searching the space of non-diagonal supercell matrices that produce approximately the desired number of atoms and simultaneously maximize the filling ratio. This algorithm produces rather non-intuitive cells. Consider Bi 2 Te 3 defined in the primitive rhombohedral cell: Bi2Te3\n  10.314046162\n 0.243360208934  0.000000000000  0.969935981757\n-0.121680104467  0.210756123207  0.969935981757\n-0.121680104467 -0.210756123207  0.969935981757\nBi Te\n2 3\ndirect coordinates\n 0.599898812406  0.599898812406  0.599898812406 site: 1\n 0.400101187594  0.400101187594  0.400101187594 site: 2\n 0.791308614612  0.791308614612  0.791308614612 site: 3\n 0.208691385388  0.208691385388  0.208691385388 site: 4\n 0.000000000000  0.000000000000  0.000000000000 site: 5 Using this algorithm I found the supercell matrix \nM=\\begin{pmatrix}\n3 & 2 & -4 \\\\\n4 & -3 & -2 \\\\\n-2 & 4 & -3\n\\end{pmatrix}\n that produce the lattice vectors Bi2Te3 upercell\n      10.314046161996\n    0.97344083573636     1.26453673924247     0.96993598175736\n    1.58184135807159    -0.21075612320708    -0.96993598175736\n   -0.60840052233523     1.47529286244955    -0.96993598175736\n Bi Te\n 86 129 This cell has a filling ratio corresponding to 98.4% of the ideal cube. I doubt I could have guessed how to generate this supercell. Input files infile.ucposcar Output files outfile.ssposcar","tags":"","loc":"program/generate_structure.html","title":"\n    \n        generate structure – TDEP\n    \n"},{"text":"Short description Use forceconstants or a Debye temperature to generate uncorrelated supercell configurations emulating a canonical ensemble. These configurations can be used to either start ensemble runs of molecular dynamics with negligible equilibration time, or be used to directly sample phase space. Command line options: Optional switches: --temperature value , -t value default value 300 Temperature to emulate --nconf value , -n value default value 5 Number of configurations to generate --quantum default value .false. Use Bose-Einstein statistics instead of Maxwell-Boltzmann. That is, use  \\sqrt{\\frac{\\hbar (2n+1) }{2 m \\omega}}  as the mean normal mode amplitudes instead of the classical  \\frac{1}{\\omega}\\sqrt{\\frac{k_BT}{m}}  --output_format value , -of value , value in: 1,2,3,4 default value 1 Selects output format. 1 is VASP, 2 is Abinit, 3 is LAMMPS, 4 is FHI-Aims. Default 1. --threshold value default value -1 Minimum frequency to consider. Frequencies smaller than this number will be replaced by this number when evaluating displacements. Useful for materials with extremely low-lying modes that can cause divergencies. --debye_temperature value , -td value default value -1 Generate forceconstants that match a Debye temperature, and build displacements according to these. See details below. --maximum_frequency value , -mf value default value -1 Generate forceconstants that match a maximum frequency (in THz), and build displacements according to these. See details below. --help , -h Print this help message --version , -v Print version Examples canonical_configuration -n 10 -t 300 canonical_configuration -n 300 -t 0 --quantum canonical_configuration -n 20 -t 10 --quantum --debye_temperature 400 Longer summary This code takes a second order forceconstant and generates a supercell with the atoms displaced corresponding to a harmonic canonical ensemble. These configurations can be used directly, to generate force-displacement statistics to determine force constants and other thermal properties, or as the starting point for molecular dynamics. Background Born-Oppenheimer molecular dynamics can be expensive for many reasons. Firstly, it requires supercells with more than 100 atoms. Secondly, computation of the electronic ground state at every time step is time consuming. Thirdly, the cell must be fully equilibrated. The precision of the calculations is statistically linked to the number of configurations used: any property $A$ for which we want to calculate the ensemble average $\\langle A \\rangle$ must be converged with respect to the number of uncorrelated time steps. To minimize the equilibration time, the simulation cell can be initialized to a thermally excited state by selecting initial atomic velocities and displacement amplitudes according to the Maxwell-Boltzmann 1 or Bose - Einstein distributions. Starting with the equations of motion for the supercell (given harmonic force constants ) \n\\begin{equation}\n\\begin{pmatrix}\nm_1 \\ddot{\\mathbf{u}}_1 \\\\\nm_2 \\ddot{\\mathbf{u}}_2 \\\\\n\\vdots \\\\\nm_{N_a} \\ddot{\\mathbf{u}}_{N_a}\n\\end{pmatrix}=\n\\begin{pmatrix}\n\\mathbf{\\Phi}_{11} & \\mathbf{\\Phi}_{12} & \\cdots & \\mathbf{\\Phi}_{1N_a} \\\\\n\\mathbf{\\Phi}_{21} & \\mathbf{\\Phi}_{22} & \\cdots & \\mathbf{\\Phi}_{2N_a} \\\\\n\\vdots & \\vdots & \\ddots & \\vdots \\\\\n\\mathbf{\\Phi}_{N_a1} & \\mathbf{\\Phi}_{N_a2} & \\cdots & \\mathbf{\\Phi}_{N_aN_a}\n\\end{pmatrix}\n\\begin{pmatrix}\n\\mathbf{u}_1\\\\\n\\mathbf{u}_2 \\\\\n\\vdots \\\\\n\\mathbf{u}_{N_a} \\\\\n\\end{pmatrix}\n\\end{equation}\n we diagonalise these and get obtaining $3N_a$ eigenvalues $\\omega&#94;2_s$ and eigenvectors $\\epsilon_s$. In the given cell, we can use this normal mode transformation to express the instantaneous positions and velocities, \n\\begin{align}\nu_i = & \\sum_{s=1}&#94;{3N_a} \\epsilon_{is} A_{is} \\sin( \\omega_s t+\\delta_s ) \\\\\n\\dot{u}_i = & \\sum_{s=1}&#94;{3N_a} \\epsilon_{is} A_{is} \\omega_s \\cos( \\omega_s t+\\delta_s)\n\\end{align}\n This is identical to the transformation introduced in phonon dispersion relations , except that the masses are incorporated in the normal mode amplitudes. We also omit the choice of $\\mathbf{q}$-vector, since we are only interested in the modes that are commensurate with the supercell. This leads to the dynamical matrix being a real symmetric matrix, with real eigenvalues and real eigenvectors. The normal mode amplitudes $A_s$ and the phase $\\delta_s$ will be determined by the following boundary conditions: we require a set of positions and velocities that correspond to a canonical ensemble. We choose $A_s$ so that they are normally distributed around their mean value and that each mode $s$ should contribute, on average, $k_B T/2$ to the internal energy. Then \n\\begin{equation}\n\\langle A_{is} \\rangle =\n\\sqrt{\\frac{\\hbar (2n_s+1) }{2 m_i \\omega_s}}\n\\approx\n\\frac{1}{\\omega_s}\\sqrt{\\frac{k_BT}{m_i}},\n\\end{equation}\n where the approximate result is in the classical limit, $\\hbar \\omega \\ll k_BT $. The appropriate distribution of atomic positions and velocities is given by, \n\\begin{align}\nu_i & = \\sum_{s=1}&#94;{3N_a}\n\\epsilon_{is} \\langle A_{is} \\rangle \\sqrt{-2\\ln \\xi_1}\\sin 2\\pi\\xi_2 \\\\\n\\dot{u}_i & = \\sum_{s=1}&#94;{3N_a}\n\\omega_s \\epsilon_{is} \\langle A_{is} \\rangle \\sqrt{-2\\ln \\xi_1}\\cos 2\\pi\\xi_2\n\\end{align}\n Here, $0 \\lt \\xi_n \\lt 1$, represents a uniform distribution of random numbers, which are transformed to a normal distribution using the standard Box-Muller transform. Choosing the mean amplitudes in the classical limit gives us a snapshot in time from a canonical Maxwell-Boltzmann ensemble (within the harmonic approximation), which results in a starting point that reduces the time until equilibration by orders of magnitude. Choosing a Bose-Einstein distribution of mean amplitudes and velocities instead allows us to sample phase space while including quantum thermal disorder at low temperatures. For applications where one does not need consecutive timesteps, the starting configurations generated by this can be used  by run several simultaneous instances of Born-Oppenheimer molecular dynamics with different random starting configurations, rather than running a single long instance. This strategy allows for parallelization of Born-Oppenheimer molecular dynamics with near perfect linear scaling, since the overhead of equilibration time is almost completely eliminated. This is illustrated in the plot above. This is the singular value decomposition of molecular dynamics trajectories. A single colored field corresponds to data from a single random initial starting configuration. The dimensions spanned per unit time is greatly increased by stitching together calculations from different initial configurations. That is, 10 MD runs of 1000 time steps explores phase space better than a single MD run of 10x1000 time steps. Matching with a Debye temperature Up until this point we have assumed you have forceconstants to generate the normal mode displacements. If you don't, it's possible to guess them. The following procedure is used: assume a pair potential $U(r)$ which obeys \n\\begin{equation}\n\\frac{ \\partial U(r)}{\\partial r_{ij} }=0\n\\end{equation}\n and \n\\begin{equation}\n\\frac{ \\partial&#94;2 U(r)}{\\partial r_{ij}&#94;2 }=\\frac{\\alpha}{r_{ij}&#94;4}\n\\end{equation}\n Here $r_{ij}$ is a pair distance in the supercell. Forceconstants can be calculated analytically from a pair potential, in this case they are given by \n\\begin{equation}\n\\mathbf{\\Phi}(r)=\n-\\frac{\\alpha}{r&#94;6}\n\\begin{pmatrix}\nr_x&#94;2 & r_x r_y & r_x r_z \\\\\nr_x r_y & r_y&#94;2 & r_y r_z \\\\\nr_x r_z & r_y r_z & r_z&#94;2  \n\\end{pmatrix}\n\\end{equation}\n By definition, this will always produce stable phonons with the correct symmetry. The parameter $\\alpha$ is determined by numerically matching the zero-point motion of the phonons to a Debye temperature (option --debyte_temperature ): \n\\begin{equation}\n\\frac{1}{N} \\sum_i \\frac{\\hbar \\omega_i(\\alpha)}{2} = \\frac{9 k_B T_D}{8}\n\\end{equation}\n Or alternatively matching the maximum frequency to a reference value (option --maximum_frequency ). Using actual forceconstants is of course better, but this procedure generates surprisingly good configurations. Stochastic sampling The thermalized samples produced by this code can be used to obtain finite-temperature interatomic force constants directly. A small tutorial is provided here . Input files infile.ucposcar infile.ssposcar (use generate structure to create one) infile.forceconstant (or use --debye_temperature as described above) Output files The desired number of configurations are printed in VASP POSCAR format by default, but the --output_format option can provide output in a variety of formats. contcar_conf0001 contcar_conf0002 contcar_conf0003 ... In case you used a Debye temperature to generate the configurations, outfile.fakeforceconstant will be written. Use phonon dispersion relations to plot it and check that the frequencies are reasonable. West, D., & Estreicher, S. (2006). First-Principles Calculations of Vibrational Lifetimes and Decay Channels: Hydrogen-Related Modes in Si. Physical Review Letters, 96(11), 115504. ↩","tags":"","loc":"program/canonical_configuration.html","title":"\n    \n        canonical configuration – TDEP\n    \n"},{"text":"Getting started To get started, make sure you meet the dependencies and install everything. While things are compiling, it might be a good idea to familarize yourself with the literature, starting with a shameless plug for my papers: Hellman, O., Abrikosov, I. A., & Simak, S. I. (2011). Lattice dynamics of anharmonic solids from first principles. Physical Review B, 84(18), 180301. Hellman, O. & Abrikosov, I. A. (2013). Temperature-dependent effective third-order interatomic force constants from first principles. Physical Review B, 88(14), 144301. Hellman, O., Steneteg, P., Abrikosov, I. A., & Simak, S. I. (2013). Temperature dependent effective potential method for accurate free energy calculations of solids. Physical Review B, 87(10), 104111. This provides background, but does not accurately reflect all the capabilities of this software package. Usage This software package consist of several programs, meant to be chained together into workflows, depending on property you are interested in. Before trying anything too complicated, make sure you start with the tutorial , everything named minimal example . The descriptions of each program serves as both reference and theoretical background. For things to make sense, read them in this order: extract forceconstants phonon dispersion relations lineshape thermal conductivity","tags":"","loc":"page//index.html","title":"Manual – TDEP"},{"text":"This package is written mainly in fortran, with parts in c, c++, and python. The minimum requirements are fortran compiler. Tested with gcc 5+, ifort 14+. Several f2003/2008 features are extensively used, so the compiler needs to be rather new. MPI fftw hdf5 python In addition, to make use of all features you might want to install gnuplot, tested with 4+ on OSX with aquaterm this documentation is generated with FORD . Note I do all the development in OSX, and install all libraries/dependencies with homebrew . For reference, these are the things I installed, and referred to in the sample important_settings: brew install gcc fftw --with-fortran openmpi gnuplot --with-aquaterm hdf5 --with-fortran --with-fortran2003 If you do the same, installation should be a breeze. Download Todo Will fix once I make the repository public. Dependencies MPI Nothing special is required by the MPI installation, except that it needs to support MPI_IN_PLACE . I have never had any issues with specific MPI implementations. hdf5 It is likely that the cluster you use already has hdf5 installed. If not, compiling is a breeze (except on Cray systems) usually, I use ./configure FC = XX CC = XX --with-fortran --with-fortran2003 --prefix = XX\nmake\nmake install Note that the fortran compiler needs to be exactly the same as the one used to compile TDEP later on. Compiling The build system is a little unorthodox, but straightforward. You need to create a file called important_settings , and put it in the root directory of tdep. Several examples are provided, start with the one that seems closest to what you have. An example follows here, for OSX: #!/bin/bash # A central place to put all the important paths. You probably have to modify this to make things work. # the fortran compiler FORTRAN_COMPILER = \"gfortran-7\" # optimization stuff. Go all in. OPTIMIZATION_LEVEL = \"-Ofast\" # the flag that sets the default real to a double. DOUBLE_FLAG = \"-fdefault-real-8\" # The flag that tells the compiler where to put .o and .mod files. MODULE_FLAG = \"-J\" # the header to put in python scripts. PYTHONHEADER = \"#!/usr/bin/python\" # Which gnuplot terminal to use by default. GNUPLOTTERMINAL = \"aqua\" # nice on OSX, needs aquaterm installed and gnuplot compiled with support for it. # Precompiler flags. Selecting default gnuplot terminal, and make the progressbars work. PRECOMPILER_FLAGS = \"-DGP ${ GNUPLOTTERMINAL } -Dgfortranprogressbar\" #PRECOMPILER_FLAGS=\"-DGP${GNUPLOTTERMINAL} -Dgfortranprogressbar -DAGRESSIVE_SANITY\" # these are the flags that are needed for gfortran FCFLAGS = \"-Wl,-commons,use_dylibs -ffree-line-length-none -std=f2008 -fall-intrinsics -cpp -fopenmp\" # These are the BLAS/LAPACK libraries. On OSX with gfortran, use the built-in 'framework accelerate' PATH_TO_BLASLAPACK_LIB = \" \" PATH_TO_BLASLAPACK_INC = \" \" BLASLAPACK_LIBS = \"-framework accelerate\" # I use fftw for Fourier transforms. PATH_TO_FFTW_LIB = \"-L/usr/local/lib\" PATH_TO_FFTW_INC = \"-I/usr/local/include\" FFTW_LIBS = \"-lfftw3\" # Also need MPI PATH_TO_MPI_LIB = \"-L/usr/local/lib\" PATH_TO_MPI_INC = \"-I/usr/local/include\" MPI_LIBS = \"-lmpi_mpifh -lmpi\" # I also use HDF5 every now and then PATH_TO_HDF5_LIB = \"-L/usr/local/lib\" PATH_TO_HDF5_INC = \"-I/usr/local/include\" HDF5_LIBS = \"-lhdf5 -lhdf5_fortran\" # We also need a C-compiler C_COMPILER = \"gcc-7\" # Things below this line is strictly optional, and not really needed except for testing purposes. # If you want to try and use CGAL. Not recommended for people who do not like to sort out compiler errors. USECGAL = \"no\" # CGAL is written in c++. I have wrapper functions in C, that I call from Fortran. CPP_COMPILER = \"gcc-7\" CPP_FLAGS = \"--std=c++0x -frounding-math -O3 -Dusecgal -DCGAL_USE_GMP -DCGAL_USE_MPFR -DCGAL_EIGEN3_ENABLED -DNDEBUG -DBOOST_PARAMETER_MAX_ARITY=12 -Wno-deprecated-declarations\" CGALLINKLINE = \"-lstdc++ -lCGAL -lmpfr -lgmp -lboost_system -lboost_thread-mt\" # It's important at least a majority of these libraries are compiled with the same c++ compiler # as above. You can get strange, strange errors otherwise. As I said, getting this up and running # is not easy. PATH_TO_CGAL_LIB = \"-L/Users/olle/software/CGAL-4.9/build/lib -L/usr/local/lib\" PATH_TO_CGAL_INC = \"-I/Users/olle/software/CGAL-4.9/build/include -I/usr/local/include -I/usr/local/include/eigen3\" # If I want to link with AIMS, I have to specify where it is PATH_TO_AIMS_LIB = \"-L/Users/olle/software/aims/lib\" PATH_TO_AIMS_INC = \"-I/Users/olle/software/aims/src\" AIMS_LIBS = \"-laims.170824.mpi\" once that is set up, run ./build_things.sh And things should start compiling. It will stop at any error, you probably have to install some library or adjust some path in important_settings . Setting paths once build_things.sh has finished, it should have printed a bashrc_tdep file. The rest of the usage guides assumes you put this in your .bashrc or equivalent. It sets the path, manpath and a few minor things, contains the following lines: MANPATH = $MANPATH :/Users/olle/tdep-devel/man PATH = $PATH :/Users/olle/tdep-devel/bin export MANPATH export PATH alias gnuplot = 'gnuplot -persist' If this is set up, you are good to go. Complicated dependencies CGAL You might have noticed that there is an optional dependency on CGAL in the provided important_settings . I wrote a Fortran interface to (a very small subset of) CGAL that can be used to generate meshes, triangulations and other things. The reason it is not enabled by default is that making CGAL and Fortran talk to each other is not straightforward. I can only describe how I got it to work. I don't know if all of these steps are necessary, or if there is some other thing I did that got it to work. This is all for OSX 10.11.4 get the latest CGAL source, I used 4.11, and read the manual installation. when configuring cgal with cmake, specify C and c++ compilers manually to gcc-7 and g++-7 , installed via homebrew. (I never got it working with clang, my guess is that linking becomes easier if the fortran, C and c++ compilers are all gcc.) configure cgal to produce static libraries (untick the box that says BUILD_SHARED_LIBS ) add -DBOOST_PARAMETER_MAX_ARITY=12 to the compile line If this made no sense whatsoever, you probably do not want to try and enable this.","tags":"","loc":"page/./0_installation.html","title":"Installation – TDEP"},{"text":"Part of the package is a set of small tools that help with preparing input for post-processing. What they do is to parse output files and prepare intput files according to this format . If you understand the format (and it is not particularly complicated), it is easy to generate a parsing script for any code. The minimal requirements are positions, forces and energies. Other quantities are there mostly for reference, and can safely be set to zero. VASP The scripts process_outcar.py and process_outcar_5.3.py are used to extract information from VASP OUTCAR files. The usage is straightforward: process_outcar_5.3.py OUTCAR This will create the relevant input files . Alternatively, is you used some statistical sampling method and have many VASP simulations that need to be stitched together, use process_outcar_5.3.py *OUTCAR That is, the script takes any number of OUTCARs as argument. The script assumes you have used ISIF = 2 , since without it forces don't get written. Abinit Todo Get Antoine to send me his script. LAMMPS LAMMPS does not write anything by default. To get usable output, I make sure to add the following to the input file: units metal\n\nvariable          st    equal step\nvariable          tm    equal step\nvariable          Et    equal etotal-v_baseline\nvariable          Ep    equal pe-v_baseline\nvariable          Ek    equal ke\nvariable          tmp   equal temp\nvariable          pr    equal press/10000\nvariable          sxx   equal pxx/10000\nvariable          syy   equal pyy/10000\nvariable          szz   equal pzz/10000\nvariable          sxy   equal pxy/10000\nvariable          sxz   equal pxz/10000\nvariable          syz   equal pyz/10000\n\nfix statdump all print 100 \" ${ st } ${ tm } ${ Et } ${ Ep } ${ Ek } ${ tmp } ${ pr } ${ sxx } ${ syy } ${ szz } ${ sxy } ${ sxz } ${ syz } \" screen no file dump.stat\ndump posdump all custom 100 dump.positions xs ys zs\ndump forcedump all custom 100 dump.forces fx fy fz\ndump_modify posdump format \"%20.15e %20.15e %20.15e\"\ndump_modify forcedump format \"%20.15e %20.15e %20.15e\" The frequency of the dumps and so on can of course be adjusted. Make sure you use generate structure to create the LAMMPS cell file, since it will also create structure input files in the format TDEP needs. These dump files are not exactly the correct format. A small script can rearrange it to the correct format: #!/bin/bash # figure out how many atoms there are na = ` head -n 4 dump.forces | tail -n 1 ` # remove the header from the stat file grep -v '&#94;#' dump.stat > infile.stat # figure out how many timesteps there are nt = ` wc -l infile.stat | awk '{print $1}' ` # create the positions and force files [ -f infile.forces ] && rm infile.forces [ -f infile.positions ] && rm infile.positions for t in ` seq 1 ${ nt } ` do nl = $(( ${ na } + 9 )) nll = $(( ${ nl } * ${ t } )) echo \"t ${ t } ${ nl } ${ nll } \" head -n ${ nll } dump.forces | tail -n ${ na } >> infile.forces\n    head -n ${ nll } dump.positions | tail -n ${ na } >> infile.positions done There are probably far better ways of doing this, happy to take any suggestions.","tags":"","loc":"page/./1_utilities.html","title":"Utility scripts – TDEP"},{"text":"To understand the capabilities of the code, it is useful to browse through the publications that have used it, in one form or another. Hellman, O., Abrikosov, I. A. & Simak, S. I. Lattice dynamics of anharmonic solids from first principles . Phys. Rev. B 84, 180301 (2011). Kim, D. S. et al. Nuclear quantum effect with pure anharmonicity and the anomalous thermal expansion of silicon . Proc. Natl. Acad. Sci. 201707745 (2018). Shulumba, N., Hellman, O. & Minnich, A. J. Intrinsic localized mode and low thermal conductivity of PbSe . Phys. Rev. B 95, 14302 (2017). Mauger, L. et al. Phonons and elasticity of cementite through the Curie temperature . Phys. Rev. B 95, 24308 (2017). Shulumba, N., Hellman, O. & Minnich, A. J. Lattice Thermal Conductivity of Polyethylene Molecular Crystals from First-Principles Including Nuclear Quantum Effects . Phys. Rev. Lett. 119, 185901 (2017). Yang, F. C. et al. Thermally Driven Electronic Topological Transition in FeTi . Phys. Rev. Lett. 117, 76402 (2016). Björkman, T. et al. Vibrational Properties of a Two-Dimensional Silica Kagome Lattice . ACS Nano 10, 10929–10935 (2016). Mozafari, E., Shulumba, N., Steneteg, P., Alling, B. & Abrikosov, I. A. Finite-temperature elastic constants of paramagnetic materials within the disordered local moment picture from ab initio molecular dynamics calculations . Phys. Rev. B 94, 54111 (2016). Shulumba, N. et al. Lattice Vibrations Change the Solid Solubility of an Alloy at High Temperatures . Phys. Rev. Lett. 117, 205502 (2016). Dewaele, A. et al. High pressure-temperature phase diagram and equation of state of titanium . Phys. Rev. B 91, 134108 (2015). Isaeva, L., Hellman, O., Lashley, J. C., Abrikosov, I. A. & Eriksson, O. Dynamic Stabilization of Cubic AuZn . Mater. Today Proc. 2, S569–S572 (2015). Shulumba, N. et al. Temperature-dependent elastic properties of Ti1-xAlxN alloys . Appl. Phys. Lett. 107, 1–4 (2015). Mei, A. B. et al. Reflection thermal diffuse x-ray scattering for quantitative determination of phonon dispersion relations . Phys. Rev. B 92, 174301 (2015). Lan, T. et al. Phonon quarticity induced by changes in phonon-tracked hybridization during lattice expansion and its stabilization of rutile TiO2 . Phys. Rev. B 92, 54304 (2015). Romero, A. H., Gross, E. K. U., Verstraete, M. J. & Hellman, O. Thermal conductivity in PbTe from first principles . Phys. Rev. B 91, 214310 (2015). Abrikosov, I. A. et al. Theoretical description of pressure-induced phase transitions: a case study of Ti-V alloys . High Press. Res. 35, 42–48 (2015). Mei, A. B. et al. Dynamic and structural stability of cubic vanadium nitride . Phys. Rev. B 91, 54101 (2015). Bouchet, J. & Bottin, F. Thermal evolution of vibrational properties of alpha-U . Phys. Rev. B 92, 174108 (2015). Budai, J. D. et al. Metallization of vanadium dioxide driven by large phonon entropy . Nature 515, 535–539 (2014). Miranda, A. L., Xu, B., Hellman, O., Romero, A. H. & Verstraete, M. J. Ab initio calculation of the thermal conductivity of indium antimonide . Semicond. Sci. Technol. 29, 124002 (2014). Hellman, O. & Broido, D. A. Phonon thermal transport in Bi2Te3 from first principles . Phys. Rev. B 90, 134309 (2014). Shulumba, N. et al. Vibrational free energy and phase stability of paramagnetic and antiferromagnetic CrN from ab initio molecular dynamics . Phys. Rev. B 89, 174108 (2014). Li, C. W. et al. Phonon self-energy and origin of anomalous neutron scattering spectra in SnTe and PbTe thermoelectrics . Phys. Rev. Lett. 112, 175501 (2014). Hellman, O., Steneteg, P., Abrikosov, I. A. & Simak, S. I. Temperature dependent effective potential method for accurate free energy calculations of solids . Phys. Rev. B 87, 104111 (2013). Steneteg, P. et al. Temperature dependence of TiN elastic constants from ab initio molecular dynamics simulations . Phys. Rev. B 87, 94114 (2013). Hellman, O. & Abrikosov, I. A. Temperature-dependent effective third-order interatomic force constants from first principles . Phys. Rev. B 88, 144301 (2013).","tags":"","loc":"page/./9_publications.html","title":"Publications – TDEP"},{"text":"Input files This page details the format for all input files. The format of the output files is infile.ucposcar An example of a crystal structure (this is exactly the VASP 5 file format): Bi2Te3\n10.314046162\n 0.243360208934  0.000000000000  0.969935981757\n-0.121680104467  0.210756123207  0.969935981757\n-0.121680104467 -0.210756123207  0.969935981757\nBi Te\n2 3\ndirect coordinates\n0.599898812406 0.599898812406 0.599898812406\n0.400101187594 0.400101187594 0.400101187594\n0.791308614612 0.791308614612 0.791308614612\n0.208691385388 0.208691385388 0.208691385388\n0.000000000000 0.000000000000 0.000000000000 The first line is a comment, the second line a global scaling factor a, and the three following lines the lattice vectors \\mathbf{a}_1,\\mathbf{a}_2,\\mathbf{a}_3. These will be multiplied by a. Next is the specfication of what elements there are, and below that how many of each. The line direct coordinates specify that the coordinates of the atoms are in fractional coordinates. Each atom has it's own line, with two first specifying the Bi positions and the last three Te positions. infile.ssposcar This file hold the ideal positions for the atoms in the supercell. The file format is identical to the unitcell, only that the cell is larger. There is no need for the unit and supercell to be perfectly commensurate: for example with the trigonal unitcell in the example above, I used a supercell based on the hexagonal unit cell. The only requirement is that the two cells describe the same lattice. And by the same, I do not mean almost the same, I mean the same to machine precision. You can not build the supercell from ideal positions and use relaxed positions for the unitcell, for example. infile.positions This file hold the positions. It looks something like this: 8.2561407159200030E-005   2.2226748311341836E-003  0.99884779259537781\n  0.99849619391764632        1.3299790395140015E-003  0.20126465487180664\n  0.99942091881904371       0.99921744312226823       0.39925524034421311\n  0.99726097226994259        9.3000027090734956E-004  0.60117595839769800\n  0.99998106248734664       0.99877980293422230       0.80215876222138049\n   2.7059648117732179E-004  0.20042853805668126        9.0607694878967109E-004\n   4.7165392641841262E-004  0.20049530215652531       0.20005541126842488\n  0.99978563110732910       0.20120110797551810       0.39998540127778304\n   5.9697200870672466E-005  0.20002590513205151       0.60020279388531417\n   1.0832057274455832E-003  0.19752092901626805       0.80125606638730629\n   ... and goes on for many many lines. The format is as follows: Row Description 1  r_1&#94;x \\qquad r_1&#94;y \\qquad r_1&#94;z  2  r_2&#94;x \\qquad r_2&#94;y \\qquad r_2&#94;z  ... ... N_a  r_{N_a}&#94;x \\qquad r_{N_a}&#94;y \\qquad r_{N_a}&#94;z  N_a+1  r_1&#94;x \\qquad r_1&#94;y \\qquad r_1&#94;z  ... ... N_aN_c  r_{N_a}&#94;x \\qquad r_{N_a}&#94;y \\qquad r_{N_a}&#94;z  That is the positions in fractional coordinates for each atom in the simulation cell, in the same order as in infile.ssposcar . Once all the positions are specified, it starts over with the next configuration, for a total of number of atoms times number of configurations lines. infile.forces The format for this file is nearly identical to infile.positions , only that Row Description 1  f_1&#94;x \\qquad f_1&#94;y \\qquad f_1&#94;z  2  f_2&#94;x \\qquad f_2&#94;y \\qquad f_2&#94;z  ... ... N_a  f_{N_a}&#94;x \\qquad f_{N_a}&#94;y \\qquad f_{N_a}&#94;z  N_a+1  f_1&#94;x \\qquad f_1&#94;y \\qquad f_1&#94;z  ... ... N_aN_c  f_{N_a}&#94;x \\qquad f_{N_a}&#94;y \\qquad f_{N_a}&#94;z  each line is the force on each atom in Cartesian coordinates, in eV/Å. Again, a total of number of atoms times number of configurations lines. infile.stat This file contains all the energy and stresses in the following format: Row Description 1  i \\quad t \\quad E_t \\quad E_p \\quad E_k \\quad T \\quad P \\quad \\sigma_{xx} \\quad \\sigma_{yy} \\quad \\sigma_{zz} \\quad \\sigma_{xz} \\quad \\sigma_{yz} \\quad \\sigma_{xy}  2  i \\quad t \\quad E_t \\quad E_p \\quad E_k \\quad T \\quad P \\quad \\sigma_{xx} \\quad \\sigma_{yy} \\quad \\sigma_{zz} \\quad \\sigma_{xz} \\quad \\sigma_{yz} \\quad \\sigma_{xy}  ... ...  N_c   i \\quad t \\quad E_t \\quad E_p \\quad E_k \\quad T \\quad P \\quad \\sigma_{xx} \\quad \\sigma_{yy} \\quad \\sigma_{zz} \\quad \\sigma_{xz} \\quad \\sigma_{yz} \\quad \\sigma_{xy}  One line for every configuration in the simulation. The energies are in eV/supercell, temperature in K, pressure and stress in GPa. Note The information in this file is only crucial when calculating the free energy. For other applications this can safely be filled with mock data. infile.meta Some information about the MD run, an example: 240    # N atoms\n2000   # N timesteps\n1.0    # timestep in fs\n300    # temperature in K The first line is the number of atoms in the simulation, the second line the number of timesteps. Then the timestep and the temperature. Note The timestep and temperature can safely be set to 0, except for autocorrelation and atomic distribution infile.lotosplitting This is an example input file for the long-range electrostatic corrections, also for Bi2Te3. 5.0  0.0  0.0 # three lines for dielectric tensor\n 0.0  5.0  0.0\n 0.0  0.0  7.5\n 8.0  0.0  0.0 # Born effective charge for atom 1, three lines\n 0.0  8.0  0.0\n 0.0  0.0  2.5\n 8.0  0.0  0.0 # Born effective charge for atom 2, three lines\n 0.0  8.0  0.0\n 0.0  0.0  2.5\n-4.5  0.0  0.0 # Born effective charge for atom 3, three lines\n 0.0 -4.5  0.0\n 0.0  0.0 -0.5\n-4.5  0.0  0.0 # Born effective charge for atom 4, three lines\n 0.0 -4.5  0.0\n 0.0  0.0 -0.5\n-7.0  0.0  0.0 # Born effective charge for atom 5, three lines\n 0.0 -7.0  0.0\n 0.0  0.0 -5.1 The first three lines is the dielectric tensor, after that three lines per atom in infile.ucposcar with the Born effective charges. The dielectric tensor is unitless, and the Born effective charges are in electron charges. It is important to note that in general, the Born effective charges are not necessarily symmetric: \nZ_i&#94;{\\alpha\\beta} = \\frac{\\partial&#94;2 U}{\\partial \\epsilon_i&#94;{\\alpha} \\partial u_i&#94;{\\beta}}\n That is derivative with respect to electric field and position. This means it matters how you enter them. In this input file, the convention is as follows: \n\\begin{pmatrix}\n    \\partial_{\\epsilon x}\\partial_{ux} & \\partial_{\\epsilon x}\\partial_{uy} & \\partial_{\\epsilon x}\\partial_{uz} \\\\\n    \\partial_{\\epsilon y}\\partial_{ux} & \\partial_{\\epsilon y}\\partial_{uy} & \\partial_{\\epsilon y}\\partial_{uz} \\\\\n    \\partial_{\\epsilon z}\\partial_{ux} & \\partial_{\\epsilon z}\\partial_{uy} & \\partial_{\\epsilon z}\\partial_{uz}\n\\end{pmatrix}\n infile.qpoints_dispersion Many programs output properties along a path in the BZ. Per default, this is generated procedurally. In case the default is not satisfactory, you have the possibility to specify a path. FCC                         ! Bravais lattice type\n  100                       ! Number of points on each path\n    4                       ! Number paths between special points\nGM  X                       ! Starting and ending special point\nX   U                       !\nK   GM                      !\nGM  L                       ! Where the first line specify the Bravais family, followed by the number of points on each line segment and the number of line segments. Each line segment is specified by two labels. Use crystal structure info to get a list of the possible labels and their coordinates. If this is not flexible enough, an arbitrary path can be specified CUSTOM                      !\n  100                       ! Number of points on each path\n    4                       ! Number paths between special points\n0.000 0.000 0.000   0.000 0.500 0.500 GM X\n0.000 0.500 0.500   0.000 0.625 0.375 X  U\n0.375 0.750 0.375   0.000 0.000 0.000 K  GM\n0.000 0.000 0.000   0.000 0.500 0.000 GM L This is the same path as above, but explicitly specified. Each segment is specified by 3+3 numbers and two labels. The coordinates are reciprocal fractional. infile.isotopes The phonon many-body perturbation theory considers scattering by isotopes. By default, they will use the natural distribution (tabulated in the code, taken from the symbol in infile.ucposcar ). In case you want to specify some other distribution, you can: 1         # number of isotopes for first atom in infile.ucposcar\n1 28.0855 # concentration, mass, one line per isotope\n2         # number of isotopes for second atom\n0.5 12.0  # concentration, mass\n0.5 13.0  # concentration, mass\n... Per atom in the unit cell, you specify the number of isotopes, followed by the appropriate number of concentrations and masses (in atomic mass units).","tags":"","loc":"page/./files.html","title":"Files – TDEP"},{"text":"This series of workflows are writtin as a combination of instructions and tutorials. This software package is easy to use, but the underlying physics are not trivial. There are some deliberate barriers introduced as attempts to force a good understanding from the user. I am expecting limited success. The minimal examples should be done first, that each deal with fundamental parts: Example 1 : will get you started and plot some stuff. Example 2 : basic MD input preparation. Example 3 : stochastic input preparation. Example 4 : free energy. Example 5 : thermal conductivity. Example 6 : properties as a function of temperature. With that taken care, I plan to add proper examples of projects with production quality data. Dig up some old stuff I already published.","tags":"","loc":"page/workflows/index.html","title":"Workflows – TDEP"},{"text":"Phonon dispersions and spectral function Following this example you will calculate the phonon dispersion relations and the phonon spectral function of fcc Al. I assume everything is installed, and that the tdep/bin folder is added to your path. Navigate to tests/test_1_fcc_al . There you will find infile.ucposcar infile.ssposcar infile.positions infile.forces infile.meta infile.stat which are prepared input files. Copy these to a new folder and work from there (not a reuqirement, but makes it easy to start over in case you mess up). First, we are interested in the phonon frequencies, and for that we need second order force constants . We use extract_forceconstants -rc2 5 This means we want forceconstants including all neighbours within 5Å. Hopefully, a new file should appear: outfile.forceconstant , along with some other files we ignore for now. Files named infile.something will not get overwritten, but those named outfile.something might. For files to be read by other programs , you need to rename it, preferably like this: ln -s outfile.forceconstant infile.forceconstant To get the phonon dispersion relations we use phonon_dispersion_relations Frequency as a function of q-vector is written to outfile.dispersion_relations . If gnuplot is properly set up (if gnuplot just flashes, it's probably because it is missing the --persist option), you can run gnuplot outfile.dispersion_relations.gnuplot And you should see something like this: If we want to know something about the broadening we need third order force constants. To get these, we rerun extract_forceconstants -rc2 5 -rc3 3 And it will produce a new forceconstant file, outfile.forceconstant_thirdorder . Again, we need to copy (or link) it to an infile: ln -s outfile.forceconstant_thirdorder infile.forceconstant_thirdorder Once this is set up, we use the lineshape code to produce the phonon spectral function: mpirun lineshape --path -qg 7 7 7 -ne 600 --temperature 800 and this produces, among other things, an outfile.sqe (and the hdf5 version of the same data, outfile.sqe.hdf5 ). I read this into matlab and plotted it with a logarithmic intensity scale, and the results look something like this: This is a sample matlab code snippet to produce this plot: % read everything from file fn =( 'outfile.sqe.hdf5' ); x = h5read ( fn , '/q_values' ); y = h5read ( fn , '/energy_values' ); gz = h5read ( fn , '/intensity' ); xtck = h5read ( fn , '/q_ticks' ); xtcklabel = strsplit ( h5readatt ( fn , '/' , 'q_tick_labels' )); energyunit = h5readatt ( fn , '/' , 'energy_unit' ); % plot the results figure ( 1 ); clf ; hold on ; box on ; [ gy , gx ]= meshgrid ( y , x ); s = pcolor ( gx , gy , log10 ( gz + 1E-2 )); set ( s , 'edgecolor' , 'none' , 'facecolor' , 'interp' ) set ( gca , 'xtick' , xtck , 'xticklabel' , xtcklabel ) ylabel ([ 'Energy (' energyunit ')' ]) xlim ([ 0 max ( x )]) ylim ([ 0 max ( y )]) And an equivalent snippet using matplotlib import matplotlib.pyplot as plt import numpy as np import h5py as h5 from matplotlib.colors import LogNorm # open the sqe file f = h5 . File ( 'outfile.sqe.hdf5' , 'r' ) # get axes and intensity x = np . array ( f . get ( 'q_values' )) y = np . array ( f . get ( 'energy_values' )) gz = np . array ( f . get ( 'intensity' )) # add a little bit so that the logscale does not go nuts gz = gz + 1E-2 # for plotting, turn the axes into 2d arrays gx , gy = np . meshgrid ( x , y ) # x-ticks xt = np . array ( f . get ( 'q_ticks' )) # labels for the x-ticks xl = f . attrs . get ( 'q_tick_labels' ) . split () # label for y-axis yl = \"Energy (\" + f . attrs . get ( 'energy_unit' ) + \")\" plt . pcolormesh ( gx , gy , gz , norm = LogNorm ( vmin = gz . min (), vmax = gz . max ()), cmap = 'viridis' ) # set the limits of the plot to the limits of the data plt . axis ([ x . min (), x . max (), y . min (), y . max ()]) plt . xticks ( xt , xl ) plt . ylabel ( yl ) plt . show () Read the documentation for the codes used, and familiarize yourself with their capabilities before moving on. A couple of things that should be very easy, and a final one that requires some thought: Change the q-point path through the Brillouin zone. First plot the dispersions along this new path, then the spectralfunction. hint. Plot the phonon DOS in units of meV from the second order force constants. Understand the difference between the different ways to integrate. hint. Get the broadened phonon DOS at some temperature. Try to understand the difference in integration technique when doing this, and the example above. hint. Get the phonon free energy at 450K. hint. Figure out what depends on what. If you have calculated the spectralfunction at 300K, and want to do it with a tighter q-point grid, from what step do you have to start over? If you want a longer cutoff for the second order force constants, from what step do you have to repeat the procedure?","tags":"","loc":"page/workflows/minimal_example_1.html","title":"Minimal example I – TDEP"},{"text":"Create the input files In this example we want to produce input files similar to those provided in the first minimal example by setting up the required files, running VASP and postprocessing. But since this is a tutorial, you do not need to actually run any DFT calculations, the output files are provided in examples/example_2_ScF3 . Preparing input Start by making an empty working directory. The first step is to prepare the unit cell. In this particular case, use this and and name it infile.ucposcar ScF3\n   4.011000\n  1.000000000000000   0.000000000000000   0.000000000000000\n  0.000000000000000   1.000000000000000   0.000000000000000\n  0.000000000000000   0.000000000000000   1.000000000000000\n Sc F\n   1   3\nDirect\n  0.000000000000000   0.000000000000000   0.000000000000000\n  0.500000000000000   0.000000000000000   0.000000000000000\n  0.000000000000000   0.000000000000000   0.500000000000000\n  0.000000000000000   0.500000000000000   0.000000000000000 The format is specified here . To run molecular dynamics, you need a larger simulation cell. I have provided tools for that: generate_structure -d 4 4 4 again, change the output to input mv outfile.ssposcar infile.ssposcar This is the preferred way of generating supercells. Any script should do, but some of them that exist out there do not use double precision for some odd reason. The symmetry analysis is rather sensitive, and assumes that the unit- and supercell describe exactly the same lattice, to machine precision. Almost the same is not good enough. This can not be stressed enough, in my experience this is the most common source of problems, and it is easily avoided. When in doubt, use at least 12 decimal places. A common problem is that .cif-files sometimes write too few digits for e.g. \\sqrt(3)/2 for my codes to correctly differentiate between crystal lattices. For example, this is really bad: hcp Fe\n 2.4\n   0.50000  -0.866025  0.00000\n   0.50000   0.866025  0.00000\n   0.00000   0.000000  1.63299\nFe\n   2\nDirect\n   0.333333333333333   0.666666666666667   0.250000000000000\n   0.666666666666667   0.333333333333333   0.750000000000000 whereas this is good: hcp Fe\n 2.4\n   0.500000000000000  -0.866025403784439  0.000000000000000\n   0.500000000000000   0.866025403784439  0.000000000000000\n   0.000000000000000   0.000000000000000  1.632993161855452\nFe\n   2\nDirect\n   0.333333333333333   0.666666666666667   0.250000000000000\n   0.666666666666667   0.333333333333333   0.750000000000000 It is a deliberate choice to set tolerances this tight: there is absolutely no reason why you should not be defining structures to high precision. Loose tolerances can cause subtle errors that are far more annoying to track down than entering those extra digits. Use the primitive unit cell The symmetry analysis is clever enough to ensure that you get the same forceconstants regardless of the cell you use, but you should use the smallest possible unit cell. There are tools available to rearrange forceconstants to larger unit cells, but not from a larger cell to a smaller. So by using the smallest possible cell, you can always change your mind later. Running a VASP simulation With the structure defined, we can run some molecular dynamics. In this pariticular example we do it cooking-show style: the output is already prepared. Nonetheless, this is what the input looks like (INCAR only, there is nothing special in the other input files): ENCUT = 600\nISMEAR = 0\nISIF = 2\nIBRION = 0\nNSW = 10000\nEDIFF = 1E-5\nIALGO = 48\n\nPOTIM = 2\nTEBEG = 150\nSMASS = 0 There are some things that might seem nonstandard. The energy cutoff is very high. I start convergence testing at about double the default, ENCUT = 2*ENMAX , where the default is read from the POTCAR files. You can not use tetrahedron integration, you must use some smearing. Fermi smearing makes the most sense, but requires a really tight k-point grid. It differs from what you might normally do in that we require high-quality forces, and not much else. Speaking of that, the tag ISIF = 2 is crucial, since without it forces will not get printed to OUTCAR . At this stage, you would run the simulations. Starting molecular dynamics from ideal lattice positions usually require a long equilibration time that has to be discarded. This time can be minimized by using a better seed. A program to do this is provided, see canonical configuration . Parsing VASP output Pretend that you started VASP and let it run for a while, and copy examples/example_2_ScF3/OUTCAR to the working directory and run process_outcar_5.3.py OUTCAR and all the input files should be created. From this point, repeat the steps in the first example . Note that these are not converged calculations by any means, the provided example is just 80 time steps using a single k-point for the electronic structure calculations (github is really not the place to put large output files, if I can figure out a place to host large files, I will put production quality files here). TLDR The short version if you are impatient: get a unitcell make a supercell run VASP run process_outcar_5.3.py I could have started with this, but I wanted you to understand a bit what you should and should not do. Things to understand: Some things to consider: Read the documentation for process_outcar_5.3.py , figure out how to stitch a continuation job together. Maybe you ran VASP with some settings that makes the OUTCAR parsing fail. Make sure you understand how to construct the input files manually.","tags":"","loc":"page/workflows/minimal_example_2.html","title":"Minimal example II – TDEP"},{"text":"Really fast stochastic calculations Todo Will arrive when I publish","tags":"","loc":"page/workflows/minimal_example_3.html","title":"Minimal example III – TDEP"},{"text":"Basic free energy calculations Navigate to /example_4_free_energy . There you should see 5 folders, each corresponding to a simulation at fix temperature, but different volumes. This particular case is PbTe at 600K. Copy all the contents to a new folder. First, we will get the free energy at a single volume. Pick one of the folders, perhaps volume_1 . We will constrain ourselves to second order force constants, run: extract_forceconstants -rc2 100 -U0\nln -s outfile.forceconstant infile.forceconstant\nphonon_dispersion_relations -loto --dos -qg 36 36 36 --temperature 300 This will produce plenty of output. The first lines calculates the second order forceconstants, including the option of calculating the renormalized baseline energy. You should have read about forceconstants already, and perhaps this is a good time to familiarize yourself with free energy calculations a bit. I put a decent explanation of the different terms here . Glance through the documentation and see what the different command line options do. The things you need for the free energy is the renormalized baseline, $U_0$, and the phonon free energy $F_{\\textrm{ph}}$. These will be in outfile.U0 and outfile.free_energy respectively. If everything worked out ok, you should have something like Fph = -0.26006391 eV/atom \nU0  = -3.76922936 eV/atom So, by adding these numbers you get the Helmholtz free energy. Electronic entropy will be included, provided that it is in $U_0$. It is up to you to ensure that the underlying DFT calculations include that properly. You can't get that much useful information from a single point in volume-temperature space, lets get the free energy for all the volumes, conveniently done with a small script: #!/bin/bash # Get the forceconstants and free energy for every volume for i in 1 2 3 4 5 do cd volume_ ${ i } extract_forceconstants -rc2 100 -U0\n        ln -sf outfile.forceconstant infile.forceconstant\n        phonon_dispersion_relations --dos --temperature 600 -qg 32 32 32 --loto cd .. done This should result in a list of volumes and energies (it does not appear magically, you have to fetch the numbers): Volume        U0           Fph\n 29.92236913  -3.76922936  -0.26006391 \n 31.84747692  -3.82606181  -0.27327257 \n 33.85343312  -3.84306260  -0.28655016 \n 35.94026710  -3.82961324  -0.30108423 \n 38.11284394  -3.80467151  -0.30650145 Plotting this, and fitting to an equation of state (Birch-Murnaghan) should like like this: Make sure you can reproduce this. Small improvement First thing we can improve is how the forceconstants are extracted. In the script above, we do a full symmetry analysis for each of the volumes. That is fine, but unnecessary. The symmetry of each supercell is the same. If we modify the script slightly #!/bin/bash # Got to the first volume and do the symmetry analysis cd volume_1\n    extract_forceconstants -rc2 100 mv outfile.forcemap.hdf5 ../ cd .. # Reuse the symmetry analysis and get the free energy for i in 1 2 3 4 5 do cd volume_ ${ i } ln -sf ../outfile.forcemap.hdf5 infile.forcemap.hdf5\n        extract_forceconstants -rc2 100 -U0 --readforcemap\n        ln -sf outfile.forceconstant infile.forceconstant\n        phonon_dispersion_relations --dos --temperature 600 -qg 32 32 32 --loto cd .. done If you try it out, you will find that it runs a little faster. Nothing significant in this small case, but for production quality calculations this is useful. Using the same infile.forcemap.hdf5 is also a good idea, which will become apparent later. Exercises to try: Rerun things with different q-point grids for the the phonon free energy. What does the convergence look like? Use subsets of the simulation to calculate $U_0$ (using --stride , explained here ), what does that convergence look like?","tags":"","loc":"page/workflows/minimal_example_4.html","title":"Minimal example IV – TDEP"},{"text":"Essential thermal conductivity Here we will reuse the data in example_1_fcc_Al . Copy the files to a new, clean folder, and repeat the steps from the first tutorial to generate second and third order force constants. You should end up with (among other things) infile.ucposcar infile.forceconstant infile.forceconstant_thirdorder Note that this example is fcc Al. I chose that since with one atom per unit cell, the thermal conductivity calculations are really fast. Unfortunately, since thermal conductivity in Al is dominated by the electronic component, none of the values can be compared with anything in a meaningful way (but that is not the point of this tutorial anyway). To get the thermal conductivity, run mpirun thermal_conductivity -qg 5 5 5 --temperature 300 and it should appear, rather quickly. Make yourself familiar with the options for thermal conductivity , there are quite a few. A series of temperatures can be calculated with mpirun thermal_conductivity -qg 5 5 5 --temperature_range 10 1000 50 --logtempaxis Todo Do a simple q-point convergence Per default, the scattering rates are integrated using the tetrahedron method. 1 Todo Make them test tetrahedron vs gaussian. Lehmann, G., & Taut, M. (1972). On the Numerical Calculation of the Density of States and Related Properties. Physica Status Solidi (B), 54(2), 469–477. ↩","tags":"","loc":"page/workflows/minimal_example_5.html","title":"Minimal example V – TDEP"},{"text":"In the previous sections we dealt with calculations at a single temperature. Sometimes you want properties as a function of temperature. In some folder I prepared some input for ScF 3 Note Or something else. Phonons dispersions as a function of temperature Make them plot in all three folders. Point out that you should only run extractforceconstants once. Plot all three. Interpolate For some reason you realise that you where not interested in the phonon dispersions at x,y,or z K, for reasons unknown you want to determine the dispersions at XX K instead. The naive way would be to do a new calculation at that temperature, but that takes a lot of time. It's better to interpolate. Interpolating the frequencies themselves could be done, but it's not great. Empirically, I have found out that if you interpolate the forceconstants instead, you will have better luck. This is a little involved, so we will break it into steps. Provided you followed the instructions and have run extract forceconstants in all three directories, you might have noted that there are files called outfile.phi_secondorder . As described , these are a list of the irreducible forceconstants. Copy this to an infile cp outfile.phi_secondorder infile.phi_secondorder And run ./extract_forceconstants -r Note that this runs much faster: by invoking the -r flag, it will read the values from file. Now, edit infile.phi_secondorder and change some random value to 100, run ./extract_forceconstants -r\nphonon_dispersion_relations\ngnuplot outfile.dispersion_relations.gnuplot The dispersions will probably look really strange. The point of this exercise was to understand how to modify an irreducible component and get a new outfile.forceconstant out. Since we know how to translate irreducible components to forceconstants, all we need to to is interpolate each irreducible component separately, translate to forceconstants, and calculate dispersions. This way you can get the dispersions at any temperature in the interval. I like to use matlab for this step, but it should be just as easy in python or some other scripting language. I will not go into details, since I assume you know how to interpolate things. You should construct a script that Reads all N outfile.phi_secondorder For each of the values in outfile.phi_secondorder , create an interpolation that can evaluate that value at any temperature. A second order polynomial works great. At a temperature of interest, print a new infile.phi_secondorder with the interpolated values and run extract_forceconstants -r . This gives you a forceconstant at this temperature. Run phonon_dispersion_relations with the new forceconstant, and store outfile.dispersion_relations somewhere. Repeat this for say 50 temperatures in the valid range. Plot the results somehow. If successful, it should look something like this: Todo Some picture Or alternatively, just tracking the TO mode at gamma: Todo Some other picture. Lehmann, G., & Taut, M. (1972). On the Numerical Calculation of the Density of States and Related Properties. Physica Status Solidi (B), 54(2), 469–477. ↩","tags":"","loc":"page/workflows/minimal_example_6.html","title":"Minimal example VI – TDEP"},{"text":"This documentation also details the library. It's easy to write codes. A minimal code that calculates the phonon dispersions on a mesh in the BZ looks something like this: program minimal_example use constants use type_crystalstructure use type_lotosplitting use type_qpointmesh use type_phonon_dispersions use type_forceconstant_secondorder implicit none type ( lo_crystalstructure ) :: uc class ( lo_qpoint_mesh ), allocatable :: qp type ( lo_phonon_dispersions ) :: dr type ( lo_forceconstant_secondorder ) :: fc type ( lo_loto ) :: loto ! read the unitcell call uc % readfromfile ( 'infile.ucposcar' ) ! read the forceconstant call fc % readfromfile ( uc , 'infile.forceconstant' ) ! skip lo-to splitting for now, get an empty one call loto % initempty () ! generate a q-point mesh call lo_generate_qmesh ( qp , uc ,[ 24 , 24 , 24 ], 'monkhorst' ) ! phonon dispersions on this mesh call dr % generate ( qp , fc , uc , loto ) ! get the phonon free energy at 300K write ( * , * ) 'phonon free energy at 300K:' , dr % phonon_free_energy ( 30 0.0_flyt ) end program Lehmann, G., & Taut, M. (1972). On the Numerical Calculation of the Density of States and Related Properties. Physica Status Solidi (B), 54(2), 469–477. ↩","tags":"","loc":"page/workflows/using_the_library.html","title":"Using the library – TDEP"}]}