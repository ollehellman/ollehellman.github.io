var tipuesearch = {"pages":[{"text":"What is this? The TDEP package is a series of tools for finite temperature lattice dynamics. Features include, but are not limited to temperature dependent phonon frequencies, anharmonic free energy and lattice thermal conductivity. The package is released under the MIT license, available on github .","tags":"","loc":"index.html","title":" TDEP "},{"text":"Programs autocorrelation Source Code main.f90 Source Code #include \"precompilerdefinitions\" program autocorrelation !!{!src/autocorrelation/manual.md!} ! use constants use helpers use dump_data use options ! use type_phonon_dispersions use type_phonon_dos use type_phonon_bandstructure use type_forceconstant_secondorder use type_qpointmesh use type_crystalstructure use type_neighbourlist use type_mdsim use type_lotosplitting ! use type_acf use celldimensions use fftwrapper use interpolatesqe ! use type_fcmd ! implicit none ! type ( lo_opts ) :: opts type ( lo_crystalstructure ) :: uc , ss , ss_sqs , ss_vac type ( lo_mdsim ), dimension (:), allocatable :: sims type ( lo_fft_mesh ) :: qp type ( lo_phonon_dispersions ) :: dr type ( lo_loto ) :: loto ! for path type ( lo_phonon_bandstructure ) :: bs type ( lo_forceconstant_secondorder ) :: fc ! for dos type ( lo_monkhorst_pack_mesh ) :: dosqp type ( lo_phonon_dispersions ) :: dosdr type ( lo_phonon_dos ) :: pd , rawpd ! for force constant md type ( lo_fcmd ) :: fcmd ! main thingy type ( lo_acfmdsim ) :: acf ! real ( flyt ) :: f0 integer :: sample ! ! Read options ! call lo_seed_random_numbers () call opts % parse () ! ! I need the underlying unitcell ! call uc % readfromfile ( 'infile.ucposcar' ) ! Read simulation, or create one. if ( opts % fcmd ) then ! Loop over samples allocate ( sims ( opts % fcmd_nsample )) do sample = 1 , opts % fcmd_nsample ! initialize the MD cell call fcmd % setupcell ( uc , opts % fcmd_temperature , opts % fcmd_ssdim , opts % fcmd_timestep , opts % fcmd_langevingamma ) ! get an MD simulation call fcmd % equilibrate ( opts % fcmd_nskip ) call fcmd % run_md ( sims ( sample ), opts % fcmd_nt , opts % fcmd_storestep ) ! setup stuff for acf if ( uc % info % alloy ) then write ( * , * ) 'not done yet.' stop !ss=fcmd%ss !ss_sqs=fcmd%sqs !call sims(sample)%reorder_timesteps(ss_sqs,ss) !call figure_out_cell_dimensions(uc,ss) else ss = fcmd % ss call figure_out_cell_dimensions ( uc , ss ) endif ! Deallocate some of the simulation deallocate ( sims ( sample )% r ) deallocate ( sims ( sample )% u ) deallocate ( sims ( sample )% f ) enddo else ! ! In this case, things are read from files. ! lo_allocate ( sims ( 1 )) call sims ( 1 )% read_from_file ( opts % verbosity ) ! ! Might need some extra info ! if ( uc % info % alloy ) then ! write ( * , * ) '... its an alloy! Sorting a bit' write ( * , * ) 'Also, not done.' stop !   ! !   ! Get the perfect positions in alloy thingy !   call ss%readfromfile('infile.sqs_alloy_supercell') !   ! and the ideal structure of the sqs !   call ss_sqs%readfromfile('infile.sqs') !   ! and now reorder the positions in sim !   call sims(1)%reorder_timesteps(ss_sqs,ss) !   ! and get the cell mapping !   call figure_out_cell_dimensions(uc,ss) elseif ( opts % vacancies ) then ! get the perfect structure call ss % readfromfile ( 'infile.ssposcar_novacancies' ) ! get the perfect structure with vacancies call ss_vac % readfromfile ( 'infile.ssposcar' ) ! call figure_out_cell_dimensions ( uc , ss ) ! else call ss % readfromfile ( 'infile.ssposcar' ) ! cell mapping call figure_out_cell_dimensions ( uc , ss ) ! endif ! write ( * , * ) '... read simulation' ! endif ! ! Get the q-grid ! call qp % generate ( uc , ss % info % supercelldimensions , verbosity = opts % verbosity ) ! ! Kill it if there are no forceconstants present ! if ( opts % useforceconstant . eqv . . false . ) then ! do sample = 1 , size ( sims , 1 ) ! make space call acf % init ( uc , ss , sims ( 1 )% nt , sims ( 1 )% ts ) ! sort and transform it call acf % sortandtransform ( sims ( sample ), ss , qp ) enddo ! ! Write the raw acf data to file ! call dump_raw_spectrum ( acf , dr ) write ( * , * ) 'Now I have done everything there is to do without forceconstants.' write ( * , * ) 'Nag on me to fix the output here.' stop endif ! ! Read the force constants and get the dispersions at the exact q-points ! call fc % readfromfile ( uc ) if ( opts % loto ) then call loto % setoptions ( uc , fc , opts % lotocorrectiontype ) else call loto % initempty () endif call dr % generate ( qp , fc , uc , loto , verbosity = opts % verbosity ) ! ! Get dispersions along a path ! call bs % generate ( uc , fc , loto , npts = opts % nqpath , readpathfromfile = opts % readpathfromfile , verbosity = opts % verbosity ) ! ! Setup the intensity ! lo_allocate ( bs % intensity ( bs % nptot , opts % nf )) lo_allocate ( bs % faxis ( opts % nf )) bs % intensity = 0.0_flyt call lo_linspace ( 0.0_flyt , opts % maxfscale * dr % omega_max , bs % faxis ) ! ! Set up the DOS ! if ( opts % dos ) then ! ! get the mesh call dosqp % generate ( uc , opts % qgrid ) ! Get the full dispersion relations call dosdr % generate ( dosqp , fc , uc , loto ) ! pd % ndos = opts % nf pd % na = uc % na pd % nb = uc % na * 3 pd % dosmax = maxval ( bs % faxis ) pd % dosmin = 0.0_flyt pd % dosprojection = opts % projecteddos lo_allocate ( pd % omega ( pd % ndos )) lo_allocate ( pd % dos ( pd % ndos )) lo_allocate ( pd % pdos_site ( pd % ndos , uc % na )) lo_allocate ( pd % pdos_mode ( pd % ndos , uc % na * 3 )) pd % omega = bs % faxis pd % dos = 0.0_flyt pd % pdos_site = 0.0_flyt ! ! Setup the unsmeared DOS ! rawpd % ndos = opts % nf rawpd % na = uc % na rawpd % nb = uc % na * 3 rawpd % dosmax = maxval ( bs % faxis ) rawpd % dosmin = 0.0_flyt rawpd % dosprojection = opts % projecteddos lo_allocate ( rawpd % omega ( rawpd % ndos )) lo_allocate ( rawpd % dos ( rawpd % ndos )) lo_allocate ( rawpd % pdos_site ( rawpd % ndos , uc % na )) lo_allocate ( rawpd % pdos_mode ( rawpd % ndos , uc % na * 3 )) rawpd % omega = bs % faxis rawpd % dos = 0.0_flyt rawpd % pdos_site = 0.0_flyt ! endif ! do sample = 1 , size ( sims , 1 ) ! make space call acf % init ( uc , ss , sims ( 1 )% nt , sims ( 1 )% ts ) ! sort and transform it call acf % sortandtransform ( sims ( sample ), ss , qp ) ! project onto normal modes call project_onto_normalmodes ( acf , qp , dr ) ! enforce symmetry call enforcesymmetry ( acf , qp ) ! shift lineshapes call shift_all_lineshapes_to_harmonic_frequencies ( acf , opts % nf , opts % maxfscale , dr , qp ) ! add them to S(q,E) call interpolate_lineshapes_to_path ( acf , bs , uc ) ! maybe add to DOS if ( opts % dos ) then ! add the nice interpolated call interpolate_lineshapes_to_dos ( acf , pd , dosqp , dosdr , uc ) ! call add_raw_spectrum_to_dos ( acf , qp , dr , rawpd ) ! endif enddo ! ! Write the lineshapes to file ! call bs % write_intensity ( opts % enhet , omegamax = bs % faxis ( opts % nf ), filename = 'outfile.acf_sqe' ) ! ! Dump the named points ! call dump_highsymm_points ( acf , uc , qp , bs , opts % enhet ) ! ! Dump the DOS ! if ( opts % dos ) then ! the nice dos pd % dos = pd % dos / ( 1.0_flyt * size ( sims , 1 )) pd % pdos_site = pd % pdos_site / ( 1.0_flyt * size ( sims , 1 )) call pd % write_to_file ( uc , opts % enhet , pdfplot = . false ., filename = 'outfile.acf_interpolated_dos' , modeproj = . false .) ! the raw dos f0 = dr % nb / lo_trapezoid_integration ( rawpd % omega , rawpd % dos ) rawpd % dos = rawpd % dos * f0 rawpd % pdos_site = rawpd % pdos_site * f0 call rawpd % write_to_file ( uc , opts % enhet , pdfplot = . false ., filename = 'outfile.acf_raw_dos' , modeproj = . false .) endif write ( * , * ) 'All done!' end program","tags":"","loc":"sourcefile/main.f90.html","title":"main.f90 – TDEP"},{"text":"Programs extract_forceconstants Source Code main.f90 Source Code #include \"precompilerdefinitions\" program extract_forceconstants !!{!src/extract_forceconstants/manual.md!} use constants use type_crystalstructure use type_neighbourlist use type_symmetrytable use type_symmetryoperation use type_mdsim use helpers use options use type_forceconstant_secondorder use type_forceconstant_thirdorder ! use type_forcemap use type_lassosolvers use test_constraints use relax_structure ! implicit none ! my types type ( lo_opts ) :: opts type ( lo_crystalstructure ) :: uc , ss type ( lo_symcell ) :: sy type ( lo_mdsim ) :: sim type ( lo_forcemap ) :: map type ( lo_forceconstant_firstorder ) :: fc1 type ( lo_forceconstant_secondorder ) :: fc2 type ( lo_forceconstant_thirdorder ) :: fc3 real ( flyt ), dimension (:,:), allocatable :: dum real ( flyt ) :: t0 , f0 , f1 , f2 , f3 integer :: i , u , uca , t character ( len = 1000 ) :: opf ! I should determine the general nature of the task here: it could be ! a) ! generate displacements in a smart way ! b) ! get forceconstants from force-displacement data ! c) ! get forceconstants from an input file, for interpolation purposes t0 = walltime () call opts % parse () write ( * , * ) '... reading infiles ' call uc % readfromfile ( 'infile.ucposcar' ) ! ! ! if ( opts % readforcemap ) then if ( opts % readirreducible . eqv . . false . ) call ss % readfromfile ( 'infile.ssposcar' ) write ( * , * ) '... reading symmetry constrained forcemap from file' !call map%readfromfile(uc,ss,'infile.forcemap',opts%readirreducible) call map % read_from_hdf5 ( uc , ss , 'infile.forcemap.hdf5' , opts % readirreducible ) else ! If not, calculate it. Figure out more or less everything related to symmetry, ! with pairs, triplets quartets and so on. call ss % readfromfile ( 'infile.ssposcar' ) write ( * , * ) '... min cutoff: ' , trim ( flyt2char ( ss % mincutoff ())) write ( * , * ) '... max cutoff: ' , trim ( flyt2char ( ss % maxcutoff ())) call sy % generate ( uc , ss , opts % cutoff2 , opts % cutoff3 , opts % cutoff4 ,& testscalar = opts % collmagnetism , testvector = opts % noncollmagnetism ,& testmatrix = opts % loto , verbosity = opts % verbosity , transpositions = . false ., nspace = . true .,& wzdim = opts % wzdimensions , firstorder = opts % firstorder ) ! Build the mapping every which way call map % generate ( sy , uc , ss ) ! Store the map in a file, for future reference write ( * , * ) '... writing forcemap to file' call map % write_to_hdf5 ( uc , ss , 'outfile.forcemap.hdf5' ) ! Dump some info to stdout, about coordination shells and such. write ( * , * ) ' ' write ( * , * ) '... found ' , trim ( int2char ( sy % nun )), ' unique atom(s):' do i = 1 , sy % nun uca = sy % un ( i )% atom_in_uc write ( * , * ) '... atom ' // trim ( int2char ( i )) // ': ' , trim ( uc % atomic_symbol ( uc % species ( uca ))),& ' at position ' // trim ( int2char ( uca )) enddo write ( * , * ) ' ' if ( map % secondorder ) write ( * , * ) '... found ' , trim ( int2char ( map % npairshells )),& ' unique pair coordination shells' if ( map % thirdorder ) write ( * , * ) '... found ' , trim ( int2char ( map % ntripletshells )),& ' unique triplet coordination shells' endif ! Step two is to get irreducible forceconstants, either solve for them or read from file. if ( opts % readirreducible ) then ! yep, read them if ( map % firstorder ) then u = open_file ( 'in' , 'infile.irrifc_firstorder' ) do i = 1 , map % nfc_singlet read ( u , * ) map % ifc_singlet ( i ) enddo close ( u ) endif if ( map % secondorder ) then u = open_file ( 'in' , 'infile.irrifc_secondorder' ) do i = 1 , map % nfc_pair read ( u , * ) map % ifc_pair ( i ) enddo close ( u ) endif if ( map % thirdorder ) then u = open_file ( 'in' , 'infile.irrifc_thirdorder' ) do i = 1 , map % nfc_triplet read ( u , * ) map % ifc_triplet ( i ) enddo close ( u ) endif write ( * , * ) 'creating constraints' call map % create_constraints ( uc , opts % rotationalconstraints ) write ( * , * ) 'enforcing constraints' call map % enforce_constraints () else ! Read the forces and positions. call sim % read_from_file ( verbosity = 2 , stride = opts % stride ) ! create the constraints call map % create_constraints ( uc , opts % rotationalconstraints ) ! Perhaps relax the internal coordinates first? if ( opts % relax ) then ! Try to relax everything do i = 1 , 1 call relax_internal_coordinates ( map , sim , uc , ss , opts % solver , opts % solveralpha , opts % rotationalconstraints ) ! If successful, we need to rebuild the forcemap after this since the internal coordinates changed. call sy % generate ( uc , ss , opts % cutoff2 , opts % cutoff3 , opts % cutoff4 ,& testscalar = opts % collmagnetism , testvector = opts % noncollmagnetism ,& testmatrix = opts % loto , verbosity = opts % verbosity , transpositions = . false ., nspace = . true .,& wzdim = opts % wzdimensions , firstorder = opts % firstorder ) call map % generate ( sy , uc , ss ) call map % create_constraints ( uc , opts % rotationalconstraints ) enddo call uc % writetofile ( 'outfile.relaxed_ucposcar' ) call ss % writetofile ( 'outfile.relaxed_ssposcar' ) ! probably stop here for now. stop endif ! Get the actual forceconstants call solve_equations ( map , sim , opts % solver , opts % solveralpha , opts % residualfit , verbosity = 2 ) ! Write the irreducible components to file if ( map % firstorder ) then u = open_file ( 'out' , 'outfile.irrifc_firstorder' ) do i = 1 , map % nfc_singlet write ( u , * ) map % ifc_singlet ( i ) enddo close ( u ) endif if ( map % secondorder ) then u = open_file ( 'out' , 'outfile.irrifc_secondorder' ) do i = 1 , map % nfc_pair write ( u , * ) map % ifc_pair ( i ) enddo close ( u ) endif if ( map % thirdorder ) then u = open_file ( 'out' , 'outfile.irrifc_thirdorder' ) do i = 1 , map % nfc_triplet write ( u , * ) map % ifc_triplet ( i ) enddo close ( u ) endif endif ! Step three is to convert the irreducible forceconstants to real forceconstants, and write them to output files. if ( map % firstorder ) then call map % get_firstorder_forceconstant ( uc , fc1 ) endif if ( map % secondorder ) then call map % get_secondorder_forceconstant ( uc , fc2 ) call fc2 % writetofile ( uc , 'outfile.forceconstant' ) endif if ( map % thirdorder ) then call map % get_thirdorder_forceconstant ( uc , fc3 ) call fc3 % writetofile ( uc , 'outfile.forceconstant_thirdorder' ) endif ! Now we can do some auxiliary things: first perhaps calculate U0 if ( opts % ediff ) then ! if I don't already have read the simulation, do it now if ( allocated ( sim % r ) . eqv . . false . ) then call sim % read_from_file ( stride = opts % stride ) endif ! get U0 if ( map % secondorder ) then if ( map % thirdorder ) then call sim % forceconstant_potential_energy ( uc , ss , fc = fc2 , fct = fc3 ) else call sim % forceconstant_potential_energy ( uc , ss , fc = fc2 ) endif else call sim % forceconstant_potential_energy ( uc , ss , fct = fc3 ) endif ! dump it to file u = open_file ( 'out' , 'outfile.U0' ) ! ok, this got a little too complicated for something this simple. lo_allocate ( dum ( 4 , sim % nt )) do t = 1 , sim % nt dum ( 1 , t ) = sim % stat % ep ( t ) dum ( 2 , t ) = sim % stat % ep ( t ) - sim % stat % harmonic_ep ( t ) dum ( 3 , t ) = sim % stat % ep ( t ) - sim % stat % harmonic_ep ( t ) - sim % stat % thirdorder_ep ( t ) dum ( 4 , t ) = ( dum ( 2 , t ) ** 2 ) enddo f0 = lo_mean ( dum ( 1 ,:)) / sim % na f1 = lo_mean ( dum ( 2 ,:)) f2 = lo_mean ( dum ( 3 ,:)) / sim % na f3 = lo_mean ( dum ( 4 ,:)) f3 = ( f1 ** 2 - f3 ) / sim % na f1 = f1 / sim % na ! dum = 0.0_flyt write ( u , \"(4(1X,E18.10))\" ) f0 , f1 , f2 , f3 close ( u ) endif ! ! call test_forceconstant_constraints(map,fc1,fc2,fc3,uc) ! call fc2 % get_elastic_constants ( uc ) write ( * , * ) 'elastic constants:' do i = 1 , 6 write ( * , \"(6(3X,F15.5))\" ) fc2 % elastic_constants_voigt (:, i ) / 1 E9_flyt enddo ! write ( * , * ) 'All done in ' , real ( walltime () - t0 ), 'seconds' ! end program","tags":"","loc":"sourcefile/main.f90~2.html","title":"main.f90 – TDEP"},{"text":"Programs crystal_structure_info Source Code main.f90 Source Code #include \"precompilerdefinitions\" program crystal_structure_info !!{!src/crystal_structure_info/manual.md!} ! ! Prints general info about the lattice, high symmetry points and so on. ! use constants use helpers use dump_data use options use geometryfunctions use type_crystalstructure use type_qpointmesh use type_symmetryoperation ! implicit none ! for normal phonon things type ( lo_opts ) :: opts type ( lo_crystalstructure ) :: uc type ( lo_bandstructure ) :: bs ! real ( flyt ), dimension (:,:), allocatable :: dum real ( flyt ), dimension ( 3 ) :: v0 , v1 real ( flyt ) :: tstart , f0 integer :: i , j , u character ( len = 1000 ) :: opf ! ! Get the command line arguments ! tstart = walltime () call opts % parse () ! Read unitcell call uc % readfromfile ( 'infile.ucposcar' , verbosity = opts % verbosity ) if ( uc % info % havebravais . eqv . . false . ) call uc % classify ( 'bravais' ) write ( * , * ) 'Info about the crystal structure:' write ( * , * ) '... I believe the basis is ' , trim ( uc % info % bravaislatticelongname ), ' (' , trim ( uc % info % bravaislattice ), ') with the basis vectors' write ( * , \"(1X,'a1:',3(2X,F18.12))\" ) uc % latticevectors (:, 1 ) write ( * , \"(1X,'a2:',3(2X,F18.12))\" ) uc % latticevectors (:, 2 ) write ( * , \"(1X,'a3:',3(2X,F18.12))\" ) uc % latticevectors (:, 3 ) write ( * , * ) '... and the atoms at these positions (in fractional coordinates)' do i = 1 , uc % na write ( * , '(1X,A8,3(2x,F15.13))' ) trim ( uc % atomic_symbol ( uc % species ( i ))), uc % r (:, i ) enddo ! Print what the conventional basis is f0 = lo_frobnorm ( uc % latticevectors - uc % info % unique_conventional_basis ) if ( f0 . gt . lo_tol ) then write ( * , * ) 'I believe this is the conventional lattice:' write ( * , \"(1X,'a1:',3(2X,F18.12))\" ) uc % info % unique_conventional_basis (:, 1 ) write ( * , \"(1X,'a2:',3(2X,F18.12))\" ) uc % info % unique_conventional_basis (:, 2 ) write ( * , \"(1X,'a3:',3(2X,F18.12))\" ) uc % info % unique_conventional_basis (:, 3 ) endif ! It might not agree with my canonical form. f0 = lo_frobnorm ( uc % latticevectors - uc % info % unique_primitive_basis ) if ( f0 . gt . lo_tol ) then write ( * , * ) ' ' write ( * , * ) 'I like this primitive basis better:' write ( * , \"(1X,'a1:',3(2X,F18.12))\" ) uc % info % unique_primitive_basis (:, 1 ) write ( * , \"(1X,'a2:',3(2X,F18.12))\" ) uc % info % unique_primitive_basis (:, 2 ) write ( * , \"(1X,'a3:',3(2X,F18.12))\" ) uc % info % unique_primitive_basis (:, 3 ) write ( * , * ) '... with the atoms at these positions (in fractional coordinates)' ! Convert the coordinates allocate ( dum ( 3 , uc % na )) do i = 1 , uc % na ! get the current coordinate v0 = uc % r (:, i ) v0 = matmul ( uc % info % permutation_to_unique , v0 ) v0 = lo_chop ( lo_clean_fractional_coordinates ( v0 ), lo_sqtol ) dum (:, i ) = v0 write ( * , '(1X,A8,3(2x,F15.13))' ) trim ( uc % atomic_symbol ( uc % species ( i ))), dum (:, i ) enddo endif ! Get the high symmetry points if ( uc % info % havewedge . eqv . . false . ) call uc % classify ( 'wedge' ) write ( * , * ) ' ' write ( * , * ) 'Available high symmetry points:' write ( * , * ) '(the ones called NP are in fact high symmetry points, but noone has bothered to name them)' write ( * , * ) '      Cartesian coordinates                        Fractional coordinates' do i = 1 , uc % irrw % nnodes v0 = lo_chop ( uc % irrw % r (:, i ), lo_tol ) v1 = lo_chop ( lo_clean_fractional_coordinates ( matmul ( v0 , uc % inv_reciprocal_latticevectors )), lo_tol ) write ( * , \"(1X,I2,1X,A4,3(1X,F13.10),3X,3(1X,F13.10))\" ) i , uc % irrw % label ( i ), v0 , v1 enddo call uc % write_bz_to_hdf5 ( 'outfile.brillouin_zone.hdf5' ) call bs % standardpath ( uc ) bs % npts = 100 write ( * , * ) ' ' write ( * , * ) 'Per default, the following path will be used:' do i = 1 , bs % npath write ( * , * ) trim ( bs % symb_q_start ( i )), ' -> ' , trim ( bs % symb_q_end ( i )) enddo write ( * , * ) 'It is written in \"outfile.qpoints_dispersion\", modify and' write ( * , * ) 'copy it to \"infile.qpoints_dispersion\" if you want' ! ! Dump a path file ! u = open_file ( 'out' , 'outfile.qpoints_dispersion' ) opf = \"(A5,22X,' ! Bravais lattice type')\" write ( u , opf ) uc % info % bravaislattice opf = \"(I5,22X,' ! Number of points on each path')\" write ( u , opf ) 100 opf = \"(I5,22X,' ! Number paths between special points')\" write ( u , opf ) bs % npath opf = \"(A3,1X,A3,20X,' ! Starting and ending special point')\" write ( u , opf ) bs % symb_q_start ( 1 ), bs % symb_q_end ( 1 ) opf = \"(A3,1X,A3,20X,' !')\" do i = 2 , bs % npath write ( u , opf ) bs % symb_q_start ( i ), bs % symb_q_end ( i ) enddo close ( u ) if ( opts % printsymmetry ) then write ( * , * ) ' Symmetry operations:' do i = 1 , uc % sym % n write ( * , * ) 'Operation ' , trim ( int2char ( i )), ' ' , uc % sym % op ( i )% whatkind write ( * , * ) '    Axis:' , lo_chop ( uc % sym % op ( i )% axis , lo_sqtol ) if ( uc % sym % op ( i )% fold . gt . 0 ) write ( * , * ) '   Angle:' , 36 0.0_flyt / uc % sym % op ( i )% fold !write(*,*) '    FMAP:',uc%sym%op(i)%fmap write ( * , * ) ' ... in Cartesian coordinates' do j = 1 , 3 write ( * , \"(6(3X,F15.11))\" ) uc % sym % op ( i )% m ( j ,:) enddo write ( * , * ) ' ... in fractional coordinates' do j = 1 , 3 write ( * , \"(6(3X,F15.11))\" ) uc % sym % op ( i )% fm ( j ,:) enddo enddo ! endif write ( * , * ) 'all done' write ( * , * ) ' ' end program","tags":"","loc":"sourcefile/main.f90~3.html","title":"main.f90 – TDEP"},{"text":"Programs phonon_dispersion_relations Source Code main.f90 Source Code #include \"precompilerdefinitions\" program phonon_dispersion_relations !!{!src/phonon_dispersion_relations/manual.md!} use constants use helpers use dump_data use options use geometryfunctions use type_crystalstructure use type_forceconstant_secondorder use type_forceconstant_thirdorder use type_qpointmesh use type_phonon_dispersions use type_phonon_dos use type_phonon_bandstructure use type_lotosplitting use type_symmetryoperation use type_symmetrytable use type_sqs ! local use densityplots use velocitydos ! implicit none ! for normal phonon things type ( lo_opts ) :: opts type ( lo_forceconstant_secondorder ) :: fc type ( lo_forceconstant_thirdorder ) :: fct type ( lo_crystalstructure ) :: uc type ( lo_loto ) :: loto type ( lo_phonon_bandstructure ) :: bs class ( lo_qpoint_mesh ), allocatable :: qp type ( lo_phonon_dispersions ) :: dr type ( lo_phonon_dos ) :: pd ! for phonon dos of alloys !type(lo_symcell) :: sy !type(lo_forceconstant_secondorder) :: fcalloy !type(lo_sqs) :: sqs real ( flyt ), dimension ( 3 ) :: v1 real ( flyt ) :: f0 , f1 , f2 , f3 , f4 , t0 , tstart real ( flyt ), dimension (:), allocatable :: dum , temperatures integer :: i , j , k , l , u character ( len = 1000 ) :: opf ! Get the command line arguments tstart = walltime () call opts % parse () ! Read the crystal structure call uc % readfromfile ( 'infile.ucposcar' , verbosity = opts % verbosity ) ! Maybe non-default isotope distribution if ( opts % readiso ) then write ( * , * ) '... reading isotope distribution from file' call uc % readisotopefromfile () endif ! Read the force constant call fc % readfromfile ( uc ) ! Perhaps some LO-TO splitting if ( opts % loto ) then call loto % setoptions ( uc , fc , opts % lotocorrectiontype , opts % verbosity ) else call loto % initempty () endif ! Perhaps some Gruneisen parameters, in that case we need third order force constants. if ( opts % gruneisen ) then call fct % readfromfile ( uc , verbosity = opts % verbosity ) endif ! Get the dispersions on the path t0 = walltime () if ( opts % gruneisen ) then call bs % generate ( uc , fc , loto , fct = fct , verbosity = opts % verbosity , npts = opts % nq , readpathfromfile = opts % readpathfromfile ) else call bs % generate ( uc , fc , loto , verbosity = opts % verbosity , npts = opts % nq , readpathfromfile = opts % readpathfromfile , correctionlevel = 0 ) endif ! Write a small summary write ( * , * ) ' ' write ( * , * ) ' Settings: ' write ( * , * ) '            add LO-TO splitting: ' , opts % loto write ( * , * ) '      mode Gruneisen parameters: ' , opts % gruneisen write ( * , * ) '                number of bands: ' // trim ( int2char ( bs % nb )) write ( * , * ) '                number of paths: ' // trim ( int2char ( bs % npath )) write ( * , * ) '  number of points on each path: ' // trim ( int2char ( bs % npts )) write ( * , * ) ' ' do i = 1 , bs % npath write ( * , * ) '        path ' // trim ( int2char ( i )) // ': from ' // trim ( bs % symb_q_start ( i )) // ' to ' // trim ( bs % symb_q_end ( i )) opf = \"(1X,'  starting point: cartesian',3(F9.6,' '),'fractional',3(F9.6,' '))\" v1 = uc % cartesian_to_fractional ( bs % segment ( i )% r1 , reciprocal = . true ., pbc = . false .) write ( * , opf ) bs % segment ( i )% r1 , v1 opf = \"(1X,'    ending point: cartesian',3(F9.6,' '),'fractional',3(F9.6,' '))\" v1 = uc % cartesian_to_fractional ( bs % segment ( i )% r2 , reciprocal = . true ., pbc = . false .) write ( * , opf ) bs % segment ( i )% r2 , v1 enddo write ( * , * ) ' ' write ( * , \"(' ...            got the phonon bandstructure in ',F12.9,'s' )\" ) real ( walltime () - t0 ) ! Dump things to files for plotting call bs % write_dispersive_property ( opts % enhet , 'frequency' , 'outfile.dispersion_relations' ,. false .) call bs % write_dispersive_property ( opts % enhet , 'groupvelocity' , 'outfile.group_velocities' ,. false .) if ( opts % gruneisen ) call bs % write_dispersive_property ( opts % enhet , 'gruneisen' , 'outfile.mode_gruneisen_parameters' ,. false .) ! The dispersions along the path are done. Perhaps we want the full dispersion relations for something? if ( opts % fullmesh ) then write ( * , * ) ' ' write ( * , * ) ' Calculating phonon dispersion across the Brillouin zone' ! Get a q-point mesh if ( opts % readqmesh ) then write ( * , * ) '... getting q-mesh from file' call lo_read_qmesh_from_file ( qp , uc , 'infile.qgrid.hdf5' ) else write ( * , * ) '... generating q-mesh' select case ( opts % meshtype ) case ( 1 ) call lo_generate_qmesh ( qp , uc , opts % qgrid , 'monkhorst' , verbosity = opts % verbosity , timereversal = opts % timereversal ) case ( 2 ) call lo_generate_qmesh ( qp , uc , opts % qgrid , 'fft' , verbosity = opts % verbosity , timereversal = opts % timereversal ) case ( 3 ) call lo_generate_qmesh ( qp , uc , opts % qgrid , 'wedge' , verbosity = opts % verbosity ) end select endif ! Get the full dispersion relations t0 = walltime () call dr % generate ( qp , fc , uc , loto , verbosity = opts % verbosity ) endif ! Perhaps we want the phonon density of states and related things if ( opts % dos ) then t0 = walltime () if ( opts % alloydos ) then ! for alloys, have to do some special special thingy. But it is old and stupid, so just no. !call pd%generate_alloydos(uc,fc,dr%omega_max*1.6_flyt,opts%qgrid,opts%alloyssdim) else ! the normal way, for normal stuff call pd % generate ( dr , qp , uc , verbosity = max ( 1 , opts % verbosity ), dosprojection = opts % siteprojecteddos ,& integrationtype = opts % dosintegrationtype , adaptiveparameter = opts % sigma , ndos = opts % dospoints ) endif ! Dump it to file call pd % write_to_file ( uc , opts % enhet ,. false ., modeproj = opts % modeprojecteddos ) endif ! A positive number of temperatures means I should dump energy if ( opts % trangenpts . gt . 0 ) then if ( . not . opts % fullmesh ) then write ( * , * ) 'I screwed up the heuristics' stop endif write ( * , * ) '... calculating free energy' lo_allocate ( temperatures ( opts % trangenpts )) call lo_linspace ( opts % trangemin , opts % trangemax , temperatures ) ! dump some free energies and entropies u = open_file ( 'out' , 'outfile.free_energy' ) do i = 1 , opts % trangenpts f0 = temperatures ( i ) f1 = dr % phonon_free_energy ( f0 ) f2 = dr % phonon_entropy ( f0 ) f3 = dr % phonon_cv ( f0 ) f4 = dr % phonon_free_energy_classical ( f0 ) if ( abs ( f1 - 12345678 9.0_flyt ) . lt . lo_tol ) then ! return NaN if I have imaginary frequencies write ( u , * ) f0 , ' NaN  NaN  NaN  NaN' else write ( u , \"(5(1X,E18.11))\" ) temperatures ( i ), f1 , f2 , f3 , f4 endif enddo close ( u ) ! If the modevib option is specified, write the contribution of each phonon branch ! to the total vibrational entropy for each temperature if ( opts % modevib ) then u = open_file ( 'out' , 'outfile.mode_vibentropies' ) opf = \"(\" // trim ( int2char ( dr % nb )) // \"(1X,E18.12))\" lo_allocate ( dum ( dr % nb )) do i = 1 , opts % trangenpts do j = 1 , dr % nb dum ( j ) = dr % phonon_entropy ( temperatures ( i ), modenum = j ) enddo write ( u , opf ) dum enddo lo_deallocate ( dum ) close ( u ) endif ! If the sitevib option is specified, write the contribution of each unit cells site ! to the total vibrational entropy for each temperature if ( opts % sitevib ) then u = open_file ( 'out' , 'outfile.site_vibentropies' ) opf = \"(\" // trim ( int2char ( uc % na )) // \"(1X,E18.12))\" lo_allocate ( dum ( uc % na )) do i = 1 , opts % trangenpts do j = 1 , uc % na dum ( j ) = dr % phonon_entropy ( temperatures ( i ), sitenum = j ) enddo write ( u , opf ) dum enddo lo_deallocate ( dum ) close ( u ) endif endif ! Calculate and dump the velocity density of states! ! Actually no, it's not that exciting. Kind of a stupid idea to begin with. !call dump_velocity_dos(uc,dr,qp,opts%temperature) ! Write everything on the grid to file, for some inexplicable reason. if ( opts % dumpgrid ) then ! small sanity check if ( . not . opts % fullmesh ) then write ( * , * ) 'I screwed up the heuristics' stop endif if ( opts % gruneisen ) then call dr % gruneisen ( qp , fct , uc , opts % verbosity ) endif ! actually write it call dr % write_to_hdf5 ( qp , 'outfile.grid_dispersions.hdf5' ) write ( * , * ) '... wrote data for the full grid' endif ! Maybe create some stunt ARCS data. But no, noone cares about this. So no. !if ( opts%stuntarcs ) then !    write(*,*) '' !    write(*,*) 'Calculating stunt ARCS data' !    call generate_theoretical_density_plot(bs,uc,fc,opts,loto) !endif write ( * , * ) ' ' write ( * , \"('  All done! It took',F12.3,'s' )\" ) walltime () - tstart end program","tags":"","loc":"sourcefile/main.f90~4.html","title":"main.f90 – TDEP"},{"text":"Programs atomic_distribution Source Code main.f90 Source Code #include \"precompilerdefinitions\" program atomic_distribution !!{!src/atomic_distribution/manual.md!} use constants use type_crystalstructure use type_mdsim use type_symmetrytable use type_symmetryoperation use helpers use dump_data use options ! use pairmapping use vectordist use pair_distribution use mean_square_displacement use timedistance_correlation use correlationfunction implicit none ! type ( lo_opts ) :: opts type ( lo_crystalstructure ) :: uc , ss type ( lo_mdsim ) :: sim type ( lo_symcell ) :: sy type ( lo_vectordist ) :: vd type ( lo_pairmapping ) :: pm type ( lo_pair_distribution ) :: pdf type ( lo_mean_square_displacement ) :: msd type ( lo_timedistance_correlation ) :: tdc type ( lo_correlationfunction ) :: cf real ( flyt ), dimension ( 3 ) :: v real ( flyt ) :: f0 integer :: i , j , k , l , u , a1 , sh integer :: nhist character ( len = 1000 ) :: fn ! get command line arguments call opts % parse () ! read positions call uc % readfromfile ( 'infile.ucposcar' ) write ( * , * ) '... read unitcell' call ss % readfromfile ( 'infile.ssposcar' ) write ( * , * ) '... read supercell' ! Get all kinds of symmetry stuff if ( opts % cutoff . lt . 0.0_flyt ) then opts % cutoff = ss % maxcutoff () endif call sy % generate ( uc , ss , opts % cutoff , - 1.0_flyt , - 1.0_flyt ,& testscalar = . false ., testvector = . false .,& testmatrix = . false ., verbosity = 0 , transpositions = . false .,& firstorder = . false .) write ( * , * ) '... found ' // trim ( int2char ( sy % nun )) // ' unique atoms' do i = 1 , sy % nun write ( * , * ) '    atom ' , i , uc % atomic_symbol ( uc % species ( sy % un ( i )% atom_in_uc ) ) enddo ! I know the number of unique atoms, and coordination shells. I need a reverse list, sort of. ! I need to know for each atom in the unit cell, and for each pair, which atoms to sum over ! and how they should transform call pm % setup_symmetry ( sy , uc , ss ) ! Also need the actual simulation call sim % read_from_file ( verbosity = 2 , stride = opts % stride ) ! First we calculate the symmetry-projected radial pair distribution function call pdf % bin ( uc , ss , pm , sim , opts % nbin ) ! Write this to file call pdf % write_to_hdf5 () write ( * , * ) 'Wrote pair distribution function to file' ! Then we calculate the mean square displacement, could be useful call msd % generate ( uc , ss , pm , sim ) call msd % write_to_hdf5 () call msd % write_to_plaintext ( pm , uc ) write ( * , * ) 'Wrote mean square displacement to file' ! Additionally, I like the time-distance correlation functions. Not exactly sure what they ! are good for, but it's interesting to look at. Only in the non-diffusive case for now. if ( opts % timedistance ) then if ( pdf % diffusion . eqv . . false . ) then call tdc % generate ( pdf , uc , ss , pm , sim , opts % nbin ) call tdc % write_to_hdf5 () endif endif ! generate the vector distribution (only in case of no diffusion, this makes little sense if things are melted) if ( pdf % diffusion . eqv . . false . ) then call vd % generate ( pm , uc , ss , sim , opts % bintype , opts % transform , opts % nbin ) call vd % write_to_hdf5 ( pm ) endif ! This works, except for units, and no manual written. Stupid manual. ! So I decided to comment it instead of writing the manual. ! realspace velocity-velocity autocorrelation functions ! call cf%generate(uc,ss,pm,sim) ! call cf%write_to_plaintext(pm,uc) write ( * , * ) 'All done!' end program","tags":"","loc":"sourcefile/main.f90~5.html","title":"main.f90 – TDEP"},{"text":"Programs thermal_conductivity Source Code main.f90 Source Code #include \"precompilerdefinitions\" program thermal_conductivity !!{!src/thermal_conductivity/manual.md!} use constants use type_crystalstructure use type_mdsim use type_forceconstant_secondorder use type_forceconstant_thirdorder use type_symmetryoperation use type_qpointmesh use type_phonon_dispersions use type_phonon_dos use type_lotosplitting use type_phononscatteringevents use helpers use dump_data ! unique use options use scatteringstrengths use pbe use type_lompi use phononevents use mfp implicit none ! Standard, from libolle type ( lo_opts ) :: opts type ( lo_forceconstant_secondorder ) :: fc type ( lo_forceconstant_thirdorder ) :: fct type ( lo_phonon_dispersions ) :: dr type ( lo_crystalstructure ) :: uc type ( lo_loto ) :: loto type ( lo_fft_mesh ) :: qp ! Unique type ( lo_threephononevents ) :: sc type ( lo_mpiinfo ) :: mw type ( lo_tcmpi ) :: tcmpi type ( lo_mfp ) :: mf ! Small stuff real ( flyt ), dimension ( 3 , 3 ) :: kappa , kappaf real ( flyt ), dimension (:,:), allocatable :: thermal_cond real ( flyt ), dimension (:,:), allocatable :: thermal_cond_fancy real ( flyt ), dimension (:,:), allocatable :: dx , dy , ddy real ( flyt ), dimension (:), allocatable :: temperatures , dum real ( flyt ) :: t0 , f0 , f1 , f2 , f3 , tt0 integer :: i , j , k , l , u , ii , pp character ( len = 90 ) :: opf ! timers real ( flyt ) :: timer_init , timer_count , timer_matrixelements , timer_scf real ( flyt ) :: timer_kappa , timer_qs , timer_comm , timer_fancykappa ! Start MPI and timers call lo_init_mpi_world ( mw ) tt0 = mpi_wtime () timer_init = mpi_wtime () ! Get options call opts % parse () ! There is a bunch of stuff that all ranks need, first the unit cell: call uc % readfromfile ( 'infile.ucposcar' ) call uc % classify ( 'wedge' ) if ( mw % r . eq . 0 ) write ( * , * ) '... read unitcell poscar' ! Perhaps non-natural isotope distribution if ( opts % readiso ) then if ( mw % r . eq . 0 ) write ( * , * ) '... reading isotope distribution from file' call uc % readisotopefromfile () ! Only print it if actually specified if ( mw % r . eq . 0 ) then do i = 1 , uc % na do j = 1 , uc % isotope ( i )% n write ( * , \"('    isotope: ',I2,' concentration: ',F8.5,' mass: ',F12.6)\" ) & j , uc % isotope ( i )% conc ( j ), uc % isotope ( i )% mass ( j ) enddo write ( * , \"('    element: ',A2,' mean mass: ',F12.6,' mass disorder parameter',F12.9)\" ) & trim ( uc % atomic_symbol ( uc % species ( i ) )), uc % isotope ( i )% mean_mass ,& uc % isotope ( i )% disorderparameter enddo endif endif ! Read the force constants call fc % readfromfile ( uc ) if ( mw % r . eq . 0 ) write ( * , * ) '... read second order forceconstant' call fct % readfromfile ( uc ) if ( mw % r . eq . 0 ) write ( * , * ) '... read third order forceconstant' ! Get q-point mesh call qp % generate ( uc , opts % qgrid , timereversal = opts % timereversal ) if ( mw % r . eq . 0 ) write ( * , * ) '... found ' // trim ( int2char ( qp % nq_irr )) // ' irreducible points out of ' // trim ( int2char ( qp % nq_tot )) ! Get frequencies in the whole BZ t0 = mpi_wtime () if ( mw % r . eq . 0 ) then write ( * , * ) '... getting the full dispersion relations' write ( * , * ) '... correction level' , opts % correctionlevel endif if ( opts % loto ) then call loto % setoptions ( uc , fc , opts % lotocorrectiontype ) else call loto % initempty () endif call dr % generate ( qp , fc , uc , loto , correctionlevel = 2 ) if ( mw % r . eq . 0 ) write ( * , * ) '... got the full dispersion relations' , mpi_wtime () - t0 ! Make sure that everyone is done: call mpi_barrier ( mw % comm , mw % error ) ! Now we need to divide the q-points among the ranks: allocate ( tcmpi % qpoint_map ( qp % nq_irr )) allocate ( tcmpi % qpoint_counter ( mw % n )) allocate ( tcmpi % rankinfo ( mw % n )) tcmpi % qpoint_counter = 0 k = 0 do j = 1 , qp % nq_irr do i = 1 , mw % n k = k + 1 if ( k . gt . qp % nq_irr ) exit tcmpi % qpoint_map ( k ) = i tcmpi % qpoint_counter ( i ) = tcmpi % qpoint_counter ( i ) + 1 enddo enddo tcmpi % nq = tcmpi % qpoint_counter ( mw % r + 1 ) lo_allocate ( tcmpi % qpoints ( tcmpi % nq )) ! Figure out which rank gets which q-point do i = 1 , mw % n lo_allocate ( tcmpi % rankinfo ( i )% qpoint ( tcmpi % qpoint_counter ( i ) )) enddo tcmpi % qpoint_counter = 0 k = 0 do j = 1 , qp % nq_irr do i = 1 , mw % n k = k + 1 if ( k . gt . qp % nq_irr ) exit tcmpi % qpoint_counter ( i ) = tcmpi % qpoint_counter ( i ) + 1 tcmpi % rankinfo ( i )% qpoint ( tcmpi % qpoint_counter ( i ) ) = k enddo enddo ! Store the ones for this rank tcmpi % qpoints = tcmpi % rankinfo ( mw % r + 1 )% qpoint call mpi_barrier ( mw % comm , mw % error ) ! Divide the tetrahedrons as well lo_allocate ( tcmpi % tetrahedron_map ( qp % ntet )) lo_allocate ( tcmpi % tetrahedron_counter ( mw % n )) tcmpi % tetrahedron_counter = 0 k = 0 do j = 1 , qp % ntet do i = 1 , mw % n k = k + 1 if ( k . gt . qp % ntet ) exit tcmpi % tetrahedron_map ( k ) = i tcmpi % tetrahedron_counter ( i ) = tcmpi % tetrahedron_counter ( i ) + 1 enddo enddo tcmpi % ntet = tcmpi % tetrahedron_counter ( mw % r + 1 ) lo_allocate ( tcmpi % tetrahedrons ( tcmpi % ntet )) ! Figure out which rank gets which tetrahedron do i = 1 , mw % n lo_allocate ( tcmpi % rankinfo ( i )% tetrahedron ( tcmpi % tetrahedron_counter ( i ) )) enddo tcmpi % tetrahedron_counter = 0 k = 0 do j = 1 , qp % ntet do i = 1 , mw % n k = k + 1 if ( k . gt . qp % ntet ) exit tcmpi % tetrahedron_counter ( i ) = tcmpi % tetrahedron_counter ( i ) + 1 tcmpi % rankinfo ( i )% tetrahedron ( tcmpi % tetrahedron_counter ( i ) ) = k enddo enddo tcmpi % tetrahedrons = tcmpi % rankinfo ( mw % r + 1 )% tetrahedron ! Print some things to see that the q-points are distributed correct !if ( mw%r .eq. 0 ) then !    write(*,*) ' ' !    do i=1,mw%n !        write(*,*) 'rank',i,'nq',tcmpi%qpoint_counter(i) !        do j=1,tcmpi%qpoint_counter(i) !            write(*,*) 'qpoint',j,'global',tcmpi%rankinfo(i)%qpoint(j) !        enddo !    enddo !endif if ( mw % r . eq . 0 ) write ( * , * ) '... initialization done.' ! stop init timer, start counting timer timer_init = mpi_wtime () - timer_init timer_count = mpi_wtime () ! Count scattering events t0 = mpi_wtime () sc % sigma = opts % sigma * dr % default_smearing () sc % thres = opts % thres sc % adaptiveparameter = opts % sigma sc % integrationtype = opts % integrationtype sc % isotopescattering = . true . sc % taubs = opts % tau_boundary sc % mfpmax = opts % mfp_max sc % correctionlevel = opts % correctionlevel call lo_find_all_scattering_events ( qp , dr , sc , mw , tcmpi ) call mpi_barrier ( mw % comm , mw % error ) if ( mw % r . eq . 0 ) write ( * , * ) 'Counted' , mpi_wtime () - t0 ! stop counting timer, start matrixelement timer timer_count = mpi_wtime () - timer_count timer_matrixelements = mpi_wtime () ! Calculate scattering amplitudes t0 = mpi_wtime () call calculate_scattering_amplitudes_mpi ( uc , qp , sc , dr , fct , mw , tcmpi ) call mpi_barrier ( mw % comm , mw % error ) if ( mw % r . eq . 0 ) write ( * , * ) 'Scattering amplitudes' , mpi_wtime () - t0 ! stop matrix element timer, start some other timer timer_matrixelements = mpi_wtime () - timer_matrixelements ! Get thermal conductivity allocate ( thermal_cond ( 10 , opts % trangenpts )) allocate ( thermal_cond_fancy ( 10 , opts % trangenpts )) thermal_cond = 0.0_flyt thermal_cond_fancy = 0.0_flyt if ( mw % r . eq . 0 ) write ( * , * ) ' ' if ( mw % r . eq . 0 ) write ( * , * ) 'THERMAL CONDUCTIVITY ' , opts % trangenpts ! Reset the rest of the timers timer_qs = 0.0_flyt timer_comm = 0.0_flyt timer_kappa = 0.0_flyt timer_fancykappa = 0.0_flyt timer_scf = 0.0_flyt ! The temperature axis allocate ( temperatures ( opts % trangenpts )) if ( opts % logtempaxis ) then call lo_logspace ( opts % trangemin , opts % trangemax , temperatures ) else call lo_linspace ( opts % trangemin , opts % trangemax , temperatures ) endif ! Setup the mean-free-path vs kappa plots, as well as the thin-film plots if ( mw % r . eq . 0 ) then ! how many points on the x-axis? mf % np = opts % mfppts ! how many temperature? mf % nt = opts % trangenpts ! one plot for each temperature allocate ( mf % temp ( mf % nt )) ! thin film conductivity if ( opts % thinfilm ) then allocate ( mf % film ( mf % nt )) endif endif ! Main loop over temperatures to solve the BTE do i = 1 , opts % trangenpts if ( mw % r . eq . 0 ) write ( * , * ) '' ! I might get a silly tiny temperature: if ( temperatures ( i ) . lt . lo_temperaturetol ) then kappaf = 0.0_flyt kappa = 0.0_flyt cycle endif ! Scattering rates t0 = mpi_wtime () call calculate_qs_mpi ( qp , sc , dr , temperatures ( i ), tcmpi ) call get_F0 ( dr , temperatures ( i ), tcmpi ) timer_qs = timer_qs + mpi_wtime () - t0 ! Distribute t0 = mpi_wtime () call lo_mpi_allgather_disprel ( dr , tcmpi , mw ) timer_comm = timer_comm + mpi_wtime () - t0 ! Get RTA kappa t0 = mpi_wtime () call get_kappa ( dr , qp , temperatures ( i ), kappa , uc ) ! call get_quad_kappa(dr,qp,temperature,kappaf,uc) timer_kappa = timer_kappa + mpi_wtime () - t0 ! Get selfconsistent kappa call mpi_barrier ( mw % comm , mw % error ) if ( opts % scfiterations . gt . 1 ) then f0 = lo_huge f1 = lo_huge f2 = lo_huge f3 = lo_huge do j = 1 , opts % scfiterations ! if ( mw % r . eq . 0 ) write ( * , * ) temperatures ( i ), real ( kappa ( 1 , 1 )), real ( kappa ( 2 , 2 )), real ( kappa ( 3 , 3 )) ! SCF iteration t0 = mpi_wtime () call get_selfconsistent_solution ( sc , dr , qp , uc , tcmpi ) timer_scf = timer_scf + mpi_wtime () - t0 ! Communicate t0 = mpi_wtime () call lo_mpi_allgather_disprel ( dr , tcmpi , mw ) timer_comm = timer_comm + mpi_wtime () - t0 ! Calculate kappa t0 = mpi_wtime () call mpi_barrier ( mw % comm , mw % error ) call get_kappa ( dr , qp , temperatures ( i ), kappa , uc ) timer_kappa = timer_kappa + mpi_wtime () - t0 ! Check for convergence. I set the threshold to an arbitrary 0.01 of ! the absolute value. Probably good enough. f0 = abs ( f1 - kappa ( 1 , 1 )) / kappa ( 1 , 1 ) f3 = abs ( f2 - kappa ( 1 , 1 )) / kappa ( 1 , 1 ) if ( abs ( f3 ) . gt . lo_tol * 10 0.0_flyt . and . abs ( f0 ) . gt . lo_tol * 10 0.0_flyt ) then f2 = f1 ! store previous f1 = kappa ( 1 , 1 ) ! store current else exit endif enddo endif ! thermal_cond ( 1 , i ) = temperatures ( i ) thermal_cond ( 2 , i ) = kappa ( 1 , 1 ) thermal_cond ( 3 , i ) = kappa ( 2 , 2 ) thermal_cond ( 4 , i ) = kappa ( 3 , 3 ) thermal_cond ( 5 , i ) = kappa ( 1 , 3 ) thermal_cond ( 6 , i ) = kappa ( 2 , 3 ) thermal_cond ( 7 , i ) = kappa ( 1 , 2 ) thermal_cond ( 8 , i ) = kappa ( 3 , 1 ) thermal_cond ( 9 , i ) = kappa ( 3 , 2 ) thermal_cond ( 10 , i ) = kappa ( 2 , 1 ) if ( mw % r . eq . 0 ) write ( * , * ) temperatures ( i ), real ( kappa ( 1 , 1 )), real ( kappa ( 2 , 2 )), real ( kappa ( 3 , 3 )) call mpi_barrier ( mw % comm , mw % error ) !    thermal_cond_fancy(1,i)=temperature !    thermal_cond_fancy(2,i)=kappaf(1,1) !    thermal_cond_fancy(3,i)=kappaf(2,2) !    thermal_cond_fancy(4,i)=kappaf(3,3) !    thermal_cond_fancy(5,i)=kappaf(1,3) !    thermal_cond_fancy(6,i)=kappaf(2,3) !    thermal_cond_fancy(7,i)=kappaf(1,2) !    thermal_cond_fancy(8,i)=kappaf(3,1) !    thermal_cond_fancy(9,i)=kappaf(3,2) !    thermal_cond_fancy(10,i)=kappaf(2,1) ! Get the mean free path plot thingy if ( mw % r . eq . 0 ) then call calculate_mean_free_path ( mf % temp ( i ), qp , dr , mf % np , temperatures ( i )) endif ! And the thin film thing if ( mw % r . eq . 0 . and . opts % thinfilm ) then call calculate_thinfilm_kappa ( mf % film ( i ), qp , dr , mf % np , uc , temperatures ( i ),[ 0.0_flyt , 0.0_flyt , 1.0_flyt ],[ 0.0_flyt , 1.0_flyt , 0.0_flyt ]) endif enddo ! Write thermal conductivity to file if ( mw % r . eq . 0 ) call lo_dump_gnuplot_2d_real ( thermal_cond , 'outfile.thermal_conductivity' , ylabel = '\\kappa W/mK' , xlabel = 'Temperature (K)' ) !if ( mw%r .eq. 0 ) call lo_dump_gnuplot_2d_real(thermal_cond_fancy,'outfile.thermal_conductivity_fancy',ylabel='\\kappa W/mK',xlabel='Temperature (K)') ! Write the cumulative kappa if ( mw % r . eq . 0 ) call write_cumulative_plots ( mf ) ! Maybe dump data on a grid if ( mw % r . eq . 0 . and . opts % dumpgrid . and . opts % trangenpts . eq . 1 ) then write ( * , * ) '... dumping auxiliary data to files:' call dr % write_to_hdf5 ( qp , 'outfile.grid_thermal_conductivity.hdf5' , temperatures ( 1 )) endif ! sum up the total time if ( mw % r . eq . 0 ) then tt0 = mpi_wtime () - tt0 endif ! Print timings if ( mw % r . eq . 0 ) then t0 = timer_init + timer_count + timer_matrixelements + timer_qs + timer_comm + timer_kappa + timer_scf write ( * , * ) ' ' write ( * , * ) 'Timings:' write ( * , \"(A,F12.3,A,F7.3,A)\" ) '            initialization:' , timer_init , ' seconds, ' , real ( timer_init * 100 / tt0 ), '%' write ( * , \"(A,F12.3,A,F7.3,A)\" ) '       integration weights:' , timer_count , ' seconds, ' , real ( timer_count * 100 / tt0 ), '%' write ( * , \"(A,F12.3,A,F7.3,A)\" ) '           matrix elements:' , timer_matrixelements , ' seconds, ' , real ( timer_matrixelements * 100 / tt0 ), '%' write ( * , \"(A,F12.3,A,F7.3,A)\" ) '            QS calculation:' , timer_qs , ' seconds, ' , real ( timer_qs * 100 / tt0 ), '%' write ( * , \"(A,F12.3,A,F7.3,A)\" ) '             communication:' , timer_comm , ' seconds, ' , real ( timer_comm * 100 / tt0 ), '%' write ( * , \"(A,F12.3,A,F7.3,A)\" ) '                     kappa:' , timer_kappa , ' seconds, ' , real ( timer_kappa * 100 / tt0 ), '%' write ( * , \"(A,F12.3,A,F7.3,A)\" ) '          self consistency:' , timer_scf , ' seconds, ' , real ( timer_scf * 100 / tt0 ), '%' write ( * , \"(A,F12.3,A)\" ) '                     total:' , tt0 , ' seconds' endif call mpi_barrier ( mw % comm , mw % error ) call mpi_finalize ( i ) end program","tags":"","loc":"sourcefile/main.f90~6.html","title":"main.f90 – TDEP"},{"text":"Programs samples_from_md Source Code main.f90 Source Code #include \"precompilerdefinitions\" program samples_from_md !!{!src/samples_from_md/manual.md!} use constants use type_crystalstructure use type_mdsim use helpers use dump_data use options implicit none type ( lo_opts ) :: opts type ( lo_mdsim ) :: sim type ( lo_crystalstructure ) :: p integer , dimension (:), allocatable :: sample , indices , testsample integer :: i , j , k , ii , jj , mindist , u real ( flyt ) :: f0 , f1 , f2 , rndf , t0 , t1 real ( flyt ) :: mean_ep , mean_ek , sigma_ep , sigma_ek real ( flyt ) :: mp0 , mp1 , mk0 , mk1 , sp0 , sp1 , sk0 , sk1 character ( len = 80 ) :: fname ! Get options call opts % parse () ! Seed random numbers call lo_seed_random_numbers () ! Get simulation call sim % read_from_file () ! List of all the samples allocate ( indices ( sim % nt )) do i = 1 , sim % nt indices ( i ) = i enddo ! Get a first sample allocate ( sample ( opts % n )) allocate ( testsample ( opts % n )) call random_number ( f0 ) sample ( 1 ) = floor ( f0 * sim % nt ) + 1 ! Get the minimum distance between two samples mindist = sim % nt / opts % n / 5 write ( * , * ) 'minimum distance' , mindist ! Choose the rest do i = 2 , opts % n j = select_ok_random_sample ( indices , sample ( 1 : i - 1 ), mindist ) sample ( i ) = j enddo ! Values for the entire simulation mean_ep = lo_mean ( sim % stat % ep ) mean_ek = lo_mean ( sim % stat % ek ) sigma_ep = lo_stddev ( sim % stat % ep ) sigma_ek = lo_stddev ( sim % stat % ek ) ! Starting values for monte-carlo run mp0 = lo_mean ( sim % stat % ep ( sample )) mk0 = lo_mean ( sim % stat % ek ( sample )) sp0 = lo_stddev ( sim % stat % ep ( sample )) sk0 = lo_stddev ( sim % stat % ek ( sample )) mp0 = abs ( mp0 - mean_ep ) mk0 = abs ( mk0 - mean_ek ) sp0 = abs ( sp0 - sigma_ep ) sk0 = abs ( sk0 - sigma_ek ) t0 = mp0 + mk0 + sp0 + sk0 write ( * , * ) 'Starting Monte-Carlo, distances:' write ( * , \"(9X,4(1X,A18))\" ) '|<Ep>-<Ep0>|' , '|<Ek>-<Ek0>|' , '|S(Ep)-S(Ep0)|' , '|S(Ek)-S(Ek0)|' write ( * , \"(1X,I8,4(1X,F18.6))\" ) 0 , mp0 , mk0 , sp0 , sk0 do i = 1 , opts % maxiter ! try a new configuration testsample = sample ! CHANGE PLACES k = lo_random_int ( opts % n ) j = select_ok_random_sample ( indices , sample , mindist ) testsample ( k ) = j ! Measure distances mp1 = lo_mean ( sim % stat % ep ( testsample )) mk1 = lo_mean ( sim % stat % ek ( testsample )) sp1 = lo_stddev ( sim % stat % ep ( testsample )) sk1 = lo_stddev ( sim % stat % ek ( testsample )) mp1 = abs ( mp1 - mean_ep ) mk1 = abs ( mk1 - mean_ek ) sp1 = abs ( sp1 - sigma_ep ) sk1 = abs ( sk1 - sigma_ek ) t1 = mp1 + mk1 + sp1 + sk1 ! MC check call random_number ( f2 ) if ( exp ( - ( t1 - t0 ) / opts % temp ) . gt . f2 ) then sample = testsample mp0 = mp1 mk0 = mk1 sp0 = sp1 sk0 = sk1 t0 = t1 write ( * , \"(1X,I8,4(1X,F18.6))\" ) i , mp0 , mk0 , sp0 , sk0 if ( t0 . lt . lo_tol ) exit endif enddo write ( * , * ) ' ' write ( * , * ) ' Results of Monte-Carlo run ' write ( * , \"('                 ',4(1X,A18))\" ) '<Ep>' , '<Ek>' , 'Sigma(Ep)' , 'Sigma(Ek)' write ( * , \"('Full simulation:',4(1X,F18.6))\" ) & lo_mean ( sim % stat % ep ), lo_mean ( sim % stat % ek ), lo_stddev ( sim % stat % ep ), lo_stddev ( sim % stat % ek ) write ( * , \"('        Samples:',4(1X,F18.6))\" ) & lo_mean ( sim % stat % ep ( sample )), lo_mean ( sim % stat % ek ( sample )), lo_stddev ( sim % stat % ep ( sample )), lo_stddev ( sim % stat % ek ( sample )) ! Find the minimum, maximum and mean distance between two samples ii = 0 jj = 1000000000 f0 = 0.0_flyt do i = 1 , opts % n f1 = lo_huge do j = 1 , opts % n if ( i . ne . j ) then jj = min ( abs (( sample ( i ) - sample ( j ))), jj ) f1 = min ( abs (( sample ( i ) - sample ( j )) * 1.0_flyt ), f1 ) endif enddo ii = max ( floor ( f1 ), ii ) f0 = f0 + f1 enddo f0 = f0 / opts % n write ( * , * ) '  Max distance:' , ii write ( * , * ) '  Min distance:' , jj write ( * , * ) ' Mean distance:' , int ( f0 ) ! write the samples p = sim % crystalstructure call lo_shuffle_int_array ( sample ) do i = 1 , opts % n p % r = sim % r (:,:, sample ( i )) p % v = sim % v (:,:, sample ( i )) p % info % title = 'sample ' // trim ( int2char_padded ( sample ( i ), 7 )) fname = 'sample' // trim ( int2char_padded ( i , 5 )) call p % writetofile ( fname ,. true .) enddo ! and the energies and stuff of the samples u = open_file ( 'out' , 'outfile.stat_sample' ) do j = 1 , opts % n i = sample ( j ) write ( u , \"(I6,' ',13(2X,EN16.7))\" ) & i , i * sim % ts , sim % stat % et ( i ), sim % stat % ep ( i ), sim % stat % ek ( i ), sim % stat % t ( i ), sim % stat % p ( i ), sim % stat % stress (:, i ) enddo close ( u ) contains !> choose a sample, but not too stupidly integer function select_ok_random_sample ( indices , forbidden , mindist ) integer , dimension (:), intent ( in ) :: indices , forbidden integer , intent ( in ) :: mindist ! integer :: i , ii , j , l , nt , nf real ( flyt ) :: f0 nf = size ( forbidden , 1 ) nt = size ( indices , 1 ) do ii = 1 , 100 i = lo_random_int ( nt ) l = 0 do j = 1 , nf if ( abs ( indices ( i ) - indices ( forbidden ( j ))) . le . mindist ) l = l + 1 enddo if ( l . eq . 0 ) exit enddo select_ok_random_sample = i end function end program","tags":"","loc":"sourcefile/main.f90~7.html","title":"main.f90 – TDEP"},{"text":"Programs remap_forceconstant Source Code main.f90 Source Code #include \"precompilerdefinitions\" program remap_forceconstant !!{!src/remap_forceconstant/manual.md!} use options use constants use type_crystalstructure use type_forceconstant_secondorder use type_forceconstant_thirdorder use type_forceconstant_fourthorder use helpers implicit none type ( lo_opts ) :: opts type ( lo_crystalstructure ) :: uc , nc type ( lo_forceconstant_secondorder ) :: fc , fcn type ( lo_forceconstant_thirdorder ) :: fct , fctn type ( lo_forceconstant_fourthorder ) :: fcf !,fcfn integer :: i , j , k , l , u , ii real ( flyt ), dimension ( 3 ) :: v0 real ( flyt ), dimension ( 3 , 3 ) :: tm real ( flyt ), dimension (:,:,:), allocatable :: dfc1 , dfc2 ! call opts % parse () ! read files call uc % readfromfile ( 'infile.ucposcar' ) call nc % readfromfile ( 'infile.newposcar' ) write ( * , * ) '... read structures' if ( lo_does_file_exist ( 'infile.forceconstant' ) ) then call fc % readfromfile ( uc ) write ( * , * ) '... read secondorder forceconstant' endif ! if ( lo_does_file_exist ( 'infile.forceconstant_thirdorder' ) ) then call fct % readfromfile ( uc ) write ( * , * ) '... read thirdorder forceconstant' endif ! if ( lo_does_file_exist ( 'infile.forceconstant_fourthorder' ) ) then call fcf % readfromfile ( uc ) write ( * , * ) '... read fourthorder forceconstant' endif ! ! check for a transformation matrix ! if ( lo_does_file_exist ( 'infile.transformation' ) ) then write ( * , * ) 'Trouble: I should fix this' stop u = open_file ( 'in' , 'infile.transformation' ) do i = 1 , 3 read ( u , * ) tm ( i ,:) enddo write ( * , * ) '... read a transformation matrix:' do i = 1 , 3 write ( * , \"(3(2X,F11.8))\" ) tm ( i ,:) enddo ! else ! use the identity transformation tm ( 1 ,:) = [ 1.0_flyt , 0.0_flyt , 0.0_flyt ] tm ( 2 ,:) = [ 0.0_flyt , 1.0_flyt , 0.0_flyt ] tm ( 3 ,:) = [ 0.0_flyt , 0.0_flyt , 1.0_flyt ] endif ! Transform the original cell tm = transpose ( tm ) uc % latticevectors = matmul ( uc % latticevectors , tm ) uc % inv_latticevectors = uc % latticevectors call lo_invertmatrix_lapack ( uc % inv_latticevectors ) ! need to transpose here, otherwise it does not work tm = transpose ( tm ) ! Transform and remap the forceconstants if ( lo_does_file_exist ( 'infile.forceconstant' ) ) then ! transform do i = 1 , fc % na do j = 1 , fc % atom ( i )% n fc % atom ( i )% pair ( j )% v1 = matmul ( tm , fc % atom ( i )% pair ( j )% v1 ) fc % atom ( i )% pair ( j )% v2 = matmul ( tm , fc % atom ( i )% pair ( j )% v2 ) fc % atom ( i )% pair ( j )% lv1 = matmul ( tm , fc % atom ( i )% pair ( j )% lv1 ) fc % atom ( i )% pair ( j )% lv2 = matmul ( tm , fc % atom ( i )% pair ( j )% lv2 ) fc % atom ( i )% pair ( j )% r = matmul ( tm , fc % atom ( i )% pair ( j )% r ) ! fc % atom ( i )% pair ( j )% m = rotate ( tm , fc % atom ( i )% pair ( j )% m ) enddo enddo ! remap write ( * , * ) 'Remapping, cutoff:' , fc % cutoff call fc % remap ( uc , nc , fcn ) ! print forceconstant file call fcn % writetofile ( nc , 'outfile.forceconstant_remapped' ) write ( * , * ) 'remapped the second order force constants' ! print this in LAMMPS-compliant format. if ( opts % lammps ) then ! print the output in a lammps-friendly way, ! first we write the equilibrium positions: u = open_file ( 'out' , 'outfile.lammps_eqpos' ) do i = 1 , nc % na write ( u , * ) nc % rcart (:, i ) enddo close ( u ) ! second is a list of the forceconstants, only the small cell ones l = 0 do i = 1 , fc % na l = l + fc % atom ( i )% n enddo lo_allocate ( dfc1 ( 3 , 3 , l )) l = 0 do i = 1 , fc % na do j = 1 , fc % atom ( i )% n l = l + 1 dfc1 (:,:, l ) = fc % atom ( i )% pair ( j )% m enddo enddo u = open_file ( 'out' , 'outfile.lammps_pairfc' ) ! number of distinct forceconstants write ( u , * ) l ! all the forceconstants do i = 1 , l do j = 1 , 3 write ( u , * ) dfc1 ( j ,:, i ) enddo enddo close ( u ) ! next print a map of all pairs. u = open_file ( 'out' , 'outfile.lammps_pairmap' ) ! how many atoms, cutoff write ( u , * ) fcn % na , fcn % cutoff ! the number of neighbours for each atom do i = 1 , fcn % na write ( u , * ) i , fcn % atom ( i )% n enddo ! now massive loop over all pairs do i = 1 , fcn % na do j = 1 , fcn % atom ( i )% n ! index to atom 2 k = fcn % atom ( i )% pair ( j )% i2 ! vector to atom 2 v0 = fcn % atom ( i )% pair ( j )% r ! which forceconstant? ii =- 1 do l = 1 , size ( dfc1 , 3 ) if ( lo_frobnorm ( dfc1 (:,:, l ) - fcn % atom ( i )% pair ( j )% m ) . lt . lo_sqtol ) then ii = l exit endif enddo write ( u , \"(4(1X,I5),3(1X,F18.10))\" ) i , j , k , ii , v0 enddo enddo close ( u ) ! get the harmonic stuff call fcn % initialise_cell ( nc , 0.0_flyt ,. true .,. false ., lo_freqtol ) u = open_file ( 'out' , 'outfile.commensurate_mode_frequencies' ) do i = 1 , fcn % na * 3 write ( u , * ) fcn % omega ( i ) enddo close ( u ) endif endif if ( lo_does_file_exist ( 'infile.forceconstant_thirdorder' ) ) then ! transform do i = 1 , fct % na do j = 1 , fct % atom ( i )% n fct % atom ( i )% triplet ( j )% v1 = matmul ( tm , fct % atom ( i )% triplet ( j )% v1 ) fct % atom ( i )% triplet ( j )% v2 = matmul ( tm , fct % atom ( i )% triplet ( j )% v2 ) fct % atom ( i )% triplet ( j )% v3 = matmul ( tm , fct % atom ( i )% triplet ( j )% v3 ) fct % atom ( i )% triplet ( j )% lv1 = matmul ( tm , fct % atom ( i )% triplet ( j )% lv1 ) fct % atom ( i )% triplet ( j )% lv2 = matmul ( tm , fct % atom ( i )% triplet ( j )% lv2 ) fct % atom ( i )% triplet ( j )% lv3 = matmul ( tm , fct % atom ( i )% triplet ( j )% lv3 ) fct % atom ( i )% triplet ( j )% rv1 = matmul ( tm , fct % atom ( i )% triplet ( j )% rv1 ) fct % atom ( i )% triplet ( j )% rv2 = matmul ( tm , fct % atom ( i )% triplet ( j )% rv2 ) fct % atom ( i )% triplet ( j )% rv3 = matmul ( tm , fct % atom ( i )% triplet ( j )% rv3 ) ! fct % atom ( i )% triplet ( j )% m = rotate3 ( tm , fct % atom ( i )% triplet ( j )% m ) enddo enddo ! remap call fct % remap ( uc , nc , fctn ) call fctn % writetofile ( nc , 'outfile.forceconstant_thirdorder_remapped' ) write ( * , * ) 'remapped the third order force constants' endif !if ( lo_does_file_exist('infile.forceconstant_fourthorder') ) then !    ! transform !    do i=1,fcf%na !        do j=1,fcf%atom(i)%n !            fcf%atom(i)%quartet(j)%v1= matmul(tm,fcf%atom(i)%quartet(j)%v1 ) !            fcf%atom(i)%quartet(j)%v2= matmul(tm,fcf%atom(i)%quartet(j)%v2 ) !            fcf%atom(i)%quartet(j)%v3= matmul(tm,fcf%atom(i)%quartet(j)%v3 ) !            fcf%atom(i)%quartet(j)%v4= matmul(tm,fcf%atom(i)%quartet(j)%v4 ) !            fcf%atom(i)%quartet(j)%lv1=matmul(tm,fcf%atom(i)%quartet(j)%lv1) !            fcf%atom(i)%quartet(j)%lv2=matmul(tm,fcf%atom(i)%quartet(j)%lv2) !            fcf%atom(i)%quartet(j)%lv3=matmul(tm,fcf%atom(i)%quartet(j)%lv3) !            fcf%atom(i)%quartet(j)%lv4=matmul(tm,fcf%atom(i)%quartet(j)%lv4) !            fcf%atom(i)%quartet(j)%rv1=matmul(tm,fcf%atom(i)%quartet(j)%rv1) !            fcf%atom(i)%quartet(j)%rv2=matmul(tm,fcf%atom(i)%quartet(j)%rv2) !            fcf%atom(i)%quartet(j)%rv3=matmul(tm,fcf%atom(i)%quartet(j)%rv3) !            fcf%atom(i)%quartet(j)%rv4=matmul(tm,fcf%atom(i)%quartet(j)%rv4) !            ! !            fcf%atom(i)%quartet(j)%m=rotate4(tm,fcf%atom(i)%quartet(j)%m) !            ! !        enddo !    enddo !    ! remap !    call fcf%remap(uc,nc,fcfn) !    call fcfn%writetofile(nc,'outfile.forceconstant_fourthorder_remapped') !    write(*,*) 'remapped the fourth order force constants' !endif contains ! function rotate ( op , m ) result ( n ) real ( flyt ), dimension ( 3 , 3 ), intent ( in ) :: op , m real ( flyt ), dimension ( 3 , 3 ) :: n ! integer :: i , j , ii , jj ! n = 0.0_flyt do j = 1 , 3 do i = 1 , 3 do jj = 1 , 3 do ii = 1 , 3 n ( i , j ) = n ( i , j ) + m ( ii , jj ) * op ( i , ii ) * op ( j , jj ) enddo enddo enddo enddo ! end function ! function rotate3 ( op , m ) result ( n ) real ( flyt ), dimension ( 3 , 3 , 3 ), intent ( in ) :: m real ( flyt ), dimension ( 3 , 3 ), intent ( in ) :: op real ( flyt ), dimension ( 3 , 3 , 3 ) :: n ! integer :: i , j , k , ii , jj , kk ! n = 0.0_flyt do i = 1 , 3 do j = 1 , 3 do k = 1 , 3 do ii = 1 , 3 do jj = 1 , 3 do kk = 1 , 3 n ( i , j , k ) = n ( i , j , k ) + m ( ii , jj , kk ) * op ( i , ii ) * op ( j , jj ) * op ( k , kk ) enddo enddo enddo enddo enddo enddo ! end function ! function rotate4 ( op , m ) result ( n ) real ( flyt ), dimension ( 3 , 3 , 3 , 3 ), intent ( in ) :: m real ( flyt ), dimension ( 3 , 3 ), intent ( in ) :: op real ( flyt ), dimension ( 3 , 3 , 3 , 3 ) :: n ! integer :: i , j , k , l , ii , jj , kk , ll ! n = 0.0_flyt do i = 1 , 3 do j = 1 , 3 do k = 1 , 3 do l = 1 , 3 do ii = 1 , 3 do jj = 1 , 3 do kk = 1 , 3 do ll = 1 , 3 n ( i , j , k , l ) = n ( i , j , k , l ) + m ( ii , jj , kk , ll ) * op ( i , ii ) * op ( j , jj ) * op ( k , kk ) * op ( l , ll ) enddo enddo enddo enddo enddo enddo enddo enddo ! end function ! end program","tags":"","loc":"sourcefile/main.f90~8.html","title":"main.f90 – TDEP"},{"text":"Programs lineshape Source Code main.f90 Source Code #include \"precompilerdefinitions\" program lineshape !!{!src/lineshape/manual.md!} use constants use type_crystalstructure use type_forceconstant_secondorder use type_forceconstant_thirdorder use type_forceconstant_fourthorder use type_qpointmesh use type_phonon_dispersions use type_phonon_dos use type_lotosplitting use type_phonon_bandstructure use helpers use dump_data use scatteringrates use phonondamping use options use io implicit none type ( lo_opts ) :: opts type ( lo_forceconstant_secondorder ) :: fc type ( lo_forceconstant_thirdorder ) :: fct type ( lo_forceconstant_fourthorder ) :: fcf type ( lo_phonon_dispersions ) :: dr , drdos type ( lo_crystalstructure ) :: uc type ( lo_monkhorst_pack_mesh ) :: qp , qpdos type ( lo_phonon_bandstructure ) :: bs type ( lo_phonon_dos ) :: pd type ( lo_phonon_selfenergy ) :: se type ( lo_loto ) :: loto type ( lo_qpoint ) :: qpoint real ( flyt ) :: t0 , temperature , f0 , f1 , sigma , weight real ( flyt ) :: timer_init , timer_total real ( flyt ), dimension (:), allocatable :: dum real ( flyt ), dimension ( 2 ) :: lsintx , lsinty real ( flyt ), dimension (:,:,:), allocatable :: dumdos complex ( flyt ), dimension ( 3 ) :: cv0 integer :: i , j , k , q1 , mode integer :: path , ii , jj ! ! Start timer ! timer_total = walltime () timer_init = walltime () call opts % parse () ! ! Read unitcell POSCAR ! call uc % readfromfile ( 'infile.ucposcar' ) write ( * , * ) '... read unitcell poscar' if ( opts % readiso ) then write ( * , * ) '... reading isotope distribution from file' call uc % readisotopefromfile () endif ! ! Read the force constant ! call fc % readfromfile ( uc ) write ( * , * ) '... read second order forceconstant' if ( opts % thirdorder ) then call fct % readfromfile ( uc ) write ( * , * ) '... read third order forceconstant' endif if ( opts % fourthorder ) then call fcf % readfromfile ( uc ) write ( * , * ) '... read fourth order forceconstant' endif ! ! Get a q-mesh ! call qp % generate ( uc , opts % qgrid , verbosity = opts % verbosity ) ! ! There might be some LO-TO-splitting ! if ( opts % loto ) then call loto % setoptions ( uc , fc , opts % lotocorrectiontype ) else call loto % initempty () endif call dr % generate ( qp , fc , uc , loto ) write ( * , * ) '... got the full dispersion relations' timer_init = walltime () - timer_init ! ! q-points on a path: ! if ( opts % qpointpath ) then ! the harmonic frequencies call bs % generate ( uc , fc , loto , npts = opts % nq_on_path , readpathfromfile = opts % readpathfromfile , verbosity = opts % verbosity ) ! Make space for linewidths do q1 = 1 , bs % nptot allocate ( bs % p ( q1 )% linewidth ( fc % na * 3 )) allocate ( bs % p ( q1 )% shift ( fc % na * 3 )) allocate ( bs % p ( q1 )% threephononphasespace ( fc % na * 3 )) enddo ! Dump some general info write ( * , * ) '        isotope:' , opts % isotopescattering write ( * , * ) '    threephonon:' , opts % thirdorder write ( * , * ) '     fourphonon:' , opts % fourthorder write ( * , * ) '           loto:' , opts % loto write ( * , * ) 'integrationtype:' , opts % integrationtype ! Calculate self energy temperature = opts % temperature allocate ( bs % intensity ( bs % nptot , opts % nf )) allocate ( bs % selfenergy_real ( bs % nptot , opts % nf , dr % nb )) allocate ( bs % selfenergy_imag ( bs % nptot , opts % nf , dr % nb )) call lo_progressbar_init () t0 = walltime () do q1 = 1 , bs % nptot ! call se % setoptions ( bs % q ( q1 ), uc , fc , loto , opts % nf , dr % nb , opts % sigma * dr % default_smearing (),& opts % integrationtype , opts % sigma , 2.1 * dr % omega_max , opts % verbosity ,& opts % loto , opts % isotopescattering , opts % thirdorder ,& opts % fourthorder ,. false .,. false .) call se % generate ( opts % temperature , qp , dr , uc , loto , fc , fct , fcf ) ! Add it to the intensity do j = 1 , fc % na * 3 do i = 2 , se % nf bs % selfenergy_imag ( q1 , i , j ) = se % im_3ph ( i , j ) + se % im_iso ( i , j ) bs % selfenergy_real ( q1 , i , j ) = se % re_3ph ( i , j ) + se % re_4ph ( i , j ) enddo ! get the linewidth exactly at the harmonic frequency bs % p ( q1 )% linewidth ( j ) = lo_linear_interpolation ( se % faxis , se % im_3ph (:, j ) + se % im_iso (:, j ),& bs % p ( q1 )% omega ( j )) * 2.0_flyt ! get the anharmonic shift at the harmonic frequency bs % p ( q1 )% shift ( j ) = lo_linear_interpolation ( se % faxis , se % re_3ph (:, j ) + se % re_4ph (:, j ),& bs % p ( q1 )% omega ( j )) ! Also store the phase-space volume at this q-point bs % p ( q1 )% threephononphasespace ( j ) = lo_linear_interpolation ( se % faxis , se % twophonondos (:, j ), bs % p ( q1 )% omega ( j )) enddo ! call lo_progressbar ( 'lineshape' , q1 , bs % nptot ) ! enddo write ( * , * ) 'got selfenergies in ' , walltime () - t0 call bs % write_dispersive_property ( opts % enhet , 'shift' , 'outfile.dispersion_shifts' ,. false .) call bs % write_dispersive_property ( opts % enhet , 'linewidth' , 'outfile.dispersion_linewidths' ,. false .) call bs % write_dispersive_property ( opts % enhet , 'threephononphasespace' , 'outfile.dispersion_threephononphasespace' ,. false .) ! Figure out some neat interpolation of self-energy for really small q do path = 1 , bs % npath if ( norm2 ( bs % segment ( path )% r1 ) . lt . lo_tol . or . norm2 ( bs % segment ( path )% r2 ) . lt . lo_tol ) then write ( * , * ) 'path' , path , 'contains, gamma, interpolate for really small q' ! f0 = ( se % intensityaxis ( 2 ) - se % intensityaxis ( 1 )) * 0.25_flyt ! smallest selfenergy ! ! Is it in the beginning or the end? ! if ( norm2 ( bs % segment ( path )% r1 ) . lt . lo_tol ) then ! index in long array of this point ii = ( path - 1 ) * bs % npts + 1 ! loop over the three lowest branches do j = 1 , 3 jj = 0 do i = ii , ii + bs % npts - 1 if ( bs % p ( i )% omega ( j ) . gt . dr % omega_min * 0.5_flyt ) then jj = i exit endif enddo ! ! Interpolate this, somehow ! bs % selfenergy_imag ( ii ,:, j ) = f0 ! set imaginary at gamma bs % selfenergy_real ( ii ,:, j ) = 0.0_flyt ! set real at gamma ! x-axis for interpolation lsintx ( 1 ) = bs % q_axis ( ii ) - 1 E - 10_flyt lsintx ( 2 ) = bs % q_axis ( jj ) + 1 E - 10_flyt ! interpolate to missing points do k = 1 , se % nf ! y-axis for interpolation lsinty ( 1 ) = bs % selfenergy_imag ( ii , k , j ) lsinty ( 2 ) = bs % selfenergy_imag ( jj , k , j ) do i = ii + 1 , jj - 1 bs % selfenergy_imag ( i , k , j ) = lo_linear_interpolation ( lsintx , lsinty , bs % q_axis ( i )) enddo ! y-axis for interpolation lsinty ( 1 ) = bs % selfenergy_real ( ii , k , j ) lsinty ( 2 ) = bs % selfenergy_real ( jj , k , j ) do i = ii + 1 , jj - 1 bs % selfenergy_real ( i , k , j ) = lo_linear_interpolation ( lsintx , lsinty , bs % q_axis ( i )) enddo enddo ! enddo ! else ! index in long array of this point ii = path * bs % npts ! loop over the three lowest branches do j = 1 , 3 jj = 0 do i = ii ,( path - 1 ) * bs % npts + 1 , - 1 if ( bs % p ( i )% omega ( j ) . gt . dr % omega_min * 0.5_flyt ) then jj = i exit endif enddo ! ! Interpolate this, somehow ! bs % selfenergy_imag ( ii ,:, j ) = f0 ! set imaginary at gamma bs % selfenergy_real ( ii ,:, j ) = 0.0_flyt ! set real at gamma ! x-axis for interpolation lsintx ( 2 ) = bs % q_axis ( ii ) - 1 E - 10_flyt lsintx ( 1 ) = bs % q_axis ( jj ) + 1 E - 10_flyt ! interpolate to missing points do k = 1 , se % nf ! y-axis for interpolation lsinty ( 2 ) = bs % selfenergy_imag ( ii , k , j ) lsinty ( 1 ) = bs % selfenergy_imag ( jj , k , j ) do i = jj + 1 , ii - 1 bs % selfenergy_imag ( i , k , j ) = lo_linear_interpolation ( lsintx , lsinty , bs % q_axis ( i )) enddo ! y-axis for interpolation lsinty ( 2 ) = bs % selfenergy_real ( ii , k , j ) lsinty ( 1 ) = bs % selfenergy_real ( jj , k , j ) do i = jj + 1 , ii - 1 bs % selfenergy_real ( i , k , j ) = lo_linear_interpolation ( lsintx , lsinty , bs % q_axis ( i )) enddo enddo ! enddo ! endif endif enddo ! ! Start calculating intensities ! call lo_progressbar_init () bs % intensity = 0.0_flyt allocate ( dum ( se % nf )) do q1 = 1 , bs % nptot do j = 1 , fc % na * 3 ! Get the lineshape dum = 0.0_flyt if ( bs % p ( q1 )% omega ( j ) . gt . dr % omega_min * lo_tol ) then call getintensity ( se % faxis , bs % selfenergy_imag ( q1 ,:, j ), bs % selfenergy_real ( q1 ,:, j ),& bs % p ( q1 )% omega ( j ), se % intensityaxis , dum ) else ! acoustic branch at Gamma. Add a gaussian at 0 to no make it disappear. do i = 1 , se % nf dum ( i ) = lo_gauss ( se % intensityaxis ( i ), 0.0_flyt , se % intensityaxis ( 2 ) - se % intensityaxis ( 1 )) enddo endif ! Add it to the intensity bs % intensity ( q1 ,:) = bs % intensity ( q1 ,:) + dum enddo call lo_progressbar ( 'intensities' , q1 , bs % nptot ) enddo deallocate ( dum ) ! ! y-axis for plots ! allocate ( bs % faxis ( se % nf )) bs % faxis = se % intensityaxis call bs % write_intensity ( opts % enhet , logscale = . true .) ! endif ! ! Maybe calculate the phonon dos ! if ( opts % phonondos ) then ! Calculate the phonon dos with proper smearing write ( * , * ) '... calculating the smeared DOS' ! ! get q-grid for the DOS and the dispersions call qpdos % generate ( uc , opts % qgrid_dos ) call drdos % generate ( qpdos , fc , uc , loto ) ! ! Make some space where to store things ! lo_allocate ( dumdos ( opts % nf , dr % nb , qpdos % nq_irr )) dumdos = 0.0_flyt ! ! Get all the lineshapes ! call lo_progressbar_init () do q1 = 1 , qpdos % nq_irr ! ! get the lineshape ! call se % setoptions ( qpdos % ip ( q1 ), uc , fc , loto , opts % nf , dr % nb , opts % sigma * dr % default_smearing (),& opts % integrationtype , opts % sigma , 2.1 * dr % omega_max , opts % verbosity ,& opts % loto , opts % isotopescattering , opts % thirdorder ,& opts % fourthorder ,. false .,. false .) call se % generate ( opts % temperature , qp , dr , uc , loto , fc , fct , fcf ) ! ! Get the intensity ! do mode = 1 , drdos % nb call getintensity ( se % faxis , se % im_3ph (:, mode ) + se % im_iso (:, mode ),& se % re_3ph (:, mode ) + se % re_4ph (:, mode ), se % p % omega ( mode ), se % faxis ,& se % intensity (:, mode )) f0 = lo_trapezoid_integration ( se % faxis , se % intensity (:, mode )) if ( f0 . lt . lo_tol ) then ! add a narrow gaussian instead if ( drdos % iq ( q1 )% omega ( mode ) . gt . drdos % omega_min * 0.5_flyt ) then do i = 1 , se % nf se % intensity ( i , mode ) = lo_gauss ( se % faxis ( i ), drdos % iq ( q1 )% omega ( mode ), abs ( se % faxis ( 3 ) - se % faxis ( 1 ))) enddo endif endif enddo ! ! Store the intensities ! do mode = 1 , se % nb do i = 1 , se % nf if ( se % intensity ( i , mode ) . gt . 0 ) then dumdos ( i , mode , q1 ) = dumdos ( i , mode , q1 ) + se % intensity ( i , mode ) endif enddo enddo ! call lo_progressbar ( ' ... calculating phonon dos' , q1 , qpdos % nq_irr ) ! enddo ! ! Build the phonon dos structure ! lo_allocate ( pd % omega ( opts % nf )) lo_allocate ( pd % pdos_site ( opts % nf , uc % na )) lo_allocate ( pd % pdos_mode ( opts % nf , dr % nb )) lo_allocate ( pd % dos ( opts % nf )) pd % na = uc % na pd % nb = dr % nb pd % ndos = opts % nf pd % enhet = opts % enhet pd % omega = se % faxis !intensityaxis pd % pdos_site = 0.0_flyt pd % pdos_mode = 0.0_flyt pd % dos = 0.0_flyt pd % dosprojection = . true . pd % dossmear = drdos % default_smearing () pd % dosmax = maxval ( pd % omega ) ! ! Add it together (with some smearing???) ! lo_allocate ( dum ( pd % ndos )) call lo_progressbar_init () do q1 = 1 , qpdos % nq_irr ! weight = qpdos % ip ( q1 )% weight ! do mode = 1 , drdos % nb ! if ( drdos % iq ( q1 )% omega ( mode ) . gt . drdos % omega_min * 0.5_flyt ) then ! ! ok, smear a little ! sigma = qpdos % smearingparameter ( drdos % iq ( q1 )% vel (:, mode ), pd % dossmear , opts % sigma ) dum = 0.0_flyt do i = 1 , pd % ndos ii = floor ( pd % ndos * ( pd % omega ( i ) - 4 * sigma ) / pd % dosmax ) ii = max ( ii , 1 ) jj = ceiling ( pd % ndos * ( pd % omega ( i ) + 4 * sigma ) / pd % dosmax ) jj = min ( jj , pd % ndos ) do j = ii , jj dum ( i ) = dum ( i ) + lo_gauss ( pd % omega ( i ), pd % omega ( j ), sigma ) * dumdos ( j , mode , q1 ) enddo enddo ! make sure it's normalized after convolution dum = dum / lo_trapezoid_integration ( pd % omega , dum ) dum = dum * weight ! add it to the mode-projected pd % pdos_mode (:, mode ) = pd % pdos_mode (:, mode ) + dum ! get the site-projection thing do i = 1 , uc % na cv0 = drdos % iq ( q1 )% egv (( i - 1 ) * 3 + 1 : i * 3 , mode ) f0 = abs ( dot_product ( cv0 , conjg ( cv0 ))) pd % pdos_site (:, i ) = pd % pdos_site (:, i ) + f0 * dum enddo endif ! enddo ! call lo_progressbar ( ' ... integrating phonon dos' , q1 , qpdos % nq_irr ) enddo lo_deallocate ( dum ) ! ! Start normalizing, first the whole thing ! do mode = 1 , drdos % nb pd % dos = pd % dos + pd % pdos_mode (:, mode ) f0 = lo_trapezoid_integration ( pd % omega , pd % pdos_mode (:, mode )) pd % pdos_mode = pd % pdos_mode / f0 enddo ! remove stupid stuff f1 = pd % dos ( 1 ) do i = 1 , pd % ndos f0 = ( pd % ndos - i ) * 1.0_flyt / ( ( pd % ndos - 1 ) * 1.0_flyt ) f0 = f0 ** 2 pd % dos ( i ) = pd % dos ( i ) - f0 * f1 if ( pd % dos ( i ) . lt . 0.0_flyt ) pd % dos ( i ) = 0.0_flyt enddo pd % dos ( 1 ) = 0.0_flyt ! f0 = lo_trapezoid_integration ( pd % omega , pd % dos ) pd % dos = pd % dos * dr % nb / f0 ! and the site-projected do i = 1 , uc % na f0 = lo_trapezoid_integration ( pd % omega , pd % pdos_site (:, i )) pd % pdos_site (:, i ) = pd % pdos_site (:, i ) / f0 enddo ! make sure the pojected adds up to the total do i = 1 , pd % ndos if ( pd % dos ( i ) . gt . lo_tol / lo_twopi / 1 E12_flyt ) then f0 = sum ( pd % pdos_mode ( i ,:)) pd % pdos_mode ( i ,:) = pd % pdos_mode ( i ,:) * pd % dos ( i ) / f0 f0 = sum ( pd % pdos_site ( i ,:)) pd % pdos_site ( i ,:) = pd % pdos_site ( i ,:) * pd % dos ( i ) / f0 endif enddo ! ! Write it to file ! call pd % write_to_file ( uc , opts % enhet , pdfplot = . false ., modeproj = . false ., filename = 'outfile.phonon_dos_lineshape' ) ! endif if ( opts % oneqpoint ) then ! ! Perhaps I choose the point in the fancy way ! qpoint % noperations = 0 if ( trim ( opts % highsymmetrypoint ) . ne . 'none' ) then qpoint % v = uc % coordinate_from_high_symmetry_point_label ( opts % highsymmetrypoint ) else qpoint % v = uc % fractional_to_cartesian ( opts % qpoint , reciprocal = . true .) endif qpoint % w = qpoint % v - uc % bz % gshift ( qpoint % v ) ! ! Lineshape at a single q-point ! write ( * , * ) '... setting options for self-energy integrations' call se % setoptions ( qpoint , uc , fc , loto , opts % nf , dr % nb , opts % sigma * dr % default_smearing (),& opts % integrationtype , opts % sigma , 2.1 * dr % omega_max , opts % verbosity + 1 ,& opts % loto , opts % isotopescattering , opts % thirdorder ,& opts % fourthorder ,. false .,. false .) write ( * , * ) '... generating lineshape for a single q-point' call se % generate ( opts % temperature , qp , dr , uc , loto , fc , fct , fcf ) ! ! Get nice intensities ! do i = 1 , se % nb if ( se % p % omega ( i ) . gt . dr % omega_min * lo_tol ) then call getintensity ( se % faxis , se % im_3ph (:, i ) + se % im_iso (:, i ),& se % re_3ph (:, i ) + se % re_4ph (:, i ), se % p % omega ( i ), se % intensityaxis , se % intensity (:, i )) else se % intensity (:, i ) = 0.0_flyt endif enddo ! ! Dump it to file ! call write_lineshape_to_file ( se , dr % omega_max * 1.3_flyt , opts % enhet ) ! endif ! ! All done, print timings ! timer_total = walltime () - timer_total write ( * , * ) ' ' write ( * , * ) ' Timings:' write ( * , * ) '              initialization:' , timer_init write ( * , * ) '                       total:' , timer_total end program","tags":"","loc":"sourcefile/main.f90~9.html","title":"main.f90 – TDEP"},{"text":"Programs generate_structure Source Code main.f90 Source Code #include \"precompilerdefinitions\" program generate_structure !!{!src/generate_structure/manual.md!} use constants use type_crystalstructure use type_neighbourlist use type_mdsim use helpers use dump_data use options use type_symmetrytable use type_sqs ! implicit none type ( lo_opts ) :: opts type ( lo_crystalstructure ) :: uc , ss type ( lo_sqs ) :: sqs type ( lo_symcell ) :: sy integer :: i , j , k , l , u , ii , jj integer , dimension (:), allocatable :: dum real ( flyt ), dimension ( 3 , 3 ) :: tm character ( len = 100 ) :: opf call opts % parse () ! read positions call uc % readfromfile ( 'infile.ucposcar' , verbosity = opts % verbosity ) write ( * , * ) '... read unitcell' ! Build a supercell if ( sum ( abs ( opts % ndssdim )) . gt . 0.0_flyt ) then call uc % build_supercell ( ss , nondiagdimensions = opts % ndssdim ) else call uc % build_supercell ( ss , opts % ssdim ) endif ! build a supercell write ( * , * ) '... built supercell, dimensions ' // trim ( int2char ( opts % ssdim ( 1 ))) // 'x' // trim ( int2char ( opts % ssdim ( 2 ))) // 'x' // trim ( int2char ( opts % ssdim ( 3 ))) ! select case ( opts % outputformat ) case ( 1 ) ! VASP call ss % writetofile ( 'outfile.ssposcar' ) write ( * , * ) '... wrote supercell in VASP format' case ( 2 ) ! Abinit call ss % writetofile_abi ( 'outfile.supercell_abinit' ) write ( * , * ) '... wrote supercell in Abinit format' case ( 3 ) ! LAMMPS call ss % writetofile_lammps ( 'outfile.supercell_lammps' , transformationmatrix = tm ) write ( * , * ) '... wrote supercell in LAMMPS format' uc % latticevectors = matmul ( tm , uc % latticevectors ) ss % latticevectors = matmul ( tm , ss % latticevectors ) call uc % writetofile ( 'outfile.uc_lammps' ) call ss % writetofile ( 'outfile.ss_lammps' ) end select ! Now stop if there is no alloy stuff going on. if ( uc % info % alloy . eqv . . false . ) then write ( * , * ) '... done' stop endif ! ! ! ! ! Now I assume it's an alloy that should be sqs-ed or whatever it's called. ! ! ! ! is cutoff specified? If not, set it to max in the supercell ! if ( opts%cutoff2 .lt. 0 ) then !     opts%cutoff2=ssposcar%maxcutoff() ! else !     opts%cutoff2=max(opts%cutoff2,ssposcar%mincutoff()) ! endif ! ! what about higher order cutoffs? ! if ( opts%cutoff3 .gt. 0 ) then !     opts%cutoff3=max(opts%cutoff3,ssposcar%mincutoff()) ! endif ! if ( opts%cutoff4 .gt. 0 ) then !     opts%cutoff4=max(opts%cutoff4,ssposcar%mincutoff()) ! endif ! ! set options for symmetry thingys ! call sy%generate(ucposcar,ssposcar,opts%cutoff2,opts%cutoff3,opts%cutoff4,& !                  testscalar=opts%collmagnetism,testvector=opts%noncollmagnetism,& !                  testmatrix=opts%loto,verbosity=opts%verbosity,transpositions=.false.) ! ! ! How many symmetry unique pairs are there? ! ! write(*,*) 'Found '//trim(int2char(sy%nun))//' unique atoms' ! do i=1,ucposcar%na !     write(*,*) 'atom '//trim(int2char(i))//' is of unique type '//trim(int2char(sy%uc(i)%kvalisort))& !                //' with '//trim(int2char(sy%uc(i)%npair))//' neighbours within cutoff' ! enddo ! write(*,*) 'In the supercell we can only fit coordination shells within '//trim(flyt2char(opts%cutoff2))//' A' ! ! ! ! That's nice. Now I should have a nice way of calculating cluster correlation functions ! ! ! call lo_seed_random_numbers() ! call sqs%setup(ucposcar,ssposcar,sy,opts%distanceweight,opts%bigiterations,opts%smalliterations,opts%thres,.false.,opts%readinitial) ! call sqs%init_pairs(ucposcar,sy) ! call sqs%optimize(ssposcar) ! ! !stop ! ! !call sqs%setoptions(distanceweight=opts%distanceweight,bigiterations=opts%bigiterations,& ! !                    smalliterations=opts%smalliterations,thres=opts%thres) ! !call sqs%init(ucposcar,ssposcar,sy) ! ! get the poscar ! call sqs%returnposcar(ssposcar,sqsposcar,sqs%finalspecies) ! ! ! ! Dump files ! ! ! call sqsposcar%writetofile('outfile.sqs') ! ! ! ! Adjust the concentrations to the actual concentration ! ! ! do i=1,ucposcar%na !     if ( ucposcar%alloyatom(i)%n .gt. 0 ) then !         ! Find the sublattice corresponding to this atom !         k=0 !         do j=1,sqs%nsub !             if ( sqs%sub(j)%kvalisort .eq. sy%uc(i)%kvalisort ) then !                 k=j !                 exit !             endif !         enddo !         ucposcar%alloyatom(i)%conc=sqs%sub(k)%conc !     endif ! enddo ! ! do i=1,ssposcar%na !     if ( ssposcar%alloyatom(i)%n .gt. 0 ) then !         k=0 !         do j=1,sqs%nsub !             if ( sqs%sub(j)%kvalisort .eq. sy%ss(i)%kvalisort ) then !                 k=j !                 exit !             endif !         enddo !         ssposcar%alloyatom(i)%conc=sqs%sub(k)%conc !     endif ! enddo ! ! ! call ucposcar%writetofile('outfile.sqs_alloy_unitcell') ! call ssposcar%writetofile('outfile.sqs_alloy_supercell') ! ! ! u=open_file('out','outfile.sqs_correlationfunctions') !     allocate(dum(100)) !     do i=1,100 !         dum(i)=i !     enddo ! !     do i=1,sqs%nsub !         l=sqs%sub(i)%npairshells !         select case(sqs%sub(i)%nspecies) !         case(2) !             opf=\"(1X,'sublattice ',I2,' composition:',2(1X,A2,1X,F8.6))\" !             write(u,opf) i,sqs%sub(i)%atomic_symbol(1),sqs%sub(i)%conc(1),sqs%sub(i)%atomic_symbol(2),sqs%sub(i)%conc(2) !         case(3) !             opf=\"(1X,'sublattice ',I2,' composition:',3(1X,A2,1X,F8.6))\" !             write(u,opf) i,sqs%sub(i)%atomic_symbol(1),sqs%sub(i)%conc(1),& !                            sqs%sub(i)%atomic_symbol(2),sqs%sub(i)%conc(2),& !                            sqs%sub(i)%atomic_symbol(3),sqs%sub(i)%conc(3) !         case(4) !             opf=\"(1X,'sublattice ',I2,' composition:',4(1X,A2,1X,F8.6))\" !             write(u,opf) i,sqs%sub(i)%atomic_symbol(1),sqs%sub(i)%conc(1),& !                            sqs%sub(i)%atomic_symbol(2),sqs%sub(i)%conc(2),& !                            sqs%sub(i)%atomic_symbol(3),sqs%sub(i)%conc(3),& !                            sqs%sub(i)%atomic_symbol(4),sqs%sub(i)%conc(4) !         case(5) !             opf=\"(1X,'sublattice ',I2,' composition:',5(1X,A2,1X,F8.6))\" !             write(u,opf) i,sqs%sub(i)%atomic_symbol(1),sqs%sub(i)%conc(1),& !                            sqs%sub(i)%atomic_symbol(2),sqs%sub(i)%conc(2),& !                            sqs%sub(i)%atomic_symbol(3),sqs%sub(i)%conc(3),& !                            sqs%sub(i)%atomic_symbol(4),sqs%sub(i)%conc(4),& !                            sqs%sub(i)%atomic_symbol(5),sqs%sub(i)%conc(5) !         end select ! !         opf=\"(1X,A5,\"//trim(int2char(l))//\"(4X,I4))\" !         write(u,opf) 'shell',dum(1:l) !         do ii=1,sqs%nspecies-1 !         do jj=1,sqs%nspecies-1 !             if ( sqs%cf_target(i)%pair_nonzero_per_alpha(ii,jj) .gt. 0 ) then !                 opf=\"(1X,A5,I1,I1,2X,\"//trim(int2char(l))//\"(1X,F7.5))\" !                 write(u,opf) ' cf',ii,jj,sqs%cf_current(i)%paircorr(ii,jj,:) !             endif !         enddo !         enddo !     enddo !     deallocate(dum) ! close(u) ! ! ! write(*,*) 'Done!' ! end program","tags":"","loc":"sourcefile/main.f90~10.html","title":"main.f90 – TDEP"},{"text":"main file for canonical configuration Programs canonical_configuration Source Code main.f90 Source Code #include \"precompilerdefinitions\" !! main file for canonical configuration program canonical_configuration !!{!src/canonical_configuration/manual.md!} use constants use helpers use options use type_qpointmesh use type_phonon_dispersions use type_crystalstructure use type_forceconstant_secondorder use type_qpointmesh use type_lotosplitting implicit none type ( lo_opts ) :: opts type ( lo_crystalstructure ) :: ss , uc , sqs , alloy , p type ( lo_forceconstant_secondorder ) :: fc , fcss class ( lo_qpoint_mesh ), allocatable :: qp type ( lo_loto ) :: loto type ( lo_phonon_dispersions ) :: dr integer :: i integer , dimension ( 3 ) :: qdim real ( flyt ) :: ep , ek , temp , avgtemp real ( flyt ) :: f0 , f1 , alpha , step character ( len = 72 ) :: fname ! Get CLI options call opts % parse () ! Seed the random numbers call lo_seed_random_numbers () ! Read structures write ( * , * ) '... reading infiles' call ss % readfromfile ( 'infile.ssposcar' ) call uc % readfromfile ( 'infile.ucposcar' ) ! get a forceconstant somehow if ( opts % debye_temperature . gt . 0.0_flyt ) then call fc % fake_forceconstant ( uc , ss , opts % debye_temperature ) write ( * , * ) '... constructed fake forceconstant corresponding to Td=' , trim ( flyt2char ( opts % debye_temperature )) ! dump the stupid forceconstant call fc % writetofile ( uc , 'outfile.fakeforceconstant' ) write ( * , * ) '... wrote it to \"outfile.fakeforceconstant\", check that the frequency range is reasonable' ! now we have a fake forceconstant and can keep going! else ! read the forceconstant from file call fc % readfromfile ( uc ) endif ! Remap force constant to supercell if ( uc % info % alloy ) then write ( * , * ) '... alloy detected' write ( * , * ) 'Not done' stop ! the unitcell is an alloy, now I have to think a little !call sqs%readfromfile('infile.sqs') !call alloy%readfromfile('infile.sqs_alloy_supercell') ! the remapping is a bit different !alloy%r=sqs%r !call fc%remap(uc,alloy,fcss) else ! in normal case just remap it call fc % remap ( uc , ss , fcss ) endif write ( * , * ) '... remapped fc' ! Clean copy to work with p = ss avgtemp = 0.0_flyt do i = 1 , opts % nconf ! reset the structure p % r = ss % r p % v = 0.0_flyt p % u = 0.0_flyt ! initialize call fcss % initialise_cell ( p , opts % temperature , opts % zpm ,. false ., opts % threshold ) ! dump to file select case ( opts % output_code ) case ( 1 ) ! vasp output fname = 'contcar_conf' // trim ( int2char_padded ( i , 4 )) call p % writetofile ( trim ( fname ), write_velocities = . true .) case ( 2 ) ! abinit output fname = 'abinput_conf' // trim ( int2char_padded ( i , 4 )) call p % writetofile_abi ( trim ( fname ), write_velocities = . true .) end select ! just measure some stuff, for no good reason ek = p % kinetic_energy () / ( p % na - 1 ) ep = fcss % potential_energy ( p % u ) / ( p % na - 1 ) temp = ( ek + ep ) / ( 3 * lo_kb_ev ) avgtemp = avgtemp + temp write ( * , \"(1X,'conf:',I4,' ek:',F10.5,' ep:',F10.5,' temp:',F10.2,' mean temp',F10.2)\" ) i , ek , ep , temp , avgtemp / i enddo end program","tags":"","loc":"sourcefile/main.f90~11.html","title":"main.f90 – TDEP"},{"text":"Short description Calculates the power spectra from the velocity autocorrelation function. In addition, it uses forceconstants to fourier-interpolate the q-resolved spectra non the non-exact q-points. What that means is that it can generate continuous spectralfunctions as a function of wavevector not limited to the commensurate modes. Command line options: Optional switches: --noforceconstant default value .false. Do not use forceconstants for Fourier interpolation. --dos default value .false. Outputs the DOS. This requires a specification of a q-point mesh. --unit value , value in: thz,mev,icm default value thz Choose the output unit. The options are terahertz (in frequency, not angular frequency), inverse cm or meV. --loto default value .false. Add the corrections due to long-range electrostatic interactions, requires infile.lotosplitting Format is specified here . --nq_on_path value , -nq value default value 100 Number of q-points between each high symmetry point --readpath , -rp default value .false. Read the q-point path from infile.qpoints_dispersion . Use crystal structure into to generate an example. --qpoint_grid value#1 value#2 value#3 , -qg value#1 value#2 value#3 default value 26 26 26 Density of q-point mesh for DOS interpolation. --maxfrequency value default value 1.3 Changes the maximum frequency. Default is 1.3 times the maximum frequency determined from the supplied forceconstants. --help , -h Print this help message --version , -v Print version Examples autocorrelation autocorrelation Long description The (discrete) velocity autocorrelation function is defined for atom $i$ and Cartesian component $\\alpha$ as \nC&#94;{i\\alpha}_v(\\tau) = \n\\sum_{t=1}&#94;{N_t}\n v&#94;{\\alpha}_{i}(t)v&#94;{\\alpha}_{i}(t+\\tau)\n Where $\\tau$ is the lag time and $v_i(t)$ the velocity of atom $i$ at time $t $. We want this resolved in reciprocal space in the frequency domain: \nC(\\mathbf{q},\\omega) = \n\\sum_\\alpha\n\\sum_{i}\n\\mathcal{F}\\left\\{\\ C&#94;{i\\alpha}_v \\right\\}&#94;2 e&#94;{i\\mathbf{q}\\cdot \\mathbf{R}_i}\n where $\\mathcal{F}$ is the discrete Fourier transform over lag time. Here we exploited the fact that the Fourier transform of a convolution is a product in the frequency domain. Without loss of information, the velocities can be transformed to normal mode coordinates: \nv_{\\mathbf{q}s}&#94;{\\alpha}\n= \\sum_i \\epsilon_{\\mathbf{q}s}&#94;{i\\alpha} v_{i}&#94;{\\alpha}\n where the modes $\\mathbf{q}s$ are confined to the exact q-points and modes of the simulation cell. This gives us the mode-resolved velocity autocorrelation function \nC&#94;{\\mathbf{q}s}_v(\\tau) = \n\\sum_{\\alpha}\n\\sum_{t=1}&#94;{N_t}\n v_{\\mathbf{q}s}&#94;{\\alpha}(t) v_{\\mathbf{q}s}&#94;{\\alpha}(t+\\tau)\n and the mode resolved power spectra \nC(\\mathbf{q},s,\\omega) = \n\\mathcal{F}\\left\\{\\ C&#94;{\\mathbf{q}s}_v(\\tau) \\right\\}&#94;2\n which is easily interpolated to an arbitrary q-vector. The code will output the raw power spectra as well as the interpolated. Practical considerations Please note that autocorrelation function spectra require careful calculations. It is far better suited for classical molecular dynamics rather than Born-Oppenheimer MD. The frequency resolution scales as the simulation time, requiring very long simulation times. The (typical) small sizes of first principles MD introduce odd artifacts. Some simple convergence tests shows that the phonon lineshapes from perturbation theory and correlation functions agree at about 10000 atoms and 1ns simulation times. Do not use this code to try to determine phonon lineshapes/lifetimes unless you really know what you are doing. Input files These files are necesarry infile.ucposcar infile.ssposcar infile.meta infile.stat infile.positions infile.forces infile.forceconstant Optional file to specify a path for the phonon dispersions infile.qpoints_dispersion For including the electrostatic corrections infile.lotosplitting Output files outfile.acf_sqe.hdf5 The file is more or less self-explainatory, the following is a matlab snippet that produces a neat plot: % read everything from file fn =( 'outfile.acf_sqe.hdf5' ); x = h5read ( fn , '/q_values' ); y = h5read ( fn , '/energy_values' ); gz = h5read ( fn , '/intensity' ); xtck = h5read ( fn , '/q_ticks' ); xtcklabel = strsplit ( h5readatt ( fn , '/' , 'q_tick_labels' )); energyunit = h5readatt ( fn , '/' , 'energy_unit' ); % plot the results figure ( 1 ); clf ; hold on ; box on ; [ gy , gx ]= meshgrid ( y , x ); s = pcolor ( gx , gy , log10 ( gz + 1E-2 )); set ( s , 'edgecolor' , 'none' , 'facecolor' , 'interp' ) set ( gca , 'xtick' , xtck , 'xticklabel' , xtcklabel ) ylabel ([ 'Energy (' energyunit ')' ]) xlim ([ 0 max ( x )]) ylim ([ 0 max ( y )]) outfile.acf_highsymmetrypoint_?? In case the exact q-points of the simulation cell coincide with high-symmetry points, the spectralfunction at those points will be printed: Row Description 1  \\omega_1 \\qquad I_1 \\qquad I_2 \\qquad \\ldots \\qquad I_{3\\mathbf{N}_{a}}  2  \\omega_2 \\qquad I_1 \\qquad I_2 \\qquad \\ldots \\qquad I_{3\\mathbf{N}_{a}}  ... ... That is, the first column is the energy, the following are intensities per mode. outfile.acf_raw_dos With option --dos this will be written, containing the raw power spectrum without any interpolation procedure. It usually looks awful. Row Description 1  \\omega_1 \\qquad g(\\omega_1) \\qquad g_1(\\omega_1) \\qquad \\ldots \\qquad g_{N_a}(\\omega_1)  2  \\omega_2 \\qquad g(\\omega_2) \\qquad g_1(\\omega_2) \\qquad \\ldots \\qquad g_{N_a}(\\omega_2)  ... ... The first column is energy, the second the total DOS. In case there is more than one atom per unit cell, the site projected DOS is printed as well. outfile.acf_interpolated_dos The format is identical to the raw dos above.","tags":"","loc":"program/autocorrelation.html","title":"\n    \n        autocorrelation – TDEP\n    \n"},{"text":"Short description The main algorithm of the TDEP method. Starting with a symmetry analysis, this code finds the irreducible representation of interatomic forceconstants and extracts them from position and force data. Command line options: Optional switches: --secondorder_cutoff value , -rc2 value default value 5.0 Cutoff for the second order force constants --thirdorder_cutoff value , -rc3 value default value -1 Cutoff for the third order force constants --stride value , -s value default value 1 Use every N configuration instead of all. Useful for long MD simulations with linearly dependent configurations. --firstorder default value .false. Include the first order force constants. These can be used to find the finite temperature equilibrium structure. --residualfit default value .false. Fit the second order first, then the higher orders to the residual. --readforcemap default value .false. Read infile.forcemap.hdf5 from file instead of calculating all symmetry relations. Useful for sets of calculations with the same structure. --readirreducible default value .false. Read the irreducible forceconstants from infile.irrifc_* instead of solving for them. This option requires an infile.forcemap.hdf5 , as above. --potential_energy_differences , -U0 default value .false. Calculate the difference in potential energy from the simulation and the forceconstants to determine U0. As referenced in the thermodynamics section of phonon dispersion relations this is the renormalized baseline for the TDEP free energy: U_0= \\left\\langle U&#94;{\\textrm{BO}}(t)-\\frac{1}{2} \\sum_{ij}\\sum_{\\alpha\\beta} \\Phi_{ij}&#94;{\\alpha\\beta} \\mathbf{u}&#94;{\\alpha}_i(t) \\mathbf{u}&#94;{\\beta}_j(t) \\right\\rangle This number should be added to the appropriate phonon free energy. --help , -h Print this help message --version , -v Print version Examples getforceconstants.skript -rc2 5.1 getforceconstants.skript -rc2 4.5 -rc3 3.21 -collmagnetism Longer summary Calculations of the interatomic force constants are the most important part of any lattice dynamics calculation as they are used to calculate many micro and macroscopic properties of the system, e.g. phonon, thermodynamic, and transport properties, etc. This codes takes sets of displacements and forces, and uses these to fit the coefficients in an effective lattice dynamical Hamiltonian. This is by no means a new idea. 1 The main advantage of the TDEP method is in the implementation: it is numerically robust, well tested and general. It is not limited in order, nor limited to simple ordered systems. Lattice dynamics and interatomic force constants A quick recap of lattice dynamical theory: 2 a displacement $\\mathbf{u}$ of an atom $i$ from its ideal lattice position changes the potential energy of the lattice. Temperature disorders the lattice, causing all atoms to be displaced from their equilibrium positions; this effect can be modeled as a Taylor expansion of the potential energy contribution of the instantaneous positions of the atoms in the system, i.e. $U=U({ \\mathbf{r} })$. It is convenient to define the atomic positions as displacements $ \\mathbf{u} $ from their equilibrium positions $\\mathbf{R}_i+\\mathbf{\\mu}_i$. \n\\begin{equation}\n\\textbf{r}_i=\\mathbf{R}_i+\\mathbf{\\mu}_i+\\mathbf{u}_i.\n\\end{equation}\n $\\mathbf{R}_i$ is a lattice vector and $\\mu_i$ is the position in the unit cell. We can then expand the potential energy in terms of displacements as: \n\\begin{equation}\n\\begin{split}\nU(\\{\\textbf{u}\\})=& U_0+\n\\sum_{i}\\sum_\\alpha\n\\Phi&#94;\\alpha_{i} u&#94;\\alpha_{i} + \n\\frac{1}{2!} \\sum_{ij} \\sum_{\\alpha\\beta} \\Phi&#94;{\\alpha\\beta}_{ij} u&#94;\\alpha_{i} u&#94;\\beta_{j} + \\\\\n + & \\frac{1}{3!} \\sum_{ijk} \\sum_{\\alpha\\beta\\gamma} \\Phi&#94;{\\alpha\\beta\\gamma}_{ijk} u&#94;\\alpha_{i} u&#94;\\beta_{j} u&#94;\\gamma_{k}+\\ldots\n \\end{split}\n\\end{equation}\n Here, $ \\alpha\\beta\\gamma $ are Cartesian indices and $ U_0 $ is the potential energy of the static lattice. The coefficients of the Taylor expansion are the derivatives of the potential energy with respect to displacement and are called the Born-von Kàrmàn force constants, which can be expressed as tensors of increasing rank: \n\\begin{align}\n\\Phi&#94;\\alpha_i & = \\left. \\frac{\\partial U}{\\partial u_i&#94;\\alpha} \\right|_{u=0} = 0 \\\\\n\\Phi&#94;{\\alpha\\beta}_{ij} & = \\left. \\frac{\\partial&#94;2 U}{\\partial u_i&#94;\\alpha \\partial u_j&#94;\\beta} \\right|_{u=0} \\\\\n\\Phi&#94;{\\alpha\\beta\\gamma}_{ijk} & = \\left. \\frac{\\partial&#94;3 U}{\\partial u_i&#94;\\alpha \\partial u_j&#94;\\beta \\partial u_k&#94;\\gamma} \\right|_{u=0}\n\\end{align}\n By increasing rank, the force constants of rank $n$ represent $n$-body interactions, as illustrated in the diagram below: Force constant symmetries Symmetry analysis allows us to greatly reduce the number of values needed to express the force constants (by multiple orders of magnitude, discussed more below) and is therefore crucial for generalizing the TDEP to include higher order terms in the potential energy surface. The symmetries of the force constants are deduced from rotational and translational invariance of the system, in addition to the symmetries of the crystal itself. We start with the transposition symmetries, which is an invariance under the permutation of the indices: 4 3 \n\\begin{align}\n\\label{eq:firstsym}\\Phi_{ij}&#94;{\\alpha\\beta} &= \\Phi_{ji}&#94;{\\beta\\alpha} \\\\\n\\Phi_{ijk}&#94;{\\alpha\\beta\\gamma} = \\Phi_{ikj}&#94;{\\alpha\\gamma\\beta} = \\Phi_{jik}&#94;{\\beta\\alpha\\gamma}& =\n\\Phi_{jki}&#94;{\\beta\\gamma\\alpha} =\n\\Phi_{kij}&#94;{\\gamma\\alpha\\beta} =\n\\Phi_{kji}&#94;{\\gamma\\beta\\alpha}.\n\\end{align}\n All lattices belong to one of the 230 lattice space groups. The force constants should be invariant under these symmetry operations. Then, if two tensors are related by symmetry operation $S$ their components are related as follows: \n\\begin{align}\n\\Phi_{ij}&#94;{\\alpha\\beta} &= \n\\sum_{\\mu\\nu}\\Phi_{kl}&#94;{\\mu\\nu}\nS&#94;{\\mu\\alpha}S&#94;{\\nu\\beta}  \\\\\n\\Phi_{ijk}&#94;{\\alpha\\beta\\gamma} &= \n\\sum_{\\mu\\nu\\xi}\\Phi_{mno}&#94;{\\mu\\nu\\xi}\nS&#94;{\\mu\\alpha} S&#94;{\\nu\\beta} S&#94;{\\xi\\gamma}.\\\\\n\\end{align}\n where $S&#94;{\\alpha\\beta}$ is the proper or improper rotation matrix of the symmetry operation $S$. Naturally, this will also enforce the periodic nature of the lattice. Force constants also obey the translational invariance (acoustic sum rules): \n\\begin{align}\n\\sum_j \\mathbf{\\Phi}_{ij} & =0 \\quad \\forall\\, i \\\\\n\\sum_k \\mathbf{\\Phi}_{ijk} & =0 \\quad \\forall\\, i,j\n\\end{align}\n The rotational invariance gives \n\\begin{align}\n\\sum_i \\Phi_i&#94;\\alpha r_i&#94;\\beta & = \\sum_i \\Phi_i&#94;\\beta r_i&#94;\\alpha \\quad \\forall \\, \\alpha,\\beta \\\\\n\\sum_j \\Phi_{ij}&#94;{\\alpha\\beta} r_j&#94;\\gamma + \\Phi_i&#94;\\beta \\delta_{\\alpha\\gamma} & =\n\\sum_j \\Phi_{ij}&#94;{\\alpha\\gamma} r_j&#94;\\beta + \\Phi_i&#94;\\gamma \\delta_{\\alpha\\beta} \n\\quad \\forall \\, \\alpha,\\beta,\\gamma \\\\\n\\sum_k \\Phi_{ijk}&#94;{\\alpha\\beta\\gamma}r_k&#94;\\lambda +  \\Phi_{ij}&#94;{\\gamma\\beta} \\delta_{\\alpha\\lambda} + \\Phi_{ij}&#94;{\\alpha\\gamma} \\delta_{\\beta\\lambda} &=\n\\sum_k \\Phi_{ijk}&#94;{\\alpha\\beta\\lambda}r_k&#94;\\gamma +  \\Phi_{ij}&#94;{\\lambda\\beta} \\delta_{\\alpha\\gamma} + \\Phi_{ij}&#94;{\\alpha\\lambda} \\delta_{\\beta\\gamma} \n\\quad \\forall \\, \\alpha,\\beta,\\gamma,\\lambda \\\\\n\\end{align}\n And finally, the Huang invariances \n\\begin{align}\n[\\alpha\\beta,\\gamma\\lambda] & = \\sum_{ij} \\Phi_{ij}&#94;{\\alpha\\beta} r_{ij}&#94;\\gamma r_{ij}&#94;\\lambda \\\\\n[\\alpha\\beta,\\gamma\\lambda] & = [\\gamma\\lambda,\\alpha\\beta]\n\\end{align}\n Ensure that the second order forceconstants, when taken to the long-wavelength limit, result in the correct number of elastic constants. All the symmetry relations above are naturally satisfied by the force constants produced by this code. Effective Hamiltonian The traditional lattice dynamical Hamiltonian described above has severe limitations, in that it's deduced from the derivatives of zero temperature configuration of the crystal. The form of the Hamiltonian is however beneficial: the second order forceconstants produce an exactly solvable Hamiltonian and with phonon quasiparticles, and the higher order terms can be treated as perturbations. To extend the usefulness of this Hamiltonian, we give up the constraint that the force constants are derivatives of the zero temperature configurations. Instead, the force constant tensors are just parameters in an effective Hamiltonian that are left to be determined. Schematically, self-consistent or effective phonon theories can be split into two parts: the first part is revolves around how to sample the Born-Oppenheimer surface, the second part around how to use that data to produce an effective Hamiltonian. Sampling phase space The most straightforward way to sample the Born-Oppenheimer surface is to use molecular dynamics. This can be costly, although I provided some tools to make it faster: parallelizing over different random seeds combined with selective upsampling certainly makes it feasible. For systems with significant nuclear quantum effects, path integral molecular dynamics is preferred. The cost of these can be quite significant, but similar acceleration techniques can be used. If you care predominantly about speed, stochastic sampling might be preferred. The way the Born-Oppenheimer surface is sampled does not influence the TDEP algorithms in any way. I even consider stochastic sampling using the zero-point the preferred way of calculating the true zero temperature force constants. The only thing required of the sampling is that it provides a set of forces, $\\mathbf{f}&#94;{\\textrm{BO}}$, and displacements $\\mathbf{u}$. Obtaining an effective Hamiltonian The basic premise is to use a model Hamiltonian (where orders beyond pair interactions are optional) given by \n\\begin{equation}\\label{eq:hamiltonian}\n\\hat{H}= U_0+\\sum_i \\frac{\\textbf{p}_i&#94;2}{2m_i}+\n\\frac{1}{2!}\\sum_{ij} \\sum_{\\alpha\\beta}\\Phi_{ij}&#94;{\\alpha\\beta}\nu_i&#94;\\alpha u_j&#94;\\beta +\\frac{1}{3!}\n\\sum_{ijk} \\sum_{\\alpha\\beta\\gamma}\\Phi_{ijk}&#94;{\\alpha\\beta\\gamma}\nu_i&#94;\\alpha u_j&#94;\\beta u_k&#94;\\gamma \\ldots\n\\end{equation}\n and match the forces of the model, $\\mathbf{f}&#94;{\\textrm{M}}$ to $\\mathbf{f}&#94;{\\textrm{BO}}$. 7 , 6 , 5 A brute force minimization is certainly possible, but the current implementation is a bit more sophisticated. The forces of the model Hamiltonian are given by \n\\begin{equation}\nf&#94;{\\mathrm{M}}_{i\\alpha}=\n-\\sum_{j\\beta}\\Phi_{ij}&#94;{\\alpha\\beta}u_j&#94;\\beta\n-\\frac{1}{2}\\sum_{jk\\beta\\gamma}\\Phi_{ijk}&#94;{\\alpha\\beta\\gamma}u_j&#94;\\beta u_k&#94;\\gamma + \\ldots\n\\end{equation}\n To exploit the symmetry relations, we populate each tensor component with a symbolic variable, called $\\theta$. The index $k$ runs from 1 to the total number of components in all tensors. We include all tensors within a cutoff radius $\\textbf{r}_c$ (the maximum cutoff is determined by the simulation cell size). Using symmetries we figure out which tensor components are unique by accounting for those components that are either 0 or equal to another tensor component. This drastically reduces the number of values that have to be determined. With the symmetry irreducible representation at hand, we express the forces in the model Hamiltonian: \n\\begin{equation}\nf&#94;{\\mathrm{M}}_{i\\alpha}=\n\\sum_k \\theta_k c_k&#94;{i\\alpha}(\\mathbf{U}).\n\\end{equation}\n Here $c_k&#94;{i\\alpha}(\\mathbf{U})$, the coefficient for each $\\theta_k$ is a polynomial function of all displacements within $\\textbf{R}_c$. The form of this function depends on the crystal at hand (see the minimal example below). For a given supercell, we can express the vector of all forces in the cell as a matrix product: \n\\begin{equation}\n\\underbrace{\\mathbf{F}&#94;{\\mathrm{M}}}_{3N_a \\times 1}=\n\\underbrace{\\mathbf{C}(\\mathbf{u})}_{3N_a \\times N_{\\theta}}\n\\underbrace{\\mathbf{\\Theta}}_{N_{\\theta} \\times 1}\n\\end{equation}\n where the underbraces denote size of the matrices. The coefficient matrix $\\mathbf{C}$ is a function of all the displacements in the supercell. $\\mathbf{\\Theta}$ is a vector holding all the $\\theta_k$. Then we seek the $\\mathbf{\\Theta}$ that minimizes the difference between the model system and the ab initio one: \n\\begin{equation}\n\\begin{split}\n\\min_{\\Theta}\\Delta \\mathbf{F} & =\n\\frac{1}{N_c} \\sum_{c=1}&#94;{N_c}  \\left| \\mathbf{F}_c&#94;{\\textrm{BO}}-\\mathbf{F}_c&#94;{\\textrm{M}} \\right|&#94;2= \\\\\n& =\\frac{1}{N_c} \\sum_{c=1}&#94;{N_c} \\left| \\mathbf{F}_c&#94;{\\textrm{BO}}-\\mathbf{C}(\\mathbf{u}_{c})\\mathbf{\\Theta} \\right|&#94;2 = \\\\\n& = \\frac{1}{N_c} \\left\\Vert \n\\begin{pmatrix} \\mathbf{F}_1&#94;{\\textrm{BO}} \\\\  \\vdots \\\\ \\mathbf{F}_{N_c}&#94;{\\textrm{BO}} \\end{pmatrix}-\n\\begin{pmatrix} \\mathbf{C}(\\mathbf{u}_1) \\\\ \\vdots \\\\ \\mathbf{C}(\\mathbf{u}_{N_c}) \\end{pmatrix}\n\\mathbf{\\Theta}\n\\right\\Vert\n\\end{split}\n\\end{equation}\n Here $N_c$ is the number of supercell configurations used to sample the Born-Oppenheimer surface. A least squares solution, \n\\begin{equation}\n\\mathbf{\\Theta}=\n\\begin{pmatrix}\n\\mathbf{C}(\\mathbf{u}_1) \\\\\n\\vdots \\\\\n\\mathbf{C}(\\mathbf{u}_{N_c})\n\\end{pmatrix}&#94;{+}\n\\begin{pmatrix}\n\\mathbf{F}&#94;{\\textrm{BO}}_1 \\\\\n\\vdots \\\\\n\\mathbf{F}&#94;{\\textrm{BO}}_{N_c}\n\\end{pmatrix}\n\\end{equation}\n gives the $\\mathbf{\\Theta}$ that minimizes these forces. Then, with a simple substitution back into \\mathbf{\\Phi}_{ij} and $\\mathbf{\\Phi}_{ijk}$ we determine the quadratic and cubic force constants. Note all orders of force constants are extracted from the same set of displacements and forces, simultaneously.","tags":"","loc":"program/extract_forceconstants.html","title":"\n    \n        extract forceconstants – TDEP\n    \n"},{"text":"Short description This code serves as a diagnostic tool to check that symmetry heuristics are working as they should. The code prints which Bravais lattice was identified, which high symmetry points in the BZ are inequivalent, and so on. The Brillouin zone and its irreducible wedges are printed to files as polyhedra for manual inspection, and the symmetry operations of the lattice can be printed. Command line options: Optional switches: --printsymmetry default value .false. Also prints the symmetry operations --help , -h Print this help message --version , -v Print version Examples crystal_structure_info crystal_structure_info --printsymmetry Long summary This is mainly a diagnostic tool, to make sure that my heuristics are working as they should. For example, if you want to calculate fcc Al, and things look strange, run this code to make sure that the symmetry detection actually identifies it as fcc. As a bonus, the Brillouin zone and the irreducible wedge is printed to file, so that you can make figures like the one below. Input files infile.ucposcar Output files outfile.brillouin_zone.hdf5 This contains the information to produce the plot above. I did it with the following matlab snippet: % read all the stuff fn = 'outfile.brillouin_zone.hdf5' ; zone_nodes = h5read ( fn , '/zone_nodes' ) ' ; wedge_nodes = h5read ( fn , '/wedge_nodes' ) ' ; nf = h5readatt ( fn , '/' , 'number_of_zone_faces' ); for i = 1 : nf zone_faces { i }= h5read ( fn ,[ '/zone_face_' num2str ( i )]); end nf = h5readatt ( fn , '/' , 'number_of_wedge_faces' ); for i = 1 : nf wedge_faces { i }= h5read ( fn ,[ '/wedge_face_' num2str ( i )]); end labels = strsplit ( h5readatt ( fn , '/' , 'wedge_node_labels' )); figure ( 1 ); clf ; hold on ; axis equal off ; view ( 3 ); camlight ; i = drawPolyhedron ( zone_nodes , zone_faces ); set ( i , 'facealpha' , 0.3 ) j = drawPolyhedron ( wedge_nodes , wedge_faces ); set ( j , 'facealpha' , 0.3 , 'facecolor' , 'blue' ) for i = 1 : length ( labels ) text ( wedge_nodes ( i , 1 ), wedge_nodes ( i , 2 ), wedge_nodes ( i , 3 ), labels { i }) end This requires the Geom3D package. outfile.qpoints_dispersion This is a prototype version of infile.qpoints_dispersion , so that you don't have to start from nothing when changin the path. It can look like this: FCC                         ! Bravais lattice type\n  100                       ! Number of points on each path\n    4                       ! Number paths between special points\nGM  X                       ! Starting and ending special point\nX   U                       !\nK   GM                      !\nGM  L                       !","tags":"","loc":"program/crystal_structure_info.html","title":"\n    \n        crystal structure info – TDEP\n    \n"},{"text":"Short description Calculate phonon dispersions and related quantities. Per default, only the dispersions along a default path will be calculated. Options are available for calculating mode gruneisen parameters, phonon density of states projected in a variety of ways, thermodynamic quantities and pure data dumps. Command line options: Optional switches: --unit value , value in: thz,mev,icm default value thz Choose the output unit. The options are terahertz (in frequency, not angular frequency), inverse cm or meV. --loto default value .false. Add the corrections due to long-range electrostatic interactions, requires infile.lotosplitting Format is specified here . --nq_on_path value , -nq value default value 100 Number of q-points between each high symmetry point --readpath , -rp default value .false. Read the q-point path from infile.qpoints_dispersion . Use crystal structure into to generate an example. --dos default value .false. Calculate the phonon DOS --projected_dos_site default value .false. Project the phonon dos onto sites --projected_dos_mode default value .false. Print the phonon DOS per mode --qpoint_grid value#1 value#2 value#3 , -qg value#1 value#2 value#3 default value 26 26 26 Density of q-point mesh for Brillouin zone integrations. --meshtype value , value in: 1,2,3 default value 1 Type of q-point mesh. 1 Is a Monkhorst-Pack mesh, 2 an FFT mesh and 3 my fancy wedge-based mesh with approximately the same density the grid-based meshes. --sigma value default value 1.0 Global scaling factor for the Gaussian/adaptive Gaussian smearing. The default is determined procedurally, and scaled by this number. --readqmesh default value .false. Read the q-point mesh from file. To generate a q-mesh file, see the genkpoints utility. --integrationtype value , -it value , value in: 1,2,3 default value 2 Type of integration for the phonon DOS. 1 is Gaussian, 2 adaptive Gaussian and 3 Tetrahedron. --dospoints value default value 400 Number of points on the frequency axis of the phonon dos. --temperature value default value -1 Evaluate thermodynamic phonon properties at a single temperature. --temperature_range value#1 value#2 value#3 default value -1 -1 -1 Evaluate thermodynamic phonon properties for a series of temperatures, specify min, max and the number of points. --modevib default value .false. Write phonon entropies for each branch of the phonon dispersions. --sitevib default value .false. Write phonon entropy for each site in the unit cell. --gruneisen default value .false. Use third order force constants to calculate mode Gruneisen parameters. --dumpgrid default value .false. Write files with q-vectors, frequencies, eigenvectors and group velocities for a grid. --help , -h Print this help message --version , -v Print version Examples phonon_dispersion_relations phonon_dispersion_relations --dos -qgrid 24 24 24 -loto --integrationtype 2 This code calculates the phonon dispersions, $ \\omega(\\mathbf{q}) $. It can output dispersions along a line in the Brillouin zone, calculate the phonon DOS and all thermodynamic quantities accessible from that. In addition it can calculate the mode Grüneisen parameters. By default, very minimal input is needed, but many options to tailor the output exist. Make sure you familiarize yourself with the TDEP way of calculating free energy, it differs from what you might be familiar with from quasiharmonic theory. Equations of motion in a harmonic crystal As detailed in extract force constants we have mapped the Born-Oppenheimer to an effective potential. A model Hamiltonian truncated at the second order (a harmonic Hamiltonian) is given by 1 \n\\begin{equation}\n\\hat H=\\sum_i \\frac{\\mathbf{p}_i&#94;2}{2m_i} + \\frac{1}{2} \\sum_{ij}\\sum_{\\alpha\\beta}  \\Phi_{ij}&#94;{\\alpha\\beta} u&#94;{\\alpha}_{i} u&#94;{\\beta}_{j}\\,,\n\\end{equation}\n Ignoring surface effects, we can write the equations of motion for the ions independent of index $i$: \n\\begin{equation}\n\\ddot{\\mathbf{u}}_\\mu m_\\mu = \n-\\sum_{\\nu}\\sum_l \\mathbf{\\Phi}_{\\mu\\nu}(\\mathbf{R}_l&#94;{\\mu \\nu})\\mathbf{u}_{l\\nu}.\n\\end{equation}\n Here $\\mu,\\nu$ denote indices in the unit cell. The force constants are defined per set of lattice vectors for each combination of atoms $\\mu,\\nu$ in the unit cell. We assume a plane wave solution \n\\begin{equation}\n\\mathbf{u}_{\\mu}=\\frac{1}{m_\\mu} \\sum_{\\mathbf{q}} A_{\\mathbf{q}} \\epsilon_{\\mathbf{q}}&#94;{\\mu} e&#94;{ i\\mathbf{q} \\cdot \\mathbf{R}_l - \\omega t }.\n\\end{equation}\n Here the displacements are expressed as a sum of plane waves, or normal modes, each with wave vector $\\mathbf{q}$ and frequency $\\omega$. $\\epsilon$ is a polarisation vector, and $A_{\\mathbf{q}}$ the normal mode amplitude. Substituting this into the equation above and exploiting the orthogonality of planes waves gives, \n\\begin{equation}\n\\omega&#94;2(\\mathbf{q}) \\mathbf{\\epsilon}(\\mathbf{q})=\\mathbf{\\Phi}(\\mathbf{q})\\mathbf{\\epsilon}(\\mathbf{q})\\,,\n\\end{equation}\n where the periodic boundary conditions limit the choices of $\\mathbf{q}$ to a wave vector $\\mathbf{q}$ in the first Brillouin zone. The dynamical matrix is given by \n\\begin{equation}\n\\mathbf{\\Phi}(\\mathbf{q})=\n\\begin{pmatrix}\n\\mathbf{\\Phi}_{11}(\\mathbf{q}) & \\cdots & \\mathbf{\\Phi}_{N 1}(\\mathbf{q}) \\\\\n\\vdots & \\ddots & \\vdots \\\\\n\\mathbf{\\Phi}_{N 1}(\\mathbf{q}) & \\cdots & \\mathbf{\\Phi}_{N N}(\\mathbf{q}) \\\\\n\\end{pmatrix}\n\\end{equation}\n This is the Fourier transform of the force constant matrix, where each $3 \\times 3$ submatrix of the full $ 3N \\times 3N $ is given by \n\\begin{equation}\n\\mathbf{\\Phi}_{\\mu \\nu}(\\mathbf{q})=\n\\sum_{l}\n\\frac{ \\mathbf{\\Phi}_{\\mu\\nu}(\\mathbf{R}_l) }{\\sqrt{m_\\mu m_\\nu}}  \ne&#94;{i\\mathbf{q}\\cdot \\mathbf{R}_l}.\n\\end{equation}\n The frequencies (eigenvalues) have the same periodicity as the reciprocal lattice; hence it is convenient to limit the solution to all vectors $\\mathbf{q}$ in the first Brillouin zone. By calculating the eigenvalues and eigenvectors of the dynamical matrix over the Brillouin zone, all thermodynamic quantities involving the atomic motions can be determined, as far as the harmonic approximation is valid. Harmonic thermodynamics In the previous section, we treated the vibrations of atoms classically, by solving Newton's equations of motion. Quantum-mechanically, vibrational normal modes can be represented as quasi-particles called phonons, quanta of thermal energy. We note that our normal mode transformation is a sum over eigenfunctions of independent harmonic oscillators. This allows us to write the position and momentum operators in terms of creation and annihilation operators (without loss of generality, we can contract the notation for phonon mode $s$ at wave vector $\\mathbf{q}$ to a single index $\\lambda$): \n\\begin{align}\n\\hat{u}_{i\\alpha} = & \\sqrt{ \\frac{\\hbar}{2N m_\\alpha} }\n\\sum_\\lambda \\frac{\\epsilon_\\lambda&#94;{i\\alpha}}{ \\sqrt{ \\omega_\\lambda} }\ne&#94;{i\\mathbf{q}\\cdot\\mathbf{r}_i}\n\\left( \\hat{a}&#94;{\\mathstrut}_\\lambda + \\hat{a}&#94;\\dagger_\\lambda \\right) \\\\\n%\n\\hat{p}_{i\\alpha} = & \\sqrt{ \\frac{\\hbar m_\\alpha}{2N} }\n\\sum_\\lambda \\sqrt{ \\omega_\\lambda } \\epsilon_\\lambda&#94;{i\\alpha} \ne&#94;{i\\mathbf{q}\\cdot\\mathbf{r}_i-\\pi/2}\n\\left( \\hat{a}&#94;{\\mathstrut}_\\lambda - \\hat{a}&#94;\\dagger_\\lambda \\right)\n%\n\\end{align}\n and their inverse \n\\begin{align}\n\\hat{a}&#94;{\\mathstrut}_{\\lambda} = & \\frac{1}{\\sqrt{2N\\hbar}} \n\\sum_{i\\alpha} \\epsilon_\\lambda&#94;{i\\alpha}\ne&#94;{-i\\mathbf{q}\\cdot\\mathbf{r}_i} \\left( \\sqrt{m_i \\omega_\\lambda} \\hat{u}_{i\\alpha}-i \\frac{\\hat{p}_{i\\alpha}}{ \\sqrt{ m_i \\omega_\\lambda }} \\right) \\\\\n%\n\\hat{a}&#94;\\dagger_{\\lambda} = & \\frac{1}{\\sqrt{2N\\hbar}} \n\\sum_{i\\alpha} \\epsilon_\\lambda&#94;{i\\alpha}\ne&#94;{i\\mathbf{q}\\cdot\\mathbf{r}_i} \\left( \\sqrt{m_i \\omega_\\lambda} \\hat{u}_{i\\alpha}-i \\frac{\\hat{p}_{i\\alpha}}{ \\sqrt{ m_i \\omega_\\lambda }} \\right)\n\\end{align}\n In terms of these operators, the vibrational Hamiltonian can be written as \n\\begin{equation}\n\\hat{H}=\\sum_{\\lambda}\\hbar\\omega_\\lambda \\left( \\hat{a}&#94;\\dagger_\\lambda \\hat{a}&#94;{\\mathstrut}_\\lambda + \\frac{1}{2}\\right)\\,.\n\\end{equation}\n Since $\\hat{a}&#94;\\dagger_\\lambda \\hat{a}&#94;{\\mathstrut}_\\lambda$ are commutative operators, the Hamiltonian is that of a sum of uncoupled harmonic quantum oscillators, each having the partition function \n\\begin{equation}\nZ_{\\lambda}=\\sum_{n=0}&#94;{\\infty}e&#94;{-\\beta (n +\\frac{1}{2})\\hbar\\omega_{\\lambda} } =\n\\frac{ e&#94;{-\\beta \\hbar\\omega_{\\lambda}/2 } }{1-e&#94;{-\\beta \\hbar\\omega_{\\lambda}}}\n\\end{equation}\n that gives the total \n\\begin{equation}\nZ=\\prod_{\\lambda} \\frac{ e&#94;{-\\beta \\hbar\\omega_{\\lambda}/2 } }{1-e&#94;{-\\beta \\hbar\\omega_{\\lambda}}}.\n\\end{equation}\n From this we can get the Helmholtz (phonon) free energy: \n\\begin{equation}\nF_{\\textrm{ph}}= -k_B T \\ln Z = \\sum_{\\lambda} \\frac{\\hbar \\omega_{\\lambda}}{2}+k_B T%\n\\ln \\left( 1- \\exp \\left( -\\frac{\\hbar \\omega_{\\lambda}}{k_B T} \\right) \\right)\n\\end{equation}\n In the conventional quasiharmonic approximation, the total free energy of the system (not considering any terms pertaining to magnetic or configurational degrees of freedom) can be expressed as \n\\begin{equation}\n    F = F_{\\textrm{el}} + F_{\\textrm{ph}}\\,.\n\\end{equation}\n In the TDEP formalism it is not quite that simple. Determining the free energy with TDEP In the TDEP formalism, 4 , 3 , 2 with effective force constants, the phonon quasiparticles are different at each temperature. At fix temperature, they behave just like normal bosons, obeying Bose-Einstein statistics and so on. But changing the temperature will change both the occupation numbers and the states that are occupied. Moreover, in the harmonic approximation the baseline energy (with all atoms at their equilibrium positions) is that of the static lattice. With an effective Hamiltonian this baseline is a free parameter. The baseline shift is illustrated in the diagram below: The density depicts the phase space samples used to fit the effective Hamiltonian. The reference energy, or baseline, has been shifted with respect to zero temperature. This baseline is determined by matching the potential energies of the samples of the Born-Oppenheimer surface, $U_{BO}$, and the potential energy of the TDEP model Hamiltonian: \n\\begin{equation}\n\\begin{split}\n    \\left\\langle U_{\\textrm{BO}} - U_{\\textrm{TDEP}} \\right\\rangle & = \n    \\left\\langle U_{\\textrm{BO}} - U_0 -\\frac{1}{2} \\sum_{ij} \\sum_{\\alpha\\beta} \\Phi_{ij}&#94;{\\alpha\\beta} u&#94;{\\alpha}_i u&#94;{\\beta}_j  \\right\\rangle = 0 \\\\\n    U_0 & = \\left\\langle U_{\\textrm{BO}} - \\frac{1}{2} \\sum_{ij} \\sum_{\\alpha\\beta} \\Phi_{ij}&#94;{\\alpha\\beta} u&#94;{\\alpha}_i u&#94;{\\beta}_j \\right\\rangle\n\\end{split}\n\\end{equation}\n Intuitively, this can be interpreted as that the TDEP force constants are determined by matching forces between the real and model system, in a similar manner we match the energies as well. The new baseline is conveniently expressed as a shift: \n\\begin{equation}\n    \\Delta U = U_0-U_{\\textrm{stat}}\n\\end{equation}\n Where $U_{\\textrm{stat}}$ is the energy of the perfect lattice at 0K. The free energy is then (excluding configurational entropy, magnetic entropy etc.) \n\\begin{equation}\n    F = F_{\\textrm{el}} + F_{\\textrm{ph}} + \\Delta U_0\\,.\n\\end{equation}\n The entropy and heat capacity is not accessible from a single simulation. Since both the phonon free energy and baseline shift have non-trivial temperature dependencies, a series of calculations for different temperatures are needed, so that the entropy can be calculated via \n\\begin{equation}\n    S = -\\left.\\frac{dF}{dT}\\right|_V\n\\end{equation}\n A series of calculations on a volume-temperature grid is required to calculate Gibbs free energy, with pressure explicitly calculated as \n\\begin{equation}\n    P = -\\left.\\frac{dF}{dV}\\right|_T\n\\end{equation}\n Other dispersive properties We determine group velocities via the Hellman-Feynmann theorem: \n\\begin{equation}\n    \\nabla_{\\mathbf{q}} \\omega&#94;2_s = \\left\\langle \\epsilon_s(\\mathbf{q}) \\right| \\nabla_{\\mathbf{q}} \\Phi(\\mathbf{q})  \\left| \\epsilon_s(\\mathbf{q}) \\right\\rangle\n\\end{equation}\n where \n\\begin{equation}\n\\frac{\\partial \\mathbf{\\Phi}_{\\mu\\nu}(\\mathbf{q})}{\\partial q_\\alpha}\n    =\n    \\sum_l\n    \\frac{\\partial }{\\partial q_\\alpha}\n    \\frac{ \\mathbf{\\Phi}_{\\mu\\nu}(\\mathbf{R}_l) }{\\sqrt{m_\\mu m_\\nu}}\n    e&#94;{ i \\mathbf{q} \\cdot \\mathbf{R}_l }\n    =\n    \\sum_l\n    R_{l}&#94;\\alpha\n    \\frac{ \\mathbf{\\Phi}_{\\mu \\nu}(\\mathbf{R}_l) }{\\sqrt{m_\\mu m_\\nu}}\n    e&#94;{ i \\mathbf{q} \\cdot \\mathbf{R}_l }\n\\end{equation}\n and \n\\begin{equation}\n\\mathbf{v}_{\\mathbf{q}s} = \\nabla_{\\mathbf{q}} \\omega_s(\\mathbf{q})=\n\\frac{1}{2\\omega_s} \\nabla_{\\mathbf{q}} \\omega_s&#94;2(\\mathbf{q})\n\\end{equation}\n The only complications in using this expression is at wave vectors with degenerate frequencies, in those cases one has to average over the small group of the wave vector to obtain consistent group velocities. The mode Grüneisen parameters are a measure of the sensitivity of the vibrational frequencies to volume changes. They are given by \n\\begin{equation}\n\\gamma_{\\mathbf{q}s}=-\\frac{V}{\\omega_{\\mathbf{q}s}}\\frac{\\partial \\omega_{\\mathbf{q}s}}{\\partial V}\n\\end{equation}\n where $V$ is the volume and $\\omega_{\\mathbf{q}s}$ is the frequency of mode $s$ at wave vector $\\mathbf{q}$. $\\gamma_{\\mathbf{q}s}$ can be obtained either by numerical differentiation of the phonon dispersion relations or from the third order force constants based on a perturbation approach: \n\\begin{equation}\n\\gamma_{\\mathbf{q}s}=-\\frac{1}{6\\omega_{\\mathbf{q}s}&#94;2}\\sum_{ijk\\alpha\\beta\\gamma}\n\\frac{\\epsilon_{i\\alpha}&#94;{\\mathbf{q}s*} \\epsilon_{j\\beta}&#94;{\\mathbf{q}s}}\n{\\sqrt{m_i m_j}}\nr_k&#94;\\gamma \\Phi_{ijk}&#94;{\\alpha\\beta\\gamma}e&#94;{i\\mathbf{q}\\cdot\\ \\mathbf{r}_j}\n\\end{equation}\n Here $\\epsilon_{i\\alpha}&#94;{\\mathbf{q}s}$ is component $\\alpha$ associated eigenvector $\\epsilon$ for atom $i$. $m_i$ is the mass of atom $i$, and $\\mathbf{r}_i$ is the vector locating its position. Todo Add general description about numerical integration types somewhere. Input files infile.ucposcar infile.forceconstant Optional files: infile.qpoints_dispersion (to specify a path for the phonon dispersions) infile.lotosplitting (including the electrostatic corrections) infile.forceconstant_thirdorder (for the Grüneisen parameter) Output files Depending on options, the set of output files may differ. We start with the basic files that are written after running this code. outfile.dispersion_relations This file contains a list of $q$ points (in 1/Å) according to the chosen path (default or specified by the user in infile.qpoints_dispersions ) and the frequencies per mode (in the specified units via --unit ) for the corresponding points. Row Description 1  q_1 \\qquad \\omega_1 \\qquad \\omega_2 \\qquad \\ldots \\qquad \\omega_{3N_a}  2  q_2 \\qquad \\omega_1 \\qquad \\omega_2 \\qquad \\ldots \\qquad \\omega_{3N_a}  ... ... Not that the first column is for plotting purposes only. It serves to ensure that each line segment is scaled properly, since each segment contains a fix number of points. outfile.group_velocities This file contains the norm of the group velocities as a function of q. Format is identical to that of the dispersions: Row Description 1  q_1 \\qquad |v_1| \\qquad |v_2| \\qquad \\ldots \\qquad |v_{3N_a}|  2  q_2 \\qquad |v_1| \\qquad |v_2| \\qquad \\ldots \\qquad |v_{3N_a}|  ... ... The units are in km/s. outfile.mode_gruneisen_parameters In case you used --gruneisen , the mode Grüneisen parameters will be written, in a format similar to the dispersions and group velocities: Row Description 1 $ q_1 \\qquad \\gamma_1 \\qquad \\gamma_2 \\qquad \\ldots \\qquad \\gamma_{3N_a} $ 2 $ q_2 \\qquad \\gamma_1 \\qquad \\gamma_2 \\qquad \\ldots \\qquad \\gamma_{3N_a} $ ... ... The units are in km/s. outfile.phonon_dos The first column is the list of frequencies and the second column in the density of states for this frequency, given in arbitrary units. Note that integrated density of states is normalized. One can calculate partial density of states ( --projected_dos_mode ); if the user specifies this option, an extra column will be added into the outfile.phonon_dos file for each type of atom. With --projected_dos_site the same thing happens but with an extra column for each atom in the unit cell. Row Description 1 $ \\omega_1 \\qquad g(\\omega_1) \\qquad g_1(\\omega_1) \\qquad \\ldots \\qquad g_{N}(\\omega_1) $ 2 $ \\omega_2 \\qquad g(\\omega_2) \\qquad g_1(\\omega_2) \\qquad \\ldots \\qquad g_{N}(\\omega_2) $ ... ... The units are in states per energy unit, depending on choice of --unit . The total DOS normalizes to 3N independent of choice of unit. outfile.free_energy If one chooses the option --temperature_range or --temperature then this file will display a list of temperatures with corresponding temperatures, vibrational free energies, vibrational entropies and heat capacities. Row Description 1 $ T_1 \\qquad F_{\\textrm{vib}} \\qquad S_{\\textrm{vib}} \\qquad C_v $ 2 $ T_2 \\qquad F_{\\textrm{vib}} \\qquad S_{\\textrm{vib}} \\qquad C_v $ ... ... Temperature is given in K,  F_{\\textrm{vib}}  in eV/atom,  S_\\textrm{vib}  in eV/K/atom and heat capacity in eV/K/atom. outfile.mode_vibentropies Using --modevib gives the mode-projected vibrational entropies: Row Description 1  T_1 \\qquad S_{1} \\qquad S_{2} \\qquad \\ldots \\qquad S_{3N_a}  2  T_1 \\qquad S_{1} \\qquad S_{2} \\qquad \\ldots \\qquad S_{3N_a}  ... ... Where all entropies are in eV/K/atom. outfile.site_vibentropies Using --sitevib gives the site-projected vibrational entropies: Row Description 1  T_1 \\qquad S_{1} \\qquad S_{2} \\qquad \\ldots \\qquad S_{N_a}  2  T_1 \\qquad S_{1} \\qquad S_{2} \\qquad \\ldots \\qquad S_{N_a}  ... ... The first column is the temperature, followed by one column per atom. All entropies are in eV/K/atom. outfile.grid_dispersions.hdf5 Using option --dumpgrid writes all phonon properties for a grid in the BZ to an hdf5 file, that is self-documented. Born, M., & Huang, K. (1964). Dynamical theory of crystal lattices. Oxford: Oxford University Press. ↩ Hellman, O., Abrikosov, I. A., & Simak, S. I. (2011). Lattice dynamics of anharmonic solids from first principles. Physical Review B, 84(18), 180301. ↩ Hellman, O., & Abrikosov, I. A. (2013). Temperature-dependent effective third-order interatomic force constants from first principles. Physical Review B, 88(14), 144301. ↩ Hellman, O., Steneteg, P., Abrikosov, I. A., & Simak, S. I. (2013). Temperature dependent effective potential method for accurate free energy calculations of solids. Physical Review B, 87(10), 104111. ↩","tags":"","loc":"program/phonon_dispersion_relations.html","title":"\n    \n        phonon dispersion relations – TDEP\n    \n"},{"text":"Short description Calculates properties of the atomic distribution from molecular dynamics, such as mean square displacement, pair distribution function, vector distribution functions and probability densities. Useful for analysing simulations close to instabilities/phase transitions to have some idea where the atoms are. Command line options: Optional switches: --cutoff value , -r value default value 5.0 Consider pairs up to this distance, in A. --nbins value , -n value default value 200 Number of bins in each dimension. --notransform default value .false. Do no rotate the coordinate systems of the vector distribution. By default, the coordinate system is aligned with the positive x-direction in the direction of the bond. --bintype value , value in: 1,2,3 default value 1 Select the binning type for the vector distribution. 1 is straight binning (fastest), 2 is binning with a Gaussian, 3 is binning with a gaussian, but without the subpixel resolution. --stride value , -s value default value 1 Use every N configuration instead of all. --help , -h Print this help message --version , -v Print version Examples atomic_distribution --cutoff 4.3 atomic_distribution --cutoff 4.3 --notransform Long description When using molecular dynamics, there are several ways to analyse the trajectories. This code implements a few of them. The TDEP method was originally meant to deal with dynamically unstable systems. It turns out the the most common problem for users was that the atoms did something during the simulation: what they thought was bcc Ti was no longer bcc Ti, but some halfway phase on it's way to transition to something. So, before trying to get phonons and free energies and other things, it it useful to make sure that what is in your simulation box actually is what you think it is. A number of diagnostics is provided here. Some background The easiest measure is the mean square displacement: \n\\textrm{msd}(t) = \\frac{1}{N} \\sum_i \\left| \\mathbf{r}_i(t)-\\mathbf{r}_i(0) \\right|&#94;2\n where $\\mathbf{r}_i(t)$ is the position of atom $i$ at time $t$. \nHaving established that the system is at least still a solid we can look at the radial distribution function (or pair correlation function), defined as \ng(r) = \\frac{ n(r) }{\\rho 4 \\pi r&#94;2 dr}\n where $\\rho$ is the mean particle density, and $n(r)$ the number of particles in an infinitesimal shell of width $dr$. Usually, this is averaged over all atoms in the system. In this code, I project it onto symmetrically equivalent pairs, yielding a projected pair distribution: \ng_i(r) = {\\rho 4 \\pi r&#94;2 dr} \\sum_i \\delta\\left( \\left|r_i\\right|-r \\right)\n where the index $i$ corresponds to a coordination shell. The coordination shell is defined from the ideal lattice as set of pairs that can transform to each other via a spacegroup operation. Naturally, the sum over all projected PDFs yield the total. Above is an example for ScF 3 . The peaks are well defined per pair, indicating that the system is still crystalline. In the projected picture, each coordination shell contributes one peak. Should on peak deviate strongly from a gaussian, it probably means that the system has undergone some internal shifts of the coordinates, altering the symmetry. This code also calculates the vector distribution function, essentially three-dimensionsonal histograms of pair vectors. Schematically, it works like this: first I identify the symmetry inequivalent pair coordination shells (turqoise and blue arrows below). Each pair in the simulation cell gets a transformation associated with it (dashed lines) that takes them to the prototype vectors (connecting the dark blue atoms) With these transformation rules, every pair from every timestep gets transformed, and binned in a histogram. The histogram is attached to the ideal bond, so that the origin coincides with the equilibrium pair vector. The coordinate system is also rotated such that the positive $z$-direction coincides with the pair vector, see the sketch below. The blue dots represent samples from pairs associated with blue vectors above, same for the green dots. This results in three-dimensional distributions of pair vectors, one for each symmetry-distinct pair. This is a measure related to the pair correlation functions, but spatially resolved. If the distribution is given by $n(\\mathbf{r})$, integrating this over spherical shells gives the pair correlation function described above. Using the same example as above, ScF 3 , isosurfaces of the distribution look like this for the nearest neighbour Sc-F pair: Input files infile.ucposcar infile.ssposcar infile.meta infile.stat infile.positions infile.forces Output files outfile.mean_square_displacement.hdf5 The hdf file is self-explainatory. In addition, a plain-text outfile.mean_square_displacement is written with Row Description 1  t_1 \\qquad \\textrm{msd}(t_1) \\qquad \\textrm{msd}_1(t_1) \\qquad \\ldots \\qquad \\textrm{msd}_{N_a}(t_1)  2  t_2 \\qquad \\textrm{msd}(t_2) \\qquad \\textrm{msd}_1(t_2) \\qquad \\ldots \\qquad \\textrm{msd}_{N_a}(t_2)  ... ... Where the columns are time (in fs), mean square displacement (in Å 2 ), followed by the partial mean square displacement per unique atom. outfile.pair_distribution_function.hdf5 The hdf file is self-explainatory. Below is a matlab snippet that produces the plot above clear all ; % filename fn = 'outfile.pair_distribution_function.hdf5' ; % number of unique atoms na = h5readatt ( fn , '/' , 'number_unique_atoms' ); % the total x = h5read ( fn , '/r_axis' ); y = h5read ( fn , '/radial_pair_distribution_function' ); % the projected for i = 1 : na xx { i }= h5read ( fn ,[ '/projected_r_axis_' num2str ( i )]); yy { i }= h5read ( fn ,[ '/projected_pair_distribution_function_atom_' num2str ( i )]); end figure ( 1 ); clf ; hold on ; box on ; % plot the total plot ( x , y ) % plot the projected for i = 1 : na for j = 1 : size ( xx { i }, 1 ) plot ( xx { i }( j ,:), yy { i }( j ,:)) end end set ( gca , 'xminortick' , 'on' , 'yminortick' , 'on' ) xlabel ( 'Distance (A)' ) ylabel ( 'g(r)' ) and an equivalent snippet using matplotlib: import matplotlib.pyplot as plt import numpy as np import h5py as h5 # open the sqe file f = h5 . File ( 'outfile.pair_distribution_function.hdf5' , 'r' ) # the total x = np . array ( f . get ( 'r_axis' )) y = np . array ( f . get ( 'radial_pair_distribution_function' )) plt . plot ( x , y ) # the projected na = f . attrs . get ( 'number_unique_atoms' ) for i in range ( na ): x = np . array ( f . get ( 'projected_r_axis_' + str ( i + 1 ))) y = np . array ( f . get ( 'projected_pair_distribution_function_atom_' + str ( i + 1 ))) for j in range ( x . shape [ 1 ]): plt . plot ( x [:, j ], y [:, j ]) plt . xlabel ( \"Distance (A)\" ) plt . ylabel ( \"g(r)\" ) plt . show () outfile.vector_distribution.hdf5 This file contains all the vector distribution histograms, the prototype vectors, the transformations to the correct coordinate systems and so on. The file is self-documented. The following is the matlab snippet used to create the plot above: % file fn = 'outfile.vector_distribution.hdf5' ; % focus on one distribution, get the histogram gv = h5read ( fn , '/distribution_atom_1_shell_2' ); % and the coordinates for the bin-centers x = h5readatt ( fn , '/distribution_atom_1_shell_2' , 'bincenters' ); % grids for plotting (always uniform) [ gx , gy , gz ]= meshgrid ( x , x , x ); figure ( 1 ); clf ; hold on ; % number of isosurfaces niv = 6 ; % values for the isosurfaces iv = exp ( linspace ( log ( 0.01 ), log ( 1.5 ), niv ) ); subplot ( 1 , 2 , 1 ); hold on ; for i = 1 : niv p = patch ( isosurface ( gx , gy , gz , gv , iv ( i ))); isonormals ( gx , gy , gz , gv , p ) p . FaceColor = [ 0.7 0.1 0.1 ]; p . EdgeColor = 'none' ; alpha ( p , 0.25 ); end daspect ([ 1 1 1 ]) view ([ 0 1 ]) camlight ; lighting phong xlabel ( 'x' ) ylabel ( 'y' ) zlabel ( 'z' ) subplot ( 1 , 2 , 2 ); hold on ; for i = 1 : length ( iv ) p = patch ( isosurface ( gx , gy , gz , gv , iv ( i ))); isonormals ( gx , gy , gz , gv , p ) p . FaceColor = [ 0.7 0.1 0.1 ]; p . EdgeColor = 'none' ; alpha ( p , 0.25 ); end daspect ([ 1 1 1 ]) view ([ 0 0 1 ]) camlight ; lighting phong : xlabel ( 'x' ) ylabel ( 'y' ) zlabel ( 'z' ) Note I could not figure out an easy way to get decent-looking isosurfaces in matplotlib. Please tell me if you manage.","tags":"","loc":"program/atomic_distribution.html","title":"\n    \n        atomic distribution – TDEP\n    \n"},{"text":"Short description Calculates the lattice thermal conductivity from the iterative solution of the phonon Boltzmann equation. In addition, cumulative plots and raw data dumps of intermediate values are available. Command line options: Optional switches: --readiso default value .false. Read the isotope distribution from infile.isotopes . The format is specified here . --qpoint_grid value#1 value#2 value#3 , -qg value#1 value#2 value#3 default value 31 31 31 Density of q-point mesh. --sigma value default value 1.0 Global scaling factor for adaptive Gaussian smearing. --threshold value default value 4.0 Consider a Gaussian distribution to be 0 after this many standard deviations. --readqmesh default value .false. Read the q-point mesh from file. --loto default value .false. Add the corrections due to long-range electrostatic interactions. --integrationtype value , -it value , value in: 1,2,3 default value 2 Type of integration for the lifetimes. 1 is fix Gaussian, 2 adaptive Gaussian and 3 Tetrahedron. --temperature value default value -1 Evaluate thermal conductivity at a single temperature. --temperature_range value#1 value#2 value#3 default value 100 300 5 Series of temperatures for thermal conductivity. Specify min, max and the number of points. --logtempaxis default value .false. Space the temperature points logarithmically instead of linearly. --tau_boundary value default value -1 Add a constant boundary scattering term to the lifetimes. --max_mfp value default value -1 Add a limit on the mean free path as an approximation of domain size. --dumpgrid default value .false. Write files with q-vectors, frequencies, eigenvectors and group velocities for a grid. --thinfilm default value .false. Calculate the suppression of kappa from in a thin film. --help , -h Print this help message --version , -v Print version Examples mpirun thermal_conductivity --temperature 300 mpirun thermal_conductivity -qg 15 15 15 --temperature_range 200 600 50 mpirun thermal_conductivity --integrationtype 3 -qg 30 30 30 --max_mfp 1E-6 Longer summary Heat transport can be determined by solving the inelastic phonon Boltzmann equation. By applying a temperature gradient $\\nabla T_\\alpha$ in direction $\\alpha$, the heat current is given by the group velocities of phonon mode $\\lambda$ and non-equilibrium phonon distribution function $\\tilde{n}_\\lambda$: 2 \n\\begin{equation}\nJ_{\\alpha}=\\frac{1}{V}\\sum_\\lambda\n\\hbar \\omega_\\lambda v_{\\lambda\\alpha} \\tilde{n}_{\\lambda\\alpha}.\n\\end{equation}\n Assuming the thermal gradient is small, the non-equilibrium distribution function can be linearised as, \n\\tilde{n}_{\\lambda\\alpha} \\approx n_{\\lambda}-\nv_{\\lambda\\alpha}\n\\tau_{\\lambda\\alpha}\n\\frac{d n_{\\lambda}}{d T}\n\\frac{d T}{d \\alpha} \\, ,\n That is a linear deviation from the equilibrium distribution function $n_{\\lambda}$. Inserting this into the equation 1, and exploiting the fact that the equilibrium occupation carries no heat, we arrive at, \nJ_{\\alpha}=\\frac{1}{V}\\sum_{\\lambda}\n\\hbar \\omega_{\\lambda}\n\\frac{d n_{\\lambda}}{d T}\nv_{\\lambda\\alpha}\nv_{\\lambda\\alpha}\n\\tau_{\\lambda\\alpha}\n\\frac{d T}{d \\alpha}.\n Utilizing Fourier's law, $J=\\kappa \\nabla T$, and identifying the phonon heat capacity, \nc_{\\lambda}=\n\\hbar \\omega_\\lambda\n\\frac{d n_{\\lambda}}{d T},\n we arrive at, \n\\kappa_{\\alpha\\beta}=\\frac{1}{V} \\sum_{\\lambda}\nc_{\\lambda}\nv_{\\alpha \\lambda}v_{\\beta \\lambda} \\tau_{\\beta \\lambda},\n which can be interpreted as follows: the heat transported by each phonon will depend on how much heat it carries, how fast it travels, and how long it lives. The phonon-phonon induced lifetime can be determined from the self-energy $\\Gamma_{\\lambda}$. In addition, one must consider the scattering with mass impurities (isotopes), and the boundaries of the sample. Lifetimes With the third order force constants we can calculate the phonon lifetimes needed as input to the thermal conductivity calculations. The lifetime due to phonon-phonon scattering is related to the imaginary part of the phonon self energy ( $\\Sigma=\\Delta+i\\Gamma$ ). \n\\frac{1}{\\tau_{\\lambda}}=2 \\Gamma_{\\lambda},\n where $\\tau_{\\lambda}$ is the lifetime phonon mode $\\lambda$, and \n\\begin{split}\n\\Gamma_{\\lambda}=& \\frac{\\hbar \\pi}{16} % _{\\lambda'}\n\\sum_{\\lambda'\\lambda''}\n\\left|\\Phi_{\\lambda\\lambda'\\lambda''}\\right|&#94;2 \n\\bigl[(n_{\\lambda'}+n_{\\lambda''}+1)\n\\delta(\\omega_{\\lambda}-\\omega_{\\lambda'}-\\omega_{\\lambda''}) \\\\\n+ & 2(n_{\\lambda'}-n_{\\lambda''})\n\\delta(\\omega_{\\lambda}-\\omega_{\\lambda'}+\\omega_{\\lambda''}) \\bigr]\n\\end{split}\n $n_{\\lambda}$ is the equilibrium occupation number. The sum is over momentum conserving three-phonon processes, $\\textbf{q}+\\textbf{q}'+\\textbf{q}''=\\textbf{G}$, and the deltafunctions in frequency ensure energy conservation. The three-phonon matrix elements are given by \n\\Phi_{\\lambda\\lambda'\\lambda''} = \n\\sum_{ijk}\n\\sum_{\\alpha\\beta\\gamma}\n\\frac{\n\\epsilon_{\\lambda}&#94;{i \\alpha}\n\\epsilon_{\\lambda'}&#94;{j \\beta}\n\\epsilon_{\\lambda''}&#94;{k \\gamma}\n}{\n\\sqrt{m_{i}m_{j}m_{j}}\n\\sqrt{\n    \\omega_{\\lambda}\n    \\omega_{\\lambda'}\n    \\omega_{\\lambda''}}\n}\n\\Phi&#94;{\\alpha\\beta\\gamma}_{ijk}\ne&#94;{i \\mathbf{q}\\cdot\\mathbf{r}_i + i \\mathbf{q}'\\cdot\\mathbf{r}_j+i \\mathbf{q}''\\cdot\\mathbf{r}_k}\n where $m_i$ is the mass of atom $i$, $\\epsilon_{\\lambda}&#94;{\\alpha i}$ is component $\\alpha$ of the eigenvector for mode $\\lambda$ and atom $i$ and $\\textbf{r}_i$ is the lattice vector associated with atom $i$. Mass disorder, in the form of natural isotope distributions also cause thermal resistance. According to Tamura 5 , if the isotopes are randomly distributed on the lattice sites then the strength of the isotope scattering can be given by a mass variance parameter $g$: \ng_i=\\sum_j c_{i}&#94;j \\left(\\frac{m_i&#94;j-\\bar{m_i}}{\\bar{m_i}}\\right)&#94;2 \n where $\\bar{m_i}$ is the average isotopic mass( $\\bar{m_i}=\\sum_j c_i&#94;j m_i&#94;j$ ), $m&#94;j_i$ is the mass of isotope $j$ of atom $i$ and $c&#94;j_i$ is its concentration. The ontribution to the imaginary part of the self-energy is \n\\Gamma&#94;{\\textrm{iso}}_{\\lambda}=\n\\frac{\\pi}{4} \\sum_{\\lambda'}\n\\underbrace{\\omega_{\\lambda}\\omega_{\\lambda'} \\sum_i g_i \\left| \\epsilon_{\\lambda}&#94;{i \\dagger} \\epsilon_{\\lambda'}&#94;{i} \\right|&#94;2}_{\\Lambda_{\\lambda\\lambda'}}\n\\delta(\\omega_{\\lambda}-\\omega_{\\lambda'})\n Per default, the isotope distribution will be the natural distribution. In case some other distribution is desired, this can be specified. Scattering by domain boundaries is implemented as \n\\Gamma&#94;{\\textrm{boundary}}_{\\lambda} = \\frac{ v_{\\lambda} }{2d}\n Where $d$ is a characteristic domain size. Beyond the relaxation time approximation So far we have have considered the phonon heat conduction as an elastic process, whereas it is inelastic. This can be treated by iteratively solving the phonon boltzmann equation, formulated in terms of the (linear) deviations from equilibrium occupation numbers. 1 , 6 , 7 , 8 , 9","tags":"","loc":"program/thermal_conductivity.html","title":"\n    \n        thermal conductivity – TDEP\n    \n"},{"text":"Short description Choose representative uncorrelated samples from an MD simulation. The samples are chosen to be approximately evenly spaced, and reproduce the average potential energy, average kinetic energy have the same standard deviation of potential and kinetic energy. Command line options: Optional switches: --nsamples value , -n value default value 50 Number of samples --help , -h Print this help message --version , -v Print version Examples samples_from_md -n 100 Longer summary When performing BOMD the numerical accuracy of the DFT calculations at each time step is usually lower than that of static calculations. In many cases one needs higher accuracy than is affordable for BOMD because it is so computationally demanding. TDEP requires accurate energies and forces. Well converged DFT calculations from a BOMD run are far too costly to achieve a sufficient phase space sampling. If one instead performs BOMD calculations with low accuracy we can sample phase space well. From these low accuracy calculations we choose a set of $n$ uncorrelated samples and correct scalar parameter $a$ as \n\\begin{equation}\na = <a&#94;l> + \\frac{1}{n}\\sum_{i=1}&#94;n a&#94;h_i-a_i&#94;l,\n\\end{equation}\n where $a&#94;l$ are the low accuracy calculations and $a&#94;h$ are calculations done with high accuracy. This exploits the fact that most omissions of numerical accuracy, such as basis set and k-point selection, lead to additive errors. This technique is well suited to determine the interatomic force constants and resulting thermodynamic/transport properties with high accuracy. When it comes to quantities that are not scalar the method is just as useful. In systems that are nearly harmonic the number of uncorrelated configurations needed for convergence of the extracted force constants (and by extension the free energy) is rather low. In these cases the force constant matrices can be extracted from the upsampled configurations alone. In systems that are strongly anharmonic one needs a much denser sampling of phase space to converge; sometimes convergence requires such high density that it is impractical to upsample. The procedure still gives us some important insights: the errors in forces due to low accuracy are normally distributed around the converged values, and the standard deviation depends only weakly on the magnitude of the force. Because the errors are normally distributed around the fully converged values one can compensate for low accuracy with large numbers of less accurate calculations. The extracted force constants will converge to the same value. Tests have confirmed this visually, showing that phonon dispersion relations agree within line thickness. Convergence with respect to the number of uncorrelated configurations is slower in the low accuracy case, but sometimes it is the only option. We also see that sampling forces at a thermally excited state is numerically beneficial. With the absolute error in forces weakly depending on the magnitude the relative error in forces behaves as $\\sim|F|&#94;{-1}$. Todo We can show the histograms of the force magnitudes in FeV, together with the relative error in forces. We compare forces obtained from BOMD to the small displacement method. The small displacement method samples forces at magnitudes where the relative errors is about two orders of magnitude larger than at a thermally relevant state. So not only do we better describe the physics at high temperature, we do it in a numerically superior manner. Todo Add some some figures from my thesis. This code selects a choice of uncorrelated samples from BOMD via a Monte-Carlo algorithm, assuring the selection is completely random. We start with a calculation of average potential $E_p$, kinetic energies $E_k$, and their standard deviation. We check the distance between samples assuring that chosen samples are not temporally adjacent. The results of this procedure is written in output files ( outfile.stat_sample ). The average values and distance between selected points depend on the number of desired samples. Todo should I write more about Monte carlo? Input files infile.ucposcar infile.ssposcar infile.meta infile.stat infile.positions infile.forces Output files This code will generate a series of structures given in VASP POSCAR format with positions in fractional coordinates and velocities in Å/fs. Todo Add support for other codes as output format.","tags":"","loc":"program/samples_from_md.html","title":"\n    \n        samples from md – TDEP\n    \n"},{"text":"Short description Takes a set of forceconstants and a unit cell and outputs them for a different unit cell. The lattices must be equivalent, and if the new lattice is rotated with respect to old the rotation matrix has to be specified. Command line options: Optional switches: --help , -h Print this help message --version , -v Print version Examples remap_forceconstant Longer summary Todo Actually write this What should be here explain how my force constant structure works, and how it can be remapped. emphasize that there is no particular cell attached to a forceconstant. one simple example, fcc primitive to fcc conventional. one more annoying, take the one with fcc as a hexagonal cell.","tags":"","loc":"program/remap_forceconstant.html","title":"\n    \n        remap forceconstant – TDEP\n    \n"},{"text":"Short description Calculate the frequency-dependent self-energy and phonon spectral function from many-body perturbation theory. Per default, the self-energy is calculated for a single q-point, but can be calculated along a path in the Brillouin zone for intensity plots, or as a phonon density of states. Command line options: Optional switches: --unit value , value in: thz,mev,icm default value thz Choose the output unit. The options are terahertz (in frequency, not angular frequency), inverse cm or meV. --loto default value .false. Add the corrections due to long-range electrostatic interactions, requires infile.lotosplitting Format is specified here . --temperature value default value 300 Temperature used in the occupation numbers. Should be the same as the temperature the force constants where determined at. --n_energies value , -ne value default value 600 Number of energies for the energy-dependent self-energy. --qpoint_grid value#1 value#2 value#3 , -qg value#1 value#2 value#3 default value 26 26 26 Density of q-point mesh for Brillouin zone integrations. --integrationtype value , -it value , value in: 1,2,3 default value 2 Type of integration for the phonon DOS. 1 is Gaussian, 2 adaptive Gaussian and 3 Tetrahedron. --sigma value default value 1.0 Global scaling factor for the Gaussian/adaptive Gaussian smearing. The default is determined procedurally, and scaled by this number. --path default value .false. Calculate the self-energy and spectral function on a path through the BZ. --readpath , -rp default value .false. Read the q-point path from infile.qpoints_dispersion . Use crystal structure into to generate an example. --nq_on_path value , -nq value default value 100 Number of q-points between each high symmetry point --dos default value .false. Calculate the broadened and shifted phonon DOS. --dos_qpoint_grid value#1 value#2 value#3 default value -1 -1 -1 Interpolate to a (preferrably) denser q-mesh when calculating the DOS. --qpoint value#1 value#2 value#3 default value 0 0 0 Calculate the self-energy at a single q-point, input in fractional coordinates. --highsymmetrypoint value default value none Samy as above, but you can specify the label of a high-symmetry point instead, e.g. \"X\" or \"L\". --max_energy value default value 1.4 Maximum energy where the output is cut off, in multiples of the maximum harmonic frequency. --no_isotope_scattering default value .false. Switch off isotope (mass disorder) scattering --no_thirdorder_scattering default value .false. Switch of three-phonon scattering --fourthorder default value .false. Consider four-phonon contributions to the real part of the self-energy. --readiso default value .false. Read the isotope distribution from file --help , -h Print this help message --version , -v Print version Examples lineshape --highsymmetrypoint X --temperature 500 lineshape --path -qg 10 10 10 --noisotope lineshape --dos -qg 10 10 10 --dos_qpoint_grid 24 24 24 Long summary This code calculates the energy-dependent self energy from three-phonon scattering, as well as the contributions from mass imperfections and four-phonon scattering. It can produce nice figures like this: Todo Nice picture of S(Q,E) Background It is nowadays routine to calculate e.g. lattice thermal conductivity using perturbation theory. At that level of approximation, you calculate the phonon lifetime via the imaginary part of the phonon self-energy at the harmonic frequencies. In general, however, the picture with a well defined phonon, shifted by a small energy $ \\Delta $ and broadened by $ \\Gamma $ is not enough. In general, the phonon self-energy is energy-dependent, 1 , 2 \n\\begin{equation}\n\\Sigma(\\Omega) = \\Delta(\\Omega) + i\\Gamma(\\Omega) \\,,\n\\end{equation}\n where we use $ \\Omega $ to distinguish this energy from the eigenvalues of the dynamical matrix, $ \\omega&#94;2 $. Inelastic neutron measurements sometimes show scattering cross sections that deviate strongly from a Lorentzian. To reproduce this computationally, start by noting that in an idealised experiment the one-phonon neutron cross section would be measured as 1 , 2 \n\\begin{equation}\n\\sigma_{\\lambda}(\\Omega) \\propto\n\\frac{\n  2 \\omega_{\\lambda}\\Gamma_{\\lambda}(\\Omega)\n}{\n  \\left[\\Omega&#94;2-\\omega&#94;2_{\\lambda}-2\\omega_{\\lambda}\n  \\Delta_{\\lambda}(\\Omega)\\right]&#94;2+4\\omega&#94;2_{\\lambda}\\Gamma_{\\lambda}&#94;2(\\Omega)}\\,.\n\\end{equation}\n Here $\\omega&#94;2_{\\lambda}$ are the eigenvalues of the dynamical matrix, $\\Delta_{\\lambda}(\\Omega)$ and $\\Gamma_{\\lambda}(\\Omega)$ are the real and imaginary parts of the frequency dependent self-energy, and $\\hbar\\Omega$ is a probing energy. This is the quantity referred to as the lineshape. If you let $\\Delta$ and $\\Gamma$ go to a small constant, this reduces to a Lorentzian as expected. The energy axis is the probing energy, and the intensity represents the likelihood of exciting a phonon with energy $\\hbar\\Omega$ and momentum $\\textbf{q}$. We can interpret the cross section, or phonon lineshape, as the broadened and shifted phonon frequencies. The term \"broadening\" is used in the sense of a spectral representation: non-interaction quasiparticles are represented as Dirac $\\delta$-functions, but in the interacting case these are replaced by distributions with finite widths. Given the third order force constants, the imaginary part of the phonon self-energy can be calculated: 1 , 2 , 4 \n\\begin{equation}\n\\begin{split}\n\\Gamma_{\\lambda}(\\Omega) & =  \\frac{\\hbar\\pi}{16}\n%\\frac{V}{(2\\pi)&#94;3}\n\\sum_{\\lambda'\\lambda''}\n\\left|\n\\Phi_{\\lambda\\lambda'\\lambda''}\n\\right|&#94;2\n\\big{\\{}(n_{\\lambda'}+n_{\\lambda''}+1)\n\\delta(\\Omega-\\omega_{\\lambda'}-\\omega_{\\lambda''})+\n\\\\& +(n_{\\lambda'}-n_{\\lambda''})\n\\left[\n\\delta(\\Omega-\\omega_{\\lambda'}+\\omega_{\\lambda''}) -\n\\delta(\\Omega+\\omega_{\\lambda'}-\\omega_{\\lambda''})\n\\right]\n\\big{\\}}\n\\end{split}\n\\end{equation}\n The imaginary part of the self energy is a sum over all possible three-phonon interactions $ \\lambda \\lambda' \\lambda''$, $n_{\\lambda}$ are the Bose-Einstein thermal occupation factors counting the number of phonons in each mode. The expression for the self-energy is then an integral over the allowed processes (conserving energy and momentum), weighted by how many phonons are in each of the different modes, with the scattering strength determined by the three-phonon matrix element: \n\\begin{equation}\n\\Phi_{\\lambda\\lambda'\\lambda''} = \n\\sum_{ijk}\n\\sum_{\\alpha\\beta\\gamma}\n\\frac{\n\\epsilon_{\\lambda}&#94;{i \\alpha}\n\\epsilon_{\\lambda'}&#94;{j \\beta}\n\\epsilon_{\\lambda''}&#94;{k \\gamma}\n}{\n\\sqrt{m_{i}m_{j}m_{j}}\n\\sqrt{\n    \\omega_{\\lambda}\n    \\omega_{\\lambda'}\n    \\omega_{\\lambda''}}\n}\n\\Phi&#94;{\\alpha\\beta\\gamma}_{ijk}\ne&#94;{i \\mathbf{q}\\cdot\\mathbf{r}_i + i \\mathbf{q}'\\cdot\\mathbf{r}_j+i \\mathbf{q}''\\cdot\\mathbf{r}_k}\n\\end{equation}\n The real part is conveniently calculated via a Kramers-Kronig transform (it can of course be expressed in a similar way as the imaginary part: 1 , 2 , 4 \n\\begin{equation}\n\\Delta(\\Omega)=\\frac{1}{\\pi}\\int\\frac{\\Gamma(\\omega)}{\\omega-\\Omega}\\mathrm{d}\\omega\\,.\n\\end{equation}\n A significant deviation from Lorentzian lineshapes indicates anharmonic effects and can be checked by considering phonon spectral representation $\\sigma_{\\lambda}$. Mass disorder The mass disorder term is also included, stemming from the natural distribution of isotopes. According to Tamura 5 , if the isotopes are randomly distributed on the lattice sites then the strength of the isotope effects can be given by a mass variance parameter $g$: \n\\begin{equation}\ng_i=\\sum_j c_{i}&#94;j \\left(\\frac{m_i&#94;j-\\bar{m_i}}{\\bar{m_i}}\\right)&#94;2 \n\\end{equation}\n where $\\bar{m_i}$ is the average isotopic mass( $\\bar{m_i}=\\sum_j c_i&#94;j m_i&#94;j$ ), $m&#94;j_i$ is the mass of isotope $j$ of atom $i$ and $c&#94;j_i$ is its concentration. We can write an expression for the imaginary part of the isotope self-energy: \n\\begin{equation}\n\\Gamma_{\\lambda}(\\Omega)=\n\\frac{\\pi}{4} \\sum_{\\lambda'}\n\\Lambda_{\\lambda\\lambda'} \\delta(\\Omega-\\omega_{\\lambda}')\n\\end{equation}\n where \n\\begin{equation}\n\\Lambda_{\\lambda\\lambda'}=\n\\omega_{\\lambda}\\omega_{\\lambda'} \\sum_i g_i \\left| \\epsilon_{\\lambda}&#94;{i \\dagger} \\epsilon_{\\lambda'}&#94;{i} \\right|&#94;2\n\\end{equation}\n Per default, the isotope distribution will be the natural distribution. In case some other distribution is desired, this can be specified. Input files Required files: infile.ucposcar infile.forceconstant infile.forceconstant_thirdorder Optional files: infile.lotosplitting (for long-range corrections) infile.qpoints_dispersion (to specify the q-point path) infile.isotopes (for non-natural isotope distribution) Output files There are three possible modes for this code: the lineshape at a single q-point (default), along a path in the BZ ( --path ) or over the full BZ as a phonon DOS ( --dos ). The output files will differ. For lineshape at a single q, you get outfile.selfenergy_* Todo This is on it's way to be moved to an hdf5. Fix. outfile.sqe.hdf5 These files represent the properties calculated as a function of \\textbf{q} along high symmetry directions in the Brillouin zone. The file is self-documented. An example how to produce decent-looking plots can be found here . outfile.dos_lineshape Is identical to this . Maradudin, A. A., & Fein, A. (1962). Scattering of Neutrons by an Anharmonic Crystal. Physical Review, 128(6), 2589–2608. ↩ Cowley, R. A. (1968). Anharmonic crystals. Reports on Progress in Physics, 31(1), 123–166. ↩ Leibfried, G., & Ludwig, W. (1961). Theory of Anharmonic Effects in Crystals. Solid State Physics - Advances in Research and Applications, 12(C), 275–444. ↩ Wallace, D. C. (1998). Thermodynamics of crystals. Dover Publications, Incorporated. ↩ Tamura, S. (1983). Isotope scattering of dispersive phonons in Ge. Physical Review B, 27(2), 858–866. ↩","tags":"","loc":"program/lineshape.html","title":"\n    \n        lineshape – TDEP\n    \n"},{"text":"Short description Builds supercells. Command line options: Optional switches: --dimensions value#1 value#2 value#3 , -d value#1 value#2 value#3 default value 5 5 5 Dimensions of supercell. --nondiagonal_dimensions value#1 value#2 value#3 value#4 value#5 value#6 value#7 value#8 value#9 , -nd value#1 value#2 value#3 value#4 value#5 value#6 value#7 value#8 value#9 default value 0 0 0 0 0 0 0 0 0 Non-diagonal dimensions of supercell. --output_format value , -of value , value in: 1,2,3 default value 1 Output format. 1 is VASP, 2 Abinit, 3 LAMMPS. --help , -h Print this help message --version , -v Print version Examples generate_structure -dim 4 3 5 Longer summary This code builds a supercell with user-specified dimensions from the unit cell given in infile.ucposcar . All positions are in fractional coordinates. The code handles diagonal and non-diagonal cells. The diagonal cells are simple repetitions of the unit cell, making it $N_1 \\times N_2 \\times N_3$ larger. The non-diagonal cells can be useful when the unit cell has an awkward shape. The supercell will have the lattice vectors \n\\begin{pmatrix}\n\\mathbf{A}_1 \\\\\n\\mathbf{A}_2 \\\\\n\\mathbf{A}_3 \\\\\n\\end{pmatrix}\n= \\mathbf{M}\n\\begin{pmatrix}\n\\mathbf{a}_1 \\\\\n\\mathbf{a}_2 \\\\\n\\mathbf{a}_3 \n\\end{pmatrix}\n where $\\det( \\mathbf{M} )$ is a positive integer. Some useful transformations are, for example, with -nd -n1 n1 n1 n2 -n2 n2 n3 n3 -n3 , from a primitive fcc lattice to the conventional cubic \n\\begin{pmatrix}\nn_1 a & 0 & 0 \\\\\n0 & n_2 a & 0 \\\\\n0 & 0 & n_3 a\n\\end{pmatrix}\n=\\begin{pmatrix}\n-n_1 & n_1 & n_1 \\\\\nn_2 & -n_2 & n_2 \\\\\nn_3 & n_3 & -n_3\n\\end{pmatrix}\n\\begin{pmatrix}\n0 & a/2 & a/2 \\\\\na/2 & 0 & a/2 \\\\\na/2 & a/2 & 0\n\\end{pmatrix}\n Similarly, from a primitive bcc to conventional cubic: \n\\begin{pmatrix}\nn_1 a & 0 & 0 \\\\\n0 & n_2 a & 0 \\\\\n0 & 0 & n_3 a\n\\end{pmatrix}\n=\\begin{pmatrix}\n0 & n_1 & n_1 \\\\\nn_2 & 0 & n_2 \\\\\nn_3 & n_3 & 0\n\\end{pmatrix}\n\\begin{pmatrix}\n-a/2 & a/2 & a/2 \\\\\na/2 & -a/2 & a/2 \\\\\na/2 & a/2 & -a/2\n\\end{pmatrix}\n There are some non-obvious ones as well, such as converting a hexagonal lattice to an orthorhombic: \n\\begin{pmatrix}\nn_1 a & 0 & 0 \\\\\n0 & \\sqrt{3} n_2 a  & 0 \\\\\n0 & 0 & n_3 c\n\\end{pmatrix}\n=\\begin{pmatrix}\nn_1 & n_1 & 0 \\\\\n-n_2 & n_2 & 0 \\\\\n0 & 0 & n_3\n\\end{pmatrix}\n\\begin{pmatrix}\na/2 & -a\\sqrt{3}/2 & 0 \\\\\na/2 & a \\sqrt{3}/2 & 0 \\\\\n0 & 0 & c\n\\end{pmatrix}\n or rhombohedral (lattice parameter $a$, angle $\\alpha$) to hexagonal: \n\\begin{equation*}\n\\begin{split}\n\\begin{pmatrix}\n0 & n_1 a \\sqrt{2-2 \\cos\\alpha} & 0  \\\\\n-n_2 a\\sqrt{ \\frac{2-2 \\cos\\alpha}{3} } & -n_2 a \\sqrt{2-2 \\cos\\alpha}  & 0 \\\\\n0 & 0 & n_3 a \\sqrt{3+6\\cos\\alpha}\n\\end{pmatrix}\n= \\\\ \\\\ \\begin{pmatrix}\nn_1 & n_1 & 0 \\\\\n-n_2 & n_2 & 0 \\\\\n0 & 0 & n_3\n\\end{pmatrix}\n\\begin{pmatrix}\na\\sqrt{2-2\\cos\\alpha} & 0 & a\\sqrt{\\frac{1+2\\cos\\alpha}{3}} \\\\\n-a\\sqrt{\\frac{1-\\cos\\alpha}{2}} & a\\sqrt{3\\frac{1-\\cos\\alpha}{2}} & a\\sqrt{\\frac{1+2\\cos\\alpha}{3}} \\\\\n-a\\sqrt{\\frac{1-\\cos\\alpha}{2}} & -a\\sqrt{3\\frac{1-\\cos\\alpha}{2}} & a\\sqrt{\\frac{1+2\\cos\\alpha}{3}} \n\\end{pmatrix}\n\\end{split}\n\\end{equation*}\n There are too many ways to build supercells to list here. The examples are suggestions so that you can pick a supercell that is as cubic as possible. Converging results with respect to supercell size goes approximately as the size of the largest sphere you can fit in the cell. Input files infile.ucposcar Output files outfile.ssposcar","tags":"","loc":"program/generate_structure.html","title":"\n    \n        generate structure – TDEP\n    \n"},{"text":"Short description Use forceconstants or a Debye temperature to generate uncorrelated supercell configurations emulating a canonical ensemble. These configurations can be used to either start ensemble runs of molecular dynamics with negligible equilibration time, or be used to directly sample phase space. Command line options: Optional switches: --temperature value , -t value default value 300 Temperature to emulate --nconf value , -n value default value 5 Number of configurations to generate --quantum default value .false. Use Bose-Einstein statistics instead of Maxwell-Boltzmann. That is, use  \\sqrt{\\frac{\\hbar (2n+1) }{2 m \\omega}}  as the mean normal mode amplitudes instead of the classical  \\frac{1}{\\omega}\\sqrt{\\frac{k_BT}{m}}  --output_format value , -of value , value in: 1,2 default value 1 Selects output format. 1 is VASP, 2 is Abinit. Default 1. --threshold value default value -1 Minimum frequency to consider. Frequencies smaller than this number will be replaced by this number when evaluating displacements. Useful for materials with extremely low-lying modes that can cause divergencies. --debye_temperature value , -td value default value -1 Generate forceconstants that match a Debye temperature, and build displacements according to these. See details below. --help , -h Print this help message --version , -v Print version Examples canonical_configuration -n 10 -t 300 canonical_configuration -n 300 -t 0 --quantum canonical_configuration -n 20 -t 10 --quantum --debye_temperature 400 Longer summary This code takes a second order forceconstant and generates a supercell with the atoms displaced corresponding to a harmonic canonical ensemble. These configurations can be used directly, to generate force-displacement statistics to determine force constants and other thermal properties, or as the starting point for molecular dynamics. Todo Update this to explain how to do statistical sampling in clever ways, but probably not before I actually publish it. Background Born-Oppenheimer molecular dynamics can be expensive for many reasons. Firstly, it requires supercells with more than 100 atoms. Secondly, computation of the electronic ground state at every time step is time consuming. Thirdly, the cell must be fully equilibrated. The precision of the calculations is statistically linked to the number of configurations used: any property $A$ for which we want to calculate the ensemble average $\\langle A \\rangle$ must be converged with respect to the number of uncorrelated time steps. To minimise the equilibration time, the simulation cell can be initialised to a thermally excited state by selecting initial atomic velocities and displacement amplitudes according to the Maxwell-Boltzmann 1 or Bose - Einstein distributions. Starting with the equations of motion for the supercell (given harmonic force constants ) \n\\begin{equation}\n\\begin{pmatrix}\nm_1 \\ddot{\\mathbf{u}}_1 \\\\\nm_2 \\ddot{\\mathbf{u}}_2 \\\\\n\\vdots \\\\\nm_{N_a} \\ddot{\\mathbf{u}}_{N_a}\n\\end{pmatrix}=\n\\begin{pmatrix}\n\\mathbf{\\Phi}_{11} & \\mathbf{\\Phi}_{12} & \\cdots & \\mathbf{\\Phi}_{1N_a} \\\\\n\\mathbf{\\Phi}_{21} & \\mathbf{\\Phi}_{22} & \\cdots & \\mathbf{\\Phi}_{2N_a} \\\\\n\\vdots & \\vdots & \\ddots & \\vdots \\\\\n\\mathbf{\\Phi}_{N_a1} & \\mathbf{\\Phi}_{N_a2} & \\cdots & \\mathbf{\\Phi}_{N_aN_a} \n\\end{pmatrix}\n\\begin{pmatrix}\n\\mathbf{u}_1\\\\\n\\mathbf{u}_2 \\\\\n\\vdots \\\\\n\\mathbf{u}_{N_a} \\\\\n\\end{pmatrix}\n\\end{equation}\n we diagonalise these and get obtaining $3N_a$ eigenvalues $\\omega&#94;2_s$ and eigenvectors $\\epsilon_s$. In the given cell, we can use this normal mode transformation to express the instantaneous positions and velocities, \n\\begin{align}\nu_i = & \\sum_{s=1}&#94;{3N_a} \\epsilon_{is} A_{is} \\sin( \\omega_s t+\\delta_s ) \\\\\n\\dot{u}_i = & \\sum_{s=1}&#94;{3N_a} \\epsilon_{is} A_{is} \\omega_s \\cos( \\omega_s t+\\delta_s) \n\\end{align}\n where the normal mode amplitudes $A_s$ and the phase $\\delta_s$ will be determined by the following boundary conditions: we require a set of positions and velocities that correspond to a canonical ensemble. We choose $A_s$ so that they are normally distributed around their mean value and that each mode $s$ should contribute, on average, $k_B T/2$ to the internal energy. Then \n\\begin{equation}\n\\langle A_{is} \\rangle = \n\\sqrt{\\frac{\\hbar (2n_s+1) }{2 m_i \\omega_s}} \n\\approx\n\\frac{1}{\\omega_s}\\sqrt{\\frac{k_BT}{m_i}},\n\\end{equation}\n where the approximate result is in the classical limit, $\\hbar \\omega \\ll k_BT $. The appropriate distribution of atomic positions and velocities is given by, \n\\begin{align}\nu_i & = \\sum_{s=1}&#94;{3N_a} \n\\epsilon_{is} \\langle A_{is} \\rangle \\sqrt{-2\\ln \\xi_1}\\sin 2\\pi\\xi_2 \\\\\n\\dot{u}_i & = \\sum_{s=1}&#94;{3N_a}\n\\omega_s \\epsilon_{is} \\langle A_{is} \\rangle \\sqrt{-2\\ln \\xi_1}\\cos 2\\pi\\xi_2\n\\end{align}\n Here, $0 \\lt \\xi_n \\lt 1$, represents a uniform distribution of random numbers, which are transformed to a normal distribution using the standard Box-Muller transform. Choosing the mean amplitudes in the classical limit gives us a snapshot in time from a canonical Maxwell-Boltzmann ensemble (within the harmonic approximation), which results in a starting point that reduces the time until equilibration by orders of magnitude. Choosing a Bose-Einstein distribution of mean amplitudes and velocities instead allows us to sample phase space while including quantum thermal disorder at low temperatures. For applications where one does not need consecutive timesteps, the starting configurations generated by this can be used  by run several simultaneous instances of Born-Oppenheimer molecular dynamics with different random starting configurations, rather than running a single long instance. This strategy allows for parallelization of Born-Oppenheimer molecular dynamics with near perfect linear scaling, since the overhead of equilibration time is almost completely eliminated. This is illustrated in the plot above. This is the singular value decomposition of molecular dynamics trajectories. A single colored field corresponds to data from a single random initial starting configuration. The dimensions spanned per unit time is greatly increased by stitching together calculations from different initial configurations. That is, 10 MD runs of 1000 time steps explores phase space better than a single MD run of 10x1000 time steps. Matching with a Debye temperature Up until this point we have assumed you have forceconstants to generate the normal mode displacements. If you don't, it's possible to guess them. The following procedure is used: assume a pair potential $U(r)$ which obeys \n\\begin{equation}\n\\frac{ \\partial U(r)}{\\partial r_{ij} }=0\n\\end{equation}\n and \n\\begin{equation}\n\\frac{ \\partial&#94;2 U(r)}{\\partial r_{ij}&#94;2 }=\\frac{\\alpha}{r_{ij}&#94;4}\n\\end{equation}\n Here $r_{ij}$ is a pair distance in the supercell. Forceconstants can be calculated analytically from a pair potential, in this case they are given by \n\\begin{equation}\n\\mathbf{\\Phi}(r)=\n-\\frac{\\alpha}{r&#94;6}\n\\begin{pmatrix}\nr_x&#94;2 & r_x r_y & r_x r_z \\\\\nr_x r_y & r_y&#94;2 & r_y r_z \\\\\nr_x r_z & r_y r_z & r_z&#94;2  \n\\end{pmatrix}\n\\end{equation}\n By definition, this will always produce stable phonons with the correct symmetry. The parameter $\\alpha$ is determined by numerically matching the zero-point motion of the phonons to a Debye temperature: \n\\begin{equation}\n\\frac{1}{N} \\sum_i \\frac{\\hbar \\omega_i(\\alpha)}{2} = \\frac{9 k_B T_D}{8}\n\\end{equation}\n Using actual forceconstants is of course better, but this procedure generates surprisingly good configurations. Input files infile.ucposcar infile.ssposcar (use generate structure to create one) infile.forceconstant (or use --debye_temperature as described above) Output files The desired number of configurations are printed in VASP POSCAR format contcar_conf0001 contcar_conf0002 contcar_conf0003 ... or alternatively in Abinit format: abinput_conf0001 abinput_conf0002 abinput_conf0003 ... In case you used a Debye temperature to generate the configurations, outfile.fakeforceconstant will be written. Use phonon dispersion relations to plot it and check that the frequencies are reasonable. West, D., & Estreicher, S. (2006). First-Principles Calculations of Vibrational Lifetimes and Decay Channels: Hydrogen-Related Modes in Si. Physical Review Letters, 96(11), 115504. ↩","tags":"","loc":"program/canonical_configuration.html","title":"\n    \n        canonical configuration – TDEP\n    \n"},{"text":"Getting started To get started, make sure you meet the dependencies and install everything. While things are compiling, it might be a good idea to familarize yourself with the literature, starting with a shameless plug for my papers: Hellman, O., Abrikosov, I. A., & Simak, S. I. (2011). Lattice dynamics of anharmonic solids from first principles. Physical Review B, 84(18), 180301. Hellman, O. & Abrikosov, I. A. (2013). Temperature-dependent effective third-order interatomic force constants from first principles. Physical Review B, 88(14), 144301. Hellman, O., Steneteg, P., Abrikosov, I. A., & Simak, S. I. (2013). Temperature dependent effective potential method for accurate free energy calculations of solids. Physical Review B, 87(10), 104111. This provides background, but does not accurately reflect all the capabilities of this software package. Usage This software package consist of several programs, meant to be chained together into workflows, depending on property you are interested in. Before trying anything too complicated, make sure you start with the tutorial , everything named minimal example . The descriptions of each program serves as both reference and theoretical background. For things to make sense, read them in this order: extract forceconstants phonon dispersion relations lineshape thermal conductivity Before trying production quality calculations, it is useful to try some of the real world examples provided: Todo Actually add the real world examples. I thought I should take the raw data from what I used in papers. But it has a tendency to become awfully complicated, maybe take someone else data that is not that messy.","tags":"","loc":"page//index.html","title":"Manual – TDEP"},{"text":"This package is written mainly in fortran, with parts in c, c++, and python. The minimum requirements are fortran compiler. Tested with gcc 5+, ifort 14+. Several f2003/2008 features are extensively used, so the compiler needs to be rather new. MPI fftw hdf5 python In addition, to make use of all features you might want to install gnuplot, tested with 4+ on OSX with aquaterm this documentation is generated with FORD . Note I do all the development in OSX, and install all libraries/dependencies with homebrew . For reference, these are the things I installed, and referred to in the sample important_settings: brew install gcc fftw --with-fortran openmpi gnuplot --with-aquaterm hdf5 --with-fortran --with-fortran2003 If you do the same, installation should be a breeze. Download Todo Will fix once I make the repository public. Compiling The build system is a little unorthodox, but straightforward. You need to create a file called important_settings , and put it in the root directory of tdep. Several examples are provided, start with the one that seems closest to what you have. An example follows here, for OSX: #!/bin/bash # A central place to put all the important paths. You probably have to modify this to make things work. # the fortran compiler FORTRAN_COMPILER = \"gfortran\" # optimization stuff. Go all in. OPTIMIZATION_LEVEL = \"-Ofast\" # the flag that sets the default real to a double. DOUBLE_FLAG = \"-fdefault-real-8\" # The flag that tells the compiler where to put .o and .mod files. MODULE_FLAG = \"-J\" # the header to put in python scripts. PYTHONHEADER = \"#!/usr/bin/python\" # Which gnuplot terminal to use by default. GNUPLOTTERMINAL = \"aqua\" # nice on OSX, needs aquaterm installed and gnuplot compiled with support for it. #GNUPLOTTERMINAL=\"wxt\"  # nice on linux. #GNUPLOTTERMINAL=\"x11\"  # fallback that works but looks kind of bad # Precompiler flags. Selecting default gnuplot terminal, and make the progressbars work. PRECOMPILER_FLAGS = \"-DGP ${ GNUPLOTTERMINAL } -Dgfortranprogressbar\" # for gfortran #PRECOMPILER_FLAGS=\"-DGP${GNUPLOTTERMINAL} -Difortprogressbar\" # for ifort # these are the flags that are needed for gfortran FCFLAGS = \"-Wl,-commons,use_dylibs -ffree-line-length-none -std=f2008 -fall-intrinsics -cpp -fopenmp\" # These are the BLAS/LAPACK libraries. On OSX with gfortran, use the built-in # where you just specify -framework accelerate and everything works. On other systems # you might have to specify this manally PATH_TO_BLASLAPACK_LIB = \" \" #PATH_TO_BLASLAPACK_LIB=\"-L/path_to_somehwere \" PATH_TO_BLASLAPACK_INC = \" \" #PATH_TO_BLASLAPACK_INC=\"-I/path_to_somewhere\" BLASLAPACK_LIBS = \"-framework accelerate\" #BLASLAPACK_LIBS=\"-lblas -llapack \" # add whatever library lines needed for your blas/lapack installation # For the autocorrelation code, I use fast Fourier transforms. fftw needs to be installed and # linked. This is where homebrew installed mine on osx PATH_TO_FFTW_LIB = \"-L/usr/local/lib\" PATH_TO_FFTW_INC = \"-I/usr/local/include\" FFTW_LIBS = \"-lfftw3\" # The thermal conductivity is MPI parallel. Then you need an mpi installation. This one points to # openmpi installed by homebrew in it's default location PATH_TO_MPI_LIB = \"-L/usr/local/lib\" PATH_TO_MPI_INC = \"-I/usr/local/include\" MPI_LIBS = \"-lmpi_mpifh -lmpi\" # I also use HDF5 every now and then PATH_TO_HDF5_LIB = \"-L/usr/local/lib\" PATH_TO_HDF5_INC = \"-I/usr/local/include\" HDF5_LIBS = \"-lhdf5 -lhdf5_fortran\" # We also need a C-compiler C_COMPILER = \"gcc-5\" # If you want to try and use CGAL. Not recommended for people who do not like to sort out compiler errors. USECGAL = \"no\" # CGAL is written in c++. I have wrapper functions in C, that I call from Fortran. CPP_COMPILER = \"gcc-5\" CPP_FLAGS = \"--std=c++0x -frounding-math -O3 -Dusecgal -DCGAL_USE_GMP -DCGAL_USE_MPFR -DCGAL_EIGEN3_ENABLED -DNDEBUG -DBOOST_PARAMETER_MAX_ARITY=12 -Wno-deprecated-declarations\" CGALLINKLINE = \"-lstdc++ -lCGAL -lmpfr -lgmp -lboost_system -lboost_thread-mt\" # It's important at least a majority of these libraries are compiled with the same c++ compiler # as above. You can get strange, strange errors otherwise. As I said, getting this up and running # is not easy. But pretty cool, and worth the effort. PATH_TO_CGAL_LIB = \"-L/Users/olle/software/CGAL-4.8/build/lib -L/usr/local/lib\" PATH_TO_CGAL_INC = \"-I/Users/olle/software/CGAL-4.8/build/include -I/usr/local/include -I/usr/local/include/eigen3\" # These are not really needed, but I left them in case someone wants to test the legacy version. #MATHEMATICAHEADER=\"#!/Applications/Mathematica.app/Contents/MacOS/MathematicaScript -script\" # OSX # the folder where Mathematica puts its settings. I have made a Mathematica package, and it needs # to be linked in the correct folder, which differs from system to system. #MATHEMATICASETTINGS=\"${HOME}/Library/Mathematica\" # on OSX #MATHEMATICASETTINGS=\"${HOME}/.Mathematica\"       # on linux, usually once that is set up, run ./build_things.sh And things should start compiling. It will stop at any error, you probably have to install some library or adjust some path in important_settings . Setting paths once build_things.sh has finished, it should have printed a bashrc_tdep file. The rest of the usage guides assumes you put this in your .bashrc or equivalent. It sets the path, manpath and a few minor things, contains the following lines: MANPATH = $MANPATH :/Users/olle/tdep-devel/man PATH = $PATH :/Users/olle/tdep-devel/bin export MANPATH export PATH alias gnuplot = 'gnuplot -persist' If this is set up, you are good to go. Complicated dependencies CGAL You might have noticed that there is an optional dependency on CGAL in the provided important_settings . I wrote a Fortran interface to (a very small subset of) CGAL that can be used to generate meshes, triangulations and other things. The reason it is not enabled by default is that making CGAL and Fortran talk to each other nicely is not that fun. I can only describe how I got it to work. I don't know if all of these steps are necessary, or if there is some other thing I did that got it to work. This is all for OSX 10.11.4 get the latest CGAL source, I used 4.8, and read the manual installation. compile boost with gcc compile eigen with gcc when configuring cgal with cmake, specify C and c++ compilers manually to gcc-5 (I never got it working with clang, my guess is that linking becomes easier if the fortran, C and c++ compilers are all gcc.) configure cgal to produce static libraries add -DBOOST_PARAMETER_MAX_ARITY=12 to the compile line If this made no sense whatsoever, you probably do not want to try and enable this.","tags":"","loc":"page/./0_installation.html","title":"Installation – TDEP"},{"text":"Part of the package is a set of small tools that help with preparing input for post-processing. Vasp post-processing The scripts process_outcar.py and process_outcar_5.3.py are used to extract information from VASP OUTCAR files. Note Johan was here...","tags":"","loc":"page/./1_utilities.html","title":"Utility scripts – TDEP"},{"text":"Input files This page details the format for all input files. The format of the output files is infile.ucposcar An example of a crystal structure (this is exactly the VASP 5 file format): Bi2Te3\n10.314046162\n 0.243360208934  0.000000000000  0.969935981757\n-0.121680104467  0.210756123207  0.969935981757\n-0.121680104467 -0.210756123207  0.969935981757\nBi Te\n2 3\ndirect coordinates\n0.599898812406 0.599898812406 0.599898812406\n0.400101187594 0.400101187594 0.400101187594\n0.791308614612 0.791308614612 0.791308614612\n0.208691385388 0.208691385388 0.208691385388\n0.000000000000 0.000000000000 0.000000000000 The first line is a comment, the second line a global scaling factor a, and the three following lines the lattice vectors \\mathbf{a}_1,\\mathbf{a}_2,\\mathbf{a}_3. These will be multiplied by a. Next is the specfication of what elements there are, and below that how many of each. The line direct coordinates specify that the coordinates of the atoms are in fractional coordinates. Each atom has it's own line, with two first specifying the Bi positions and the last three Te positions. infile.ssposcar This file hold the ideal positions for the atoms in the supercell. The file format is identical to the unitcell, only that the cell is larger. There is no need for the unit and supercell to be perfectly commensurate: for example with the trigonal unitcell in the example above, I used a supercell based on the hexagonal unit cell. The only requirement is that the two cells describe the same lattice. And by the same, I do not mean almost the same, I mean the same to machine precision. You can not build the supercell from ideal positions and use relaxed positions for the unitcell, for example. infile.positions This file hold the positions. It looks something like this: 8.2561407159200030E-005   2.2226748311341836E-003  0.99884779259537781\n  0.99849619391764632        1.3299790395140015E-003  0.20126465487180664\n  0.99942091881904371       0.99921744312226823       0.39925524034421311\n  0.99726097226994259        9.3000027090734956E-004  0.60117595839769800\n  0.99998106248734664       0.99877980293422230       0.80215876222138049\n   2.7059648117732179E-004  0.20042853805668126        9.0607694878967109E-004\n   4.7165392641841262E-004  0.20049530215652531       0.20005541126842488\n  0.99978563110732910       0.20120110797551810       0.39998540127778304\n   5.9697200870672466E-005  0.20002590513205151       0.60020279388531417\n   1.0832057274455832E-003  0.19752092901626805       0.80125606638730629\n   ... and goes on for many many lines. The format is as follows: Row Description 1  r_1&#94;x \\qquad r_1&#94;y \\qquad r_1&#94;z  2  r_2&#94;x \\qquad r_2&#94;y \\qquad r_2&#94;z  ... ... N_a  r_{N_a}&#94;x \\qquad r_{N_a}&#94;y \\qquad r_{N_a}&#94;z  N_a+1  r_1&#94;x \\qquad r_1&#94;y \\qquad r_1&#94;z  ... ... N_aN_c  r_{N_a}&#94;x \\qquad r_{N_a}&#94;y \\qquad r_{N_a}&#94;z  That is the positions in fractional coordinates for each atom in the simulation cell, in the same order as in infile.ssposcar . Once all the positions are specified, it starts over with the next configuration, for a total of number of atoms times number of configurations lines. infile.forces The format for this file is nearly identical to infile.positions , only that Row Description 1  f_1&#94;x \\qquad f_1&#94;y \\qquad f_1&#94;z  2  f_2&#94;x \\qquad f_2&#94;y \\qquad f_2&#94;z  ... ... N_a  f_{N_a}&#94;x \\qquad f_{N_a}&#94;y \\qquad f_{N_a}&#94;z  N_a+1  f_1&#94;x \\qquad f_1&#94;y \\qquad f_1&#94;z  ... ... N_aN_c  f_{N_a}&#94;x \\qquad f_{N_a}&#94;y \\qquad f_{N_a}&#94;z  each line is the force on each atom in Cartesian coordinates, in eV/Å. Again, a total of number of atoms times number of configurations lines. infile.stat This file contains all the energy and stresses in the following format: Row Description 1  i \\quad t \\quad E_t \\quad E_p \\quad E_k \\quad T \\quad P \\quad \\sigma_{xx} \\quad \\sigma_{yy} \\quad \\sigma_{zz} \\quad \\sigma_{xz} \\quad \\sigma_{yz} \\quad \\sigma_{xy}  2  i \\quad t \\quad E_t \\quad E_p \\quad E_k \\quad T \\quad P \\quad \\sigma_{xx} \\quad \\sigma_{yy} \\quad \\sigma_{zz} \\quad \\sigma_{xz} \\quad \\sigma_{yz} \\quad \\sigma_{xy}  ... ...  N_c   i \\quad t \\quad E_t \\quad E_p \\quad E_k \\quad T \\quad P \\quad \\sigma_{xx} \\quad \\sigma_{yy} \\quad \\sigma_{zz} \\quad \\sigma_{xz} \\quad \\sigma_{yz} \\quad \\sigma_{xy}  One line for every configuration in the simulation. The energies are in eV/supercell, temperature in K, pressure and stress in GPa. Note The information in this file is only crucial when calculating the free energy. For other applications this can safely be filled with mock data. infile.meta Some information about the MD run, an example: 240    # N atoms\n2000   # N timesteps\n1.0    # timestep in fs\n300    # temperature in K The first line is the number of atoms in the simulation, the second line the number of timesteps. Then the timestep and the temperature. Note The timestep and temperature can safely be set to 0, except for autocorrelation and atomic distribution infile.lotosplitting This is an example input file for the long-range electrostatic corrections, also for Bi2Te3. 5.0  0.0  0.0 # three lines for dielectric tensor\n 0.0  5.0  0.0 \n 0.0  0.0  7.5 \n 8.0  0.0  0.0 # Born effective charge for atom 1, three lines\n 0.0  8.0  0.0 \n 0.0  0.0  2.5 \n 8.0  0.0  0.0 # Born effective charge for atom 2, three lines\n 0.0  8.0  0.0 \n 0.0  0.0  2.5 \n-4.5  0.0  0.0 # Born effective charge for atom 3, three lines\n 0.0 -4.5  0.0 \n 0.0  0.0 -0.5 \n-4.5  0.0  0.0 # Born effective charge for atom 4, three lines\n 0.0 -4.5  0.0 \n 0.0  0.0 -0.5 \n-7.0  0.0  0.0 # Born effective charge for atom 5, three lines\n 0.0 -7.0  0.0 \n 0.0  0.0 -5.1 The first three lines is the dielectric tensor, after that three lines per atom in infile.ucposcar with the Born effective charges. The dielectric tensor is unitless, and the Born effective charges are in electron charges. infile.qpoints_dispersion Many programs output properties along a path in the BZ. Per default, this is generated procedurally. In case the default is not satisfactory, you have the possibility to specify a path. FCC                         ! Bravais lattice type\n  100                       ! Number of points on each path\n    4                       ! Number paths between special points\nGM  X                       ! Starting and ending special point\nX   U                       !\nK   GM                      !\nGM  L                       ! Where the first line specify the Bravais family, followed by the number of points on each line segment and the number of line segments. Each line segment is specified by two labels. Use crystal structure info to get a list of the possible labels and their coordinates. If this is not flexible enough, an arbitrary path can be specified CUSTOM                      !\n  100                       ! Number of points on each path\n    4                       ! Number paths between special points\n0.000 0.000 0.000   0.000 0.500 0.500 GM X\n0.000 0.500 0.500   0.000 0.625 0.375 X  U\n0.375 0.750 0.375   0.000 0.000 0.000 K  GM\n0.000 0.000 0.000   0.000 0.500 0.000 GM L This is the same path as above, but explicitly specified. Each segment is specified by 3+3 numbers and two labels. The coordinates are reciprocal fractional. infile.isotopes The phonon many-body perturbation theory considers scattering by isotopes. By default, they will use the natural distribution (tabulated in the code, taken from the symbol in infile.ucposcar ). In case you want to specify some other distribution, you can: 1         # number of isotopes for first atom in infile.ucposcar\n1 28.0855 # concentration, mass, one line per isotope\n2         # number of isotopes for second atom\n0.5 12.0  # concentration, mass\n0.5 13.0  # concentration, mass\n... Per atom in the unit cell, you specify the number of isotopes, followed by the appropriate number of concentrations and masses (in atomic mass units).","tags":"","loc":"page/./files.html","title":"Files – TDEP"},{"text":"This series of workflows are writtin as a combination of instructions and tutorials. This software package is easy to use, but the underlying physics are not trivial. There are some deliberate barriers introduced as attempts to force a good understanding from the user. I am expecting limited success. The minimal examples should be done first, that each deal with fundamental parts: Example 1 : will get you started and plot some stuff. Example 2 : basic MD input preparation. Example 3 : stochastic input preparation. Example 4 : free energy. Example 5 : thermal conductivity. Example 6 : properties as a function of temperature. With that taken care, I plan to add proper examples of projects with production quality data. Dig up some old stuff I already published.","tags":"","loc":"page/workflows/index.html","title":"Workflows – TDEP"},{"text":"Phonon dispersions and spectral function Following this example you will calculate the phonon dispersion relations and the phonon spectral function of fcc Al. I assume everything is installed, and that the tdep/bin folder is added to your path. Navigate to tests/test_1_fcc_al . There you will find infile.ucposcar infile.ssposcar infile.positions infile.forces infile.meta infile.stat which are prepared input files. Copy these to a new folder and work from there (not a reuqirement, but makes it easy to start over in case you mess up). First, we are interested in the phonon frequencies, and for that we need second order force constants . We use extract_forceconstants -rc2 5 This means we want forceconstants including all neighbours within 5Å. Hopefully, a new file should appear: outfile.forceconstant , along with some other files we ignore for now. Files named infile.something will not get overwritten, but those named outfile.something might. For files to be read by other programs , you need to rename it, preferably like this: ln -s outfile.forceconstant infile.forceconstant To get the phonon dispersion relations we use phonon_dispersion_relations Frequency as a function of q-vector is written to outfile.dispersion_relations . If gnuplot is properly set up (if gnuplot just flashes, it's probably because it is missing the --persist option), you can run gnuplot outfile.dispersion_relations.gnuplot And you should see something like this: If we want to know something about the broadening we need third order force constants. To get these, we rerun extract_forceconstants -rc2 5 -rc3 3 And it will produce a new forceconstant file, outfile.forceconstant_thirdorder . Again, we need to copy (or link) it to an infile: ln -s outfile.forceconstant_thirdorder infile.forceconstant_thirdorder Once this is set up, we use the lineshape code to produce the phonon spectral function: lineshape --path -qg 7 7 7 -ne 600 --temperature 800 and this produces, among other things, an outfile.sqe (and the hdf5 version of the same data, outfile.sqe.hdf5 ). I read this into matlab and plotted it with a logarithmic intensity scale, and the results look something like this: This is a sample matlab code snippet to produce this plot: % read everything from file fn =( 'outfile.sqe.hdf5' ); x = h5read ( fn , '/q_values' ); y = h5read ( fn , '/energy_values' ); gz = h5read ( fn , '/intensity' ); xtck = h5read ( fn , '/q_ticks' ); xtcklabel = strsplit ( h5readatt ( fn , '/' , 'q_tick_labels' )); energyunit = h5readatt ( fn , '/' , 'energy_unit' ); % plot the results figure ( 1 ); clf ; hold on ; box on ; [ gy , gx ]= meshgrid ( y , x ); s = pcolor ( gx , gy , log10 ( gz + 1E-2 )); set ( s , 'edgecolor' , 'none' , 'facecolor' , 'interp' ) set ( gca , 'xtick' , xtck , 'xticklabel' , xtcklabel ) ylabel ([ 'Energy (' energyunit ')' ]) xlim ([ 0 max ( x )]) ylim ([ 0 max ( y )]) And an equivalent snippet using matplotlib import matplotlib.pyplot as plt import numpy as np import h5py as h5 from matplotlib.colors import LogNorm # open the sqe file f = h5 . File ( 'outfile.sqe.hdf5' , 'r' ) # get axes and intensity x = np . array ( f . get ( 'q_values' )) y = np . array ( f . get ( 'energy_values' )) gz = np . array ( f . get ( 'intensity' )) # add a little bit so that the logscale does not go nuts gz = gz + 1E-2 # for plotting, turn the axes into 2d arrays gx , gy = np . meshgrid ( x , y ) # x-ticks xt = np . array ( f . get ( 'q_ticks' )) # labels for the x-ticks xl = f . attrs . get ( 'q_tick_labels' ) . split () # label for y-axis yl = \"Energy (\" + f . attrs . get ( 'energy_unit' ) + \")\" plt . pcolormesh ( gx , gy , gz , norm = LogNorm ( vmin = gz . min (), vmax = gz . max ()), cmap = 'viridis' ) # set the limits of the plot to the limits of the data plt . axis ([ x . min (), x . max (), y . min (), y . max ()]) plt . xticks ( xt , xl ) plt . ylabel ( yl ) plt . show () Read the documentation for the codes used, and familiarise yourself with their capabilities before moving on. A couple of things that should be very easy, and a final one that requires some thought: Change the q-point path through the Brillouin zone. First plot the dispersions along this new path, then the spectralfunction. hint. Plot the phonon DOS in units of meV from the second order force constants. Understand the difference between the different ways to integrate. hint. Get the broadened phonon DOS at some temperature. Try to understand the difference in integration technique when doing this, and the example above. hint. Get the phonon free energy at 450K. hint. Figure out what depends on what. If you have calculated the spectralfunction at 300K, and want to do it with a tighter q-point grid, from what step do you have to start over? If you want a longer cutoff for the second order force constants, from what step do you have to repeat the procedure?","tags":"","loc":"page/workflows/minimal_example_1.html","title":"Minimal example I – TDEP"},{"text":"Create the input files In this example we want to produce input files similar to those provided in the first minimal example by setting up the required files, running VASP and postprocessing. But since this is a tutorial, you do not need to actually run any DFT calculations, the output files are provided in examples/example_2_ScF3 . Preparing input Start by making an empty working directory. The first step is to prepare the unit cell. In this particular case, use this and and name it infile.ucposcar ScF3\n   4.011000\n  1.000000000000000   0.000000000000000   0.000000000000000\n  0.000000000000000   1.000000000000000   0.000000000000000\n  0.000000000000000   0.000000000000000   1.000000000000000\n Sc F\n   1   3\nDirect\n  0.000000000000000   0.000000000000000   0.000000000000000\n  0.500000000000000   0.000000000000000   0.000000000000000\n  0.000000000000000   0.000000000000000   0.500000000000000\n  0.000000000000000   0.500000000000000   0.000000000000000 The format is specified here . To run molecular dynamics, you need a larger simulation cell. I have provided tools for that: generate_structure -d 4 4 4 again, change the output to input mv outfile.ssposcar infile.ssposcar This is the preferred way of generating supercells. Any script should do, but some of them that exist out there do not use double precision for some odd reason. The symmetry analysis is rather sensitive, and assumes that the unit- and supercell describe exactly the same lattice, to machine precision. Almost the same is not good enough. This can not be stressed enough, in my experience this is the most common source of problems, and it is easily avoided. When in doubt, use at least 12 decimal places. A common problem is that .cif-files sometimes write too few digits for e.g. \\sqrt(3)/2 for my codes to correctly differentiate between crystal lattices. For example, this is really bad: hcp Fe\n 2.4\n   0.50000  -0.866025  0.00000\n   0.50000   0.866025  0.00000\n   0.00000   0.000000  1.63299\nFe\n   2\nDirect\n   0.333333333333333   0.666666666666667   0.250000000000000\n   0.666666666666667   0.333333333333333   0.750000000000000 whereas this is good: hcp Fe\n 2.4\n   0.500000000000000  -0.866025403784439  0.000000000000000\n   0.500000000000000   0.866025403784439  0.000000000000000\n   0.000000000000000   0.000000000000000  1.632993161855452\nFe\n   2\nDirect\n   0.333333333333333   0.666666666666667   0.250000000000000\n   0.666666666666667   0.333333333333333   0.750000000000000 It is a deliberate choice to set tolerances this tight: there is absolutely no reason why you should not be defining structures to high precision. Loose tolerances can cause subtle errors are far more annoying to track down than entering those extra digits. Use the primitive unit cell The symmetry analysis is clever enough to ensure that you get the same forceconstants regardless of the cell you use, but you should use the smallest possible unit cell. There are tools available to rearrange forceconstants to larger unit cells, but not from a larger cell to a smaller. So by using the smallest possible cell, you can always change your mind later. Running a VASP simulation With the structure defined, we can run some molecular dynamics. In this pariticular example we do it cooking-show style: the output is already prepared. Nonetheless, this is what the input looks like (INCAR only, there is nothing special in the other input files): ENCUT = 600\nISMEAR = 0\nISIF = 2\nIBRION = 0\nNSW = 10000\nEDIFF = 1E-5\nIALGO = 48\n\nPOTIM = 2\nTEBEG = 150\nSMASS = 0 There are some things that might seem nonstandard. The energy cutoff is very high. I start convergence testing at about double the default, ENCUT = 2*ENMAX , where the default is read from the POTCAR files. You can not use tetrahedron integration, you must use some smearing. Fermi smearing makes the most sense, but requires a really tight k-point grid. It differs from what you might normally do in that we require high-quality forces, and not much else. Speaking of that, the tag ISIF = 2 is crucial, since without it forces will not get printed to OUTCAR . Todo Link to page about numerics and how many digits are required. At this stage, you would run the simulations. Starting molecular dynamics from ideal lattice positions usually require a long equilibration time that has to be discarded. This time can be minimized by using a better seed. A program to do this is provided, see initialize_md . Parsing VASP output Pretend that you started VASP and let it run for a while, and copy examples/example_2_ScF3/OUTCAR to the working directory and run process_outcar_5.3.py OUTCAR and all the input files should be created. From this point, repeat the steps in the first example . Not that these are not converged calculations by any means, the provided example is just 80 time steps using a single k-point for the electron structure calculations (github is really not the place to put large output files). TLDR The short version if you are impatient: get a unit cell make a supercell run VASP run process_outcar_5.3.py I could have started with this, but I wanted you to understand a bit what you should and should not do. Things to understand: Some things to consider: Read the documentation for process_outcar_5.3.py , figure out how to stitch a continuation job together. Maybe you ran VASP with some settings that makes the OUTCAR parsing fail. Make sure you understand how to construct the input files manually. Parsing other output Todo Equivalent guide for other codes.","tags":"","loc":"page/workflows/minimal_example_2.html","title":"Minimal example II – TDEP"},{"text":"Really fast stochastic calculations Todo Will arrive when I publish","tags":"","loc":"page/workflows/minimal_example_3.html","title":"Minimal example III – TDEP"},{"text":"Basic free energy calculations Navigate to /example_4_free_energy . There you should see 5 folders, each corresponding to a simulation at fix temperature, but different volumes. This particular case is PbTe at 600K. Copy all the contents to a new folder. First, we will get the free energy at a single volume. Pick one of the folders, perhaps volume_1 . We will constrain ourselves to second order force constants, run: extract_forceconstants -rc2 100 -U0\nln -s outfile.forceconstant infile.forceconstant\nphonon_dispersion_relations -loto --dos -qg 36 36 36 --temperature 300 This will produce plenty of output. The first lines calculates the second order forceconstants, including the option of calculating the renormalized baseline energy. You should have read about forceconstants already, and perhaps this is a good time to familiarize yourself with free energy calculations a bit. I put a decent explanation of the different terms here . Glance through the documentation and see what the different command line options do. Todo I realise now that maybe it would be logical to have an option called --free_energy or equivalent. Maybe add that, or rename an existing one. The things you need for the free energy is the renormalized baseline, $U_0$, and the phonon free energy $F_{\\textrm{ph}}$. These will be in outfile.U0 and outfile.free_energy respectively. If everything worked out ok, you should have something like Fph = -0.26006391 eV/atom \nU0  = -3.76922936 eV/atom So, by adding these numbers you get the Helmholtz free energy. Electronic entropy will be included, provided that it is in $U_0$. It is up to you to ensure that the underlying DFT calculations include that properly. You can't get that much useful information from a single point in volume-temperature space, lets get the free energy for all the volumes, conveniently done with a small script: #!/bin/bash # Get the forceconstants and free energy for every volume for i in 1 2 3 4 5 do cd volume_ ${ i } extract_forceconstants -rc2 100 -U0\n        ln -sf outfile.forceconstant infile.forceconstant\n        phonon_dispersion_relations --dos --temperature 600 -qg 32 32 32 --loto cd .. done This should result in a list of volumes and energies (it does not appear magically, you have to fetch the numbers): Volume        U0           Fph\n 29.92236913  -3.76922936  -0.26006391 \n 31.84747692  -3.82606181  -0.27327257 \n 33.85343312  -3.84306260  -0.28655016 \n 35.94026710  -3.82961324  -0.30108423 \n 38.11284394  -3.80467151  -0.30650145 Plotting this, and fitting to an equation of state (Birch-Murnaghan) should like like this: Make sure you can reproduce this. Small improvement First thing we can improve is how the forceconstants are extracted. In the script above, we do a full symmetry analysis for each of the volumes. That is fine, but unnecessary. The symmetry of each supercell is the same. If we modify the script slightly #!/bin/bash # Got to the first volume and do the symmetry analysis cd volume_1\n    extract_forceconstants -rc2 100\n    mv outfile.forcemap.hdf5 ../ cd .. # Reuse the symmetry analysis and get the free energy for i in 1 2 3 4 5 do cd volume_ ${ i } ln -sf ../outfile.forcemap.hdf5 infile.forcemap.hdf5\n        extract_forceconstants -rc2 100 -U0 --readforcemap\n        ln -sf outfile.forceconstant infile.forceconstant\n        phonon_dispersion_relations --dos --temperature 600 -qg 32 32 32 --loto cd .. done If you try it out, you will find that it runs a little faster. Nothing significant in this small case, but for production quality calculations this is useful. Using the same infile.forcemap.hdf5 is also a good idea, which will become apparent later. Exercises to try: Rerun things with different q-point grids for the the phonon free energy. What does the convergence look like? Use subsets of the simulation to calculate $U_0$ (using --stride , explained here ), what does that convergence look like?","tags":"","loc":"page/workflows/minimal_example_4.html","title":"Minimal example IV – TDEP"},{"text":"Essential thermal conductivity Here we will reuse the data in example_1_fcc_Al . Copy the files to a new, clean folder, and repeat the steps from the first tutorial to generate second and third order force constants. You should end up with (among other things) infile.ucposcar infile.forceconstant infile.forceconstant_thirdorder Note that this example is fcc Al. I chose that since with one atom per unit cell, the thermal conductivity calculations are really fast. Unfortunately, since thermal conductivity in Al is dominated by the electronic component, none of the values can be compared with anything in a meaningful way (but that is not the point of this tutorial anyway). To get the thermal conductivity, run mpirun thermal_conductivity -qg 5 5 5 --temperature 300 and it should appear, rather quickly. Make yourself familiar with the options for thermal conductivity , there are quite a few. A series of temperatures can be calculated with mpirun thermal_conductivity -qg 5 5 5 --temperature_range 10 1000 50 --logtempaxis Todo Do a simple q-point convergence Per default, the scattering rates are integrated using the tetrahedron method. 1 Todo Make them test tetrahedron vs gaussian. Lehmann, G., & Taut, M. (1972). On the Numerical Calculation of the Density of States and Related Properties. Physica Status Solidi (B), 54(2), 469–477. ↩","tags":"","loc":"page/workflows/minimal_example_5.html","title":"Minimal example V – TDEP"},{"text":"In the previous sections we dealt with calculations at a single temperature. Sometimes you want properties as a function of temperature. In some folder I prepared some input for ScF 3 Note Or something else. Phonons dispersions as a function of temperature Make them plot in all three folders. Point out that you should only run extractforceconstants once. Plot all three. Interpolate For some reason you realise that you where not interested in the phonon dispersions at x,y,or z K, for reasons unknown you want to determine the dispersions at XX K instead. The naive way would be to do a new calculation at that temperature, but that takes a lot of time. It's better to interpolate. Interpolating the frequencies themselves could be done, but it's not great. Empirically, I have found out that if you interpolate the forceconstants instead, you will have better luck. This is a little involved, so we will break it into steps. Provided you followed the instructions and have run extract forceconstants in all three directories, you might have noted that there are files called outfile.phi_secondorder . As described , these are a list of the irreducible forceconstants. Copy this to an infile cp outfile.phi_secondorder infile.phi_secondorder And run ./extract_forceconstants -r Note that this runs much faster: by invoking the -r flag, it will read the values from file. Now, edit infile.phi_secondorder and change some random value to 100, run ./extract_forceconstants -r\nphonon_dispersion_relations\ngnuplot outfile.dispersion_relations.gnuplot The dispersions will probably look really strange. The point of this exercise was to understand how to modify an irreducible component and get a new outfile.forceconstant out. Since we know how to translate irreducible components to forceconstants, all we need to to is interpolate each irreducible component separately, translate to forceconstants, and calculate dispersions. This way you can get the dispersions at any temperature in the interval. I like to use matlab for this step, but it should be just as easy in python or some other scripting language. I will not go into details, since I assume you know how to interpolate things. You should construct a script that Reads all N outfile.phi_secondorder For each of the values in outfile.phi_secondorder , create an interpolation that can evaluate that value at any temperature. A second order polynomial works great. At a temperature of interest, print a new infile.phi_secondorder with the interpolated values and run extract_forceconstants -r . This gives you a forceconstant at this temperature. Run phonon_dispersion_relations with the new forceconstant, and store outfile.dispersion_relations somewhere. Repeat this for say 50 temperatures in the valid range. Plot the results somehow. If successful, it should look something like this: Todo Some picture Or alternatively, just tracking the TO mode at gamma: Todo Some other picture. Lehmann, G., & Taut, M. (1972). On the Numerical Calculation of the Density of States and Related Properties. Physica Status Solidi (B), 54(2), 469–477. ↩","tags":"","loc":"page/workflows/minimal_example_6.html","title":"Minimal example VI – TDEP"},{"text":"This documentation also details the library. It's easy to write codes. A minimal code that calculates the phonon dispersions on a mesh in the BZ looks something like this: program minimal_example use constants use type_crystalstructure use type_lotosplitting use type_qpointmesh use type_phonon_dispersions use type_forceconstant_secondorder implicit none type ( lo_crystalstructure ) :: uc class ( lo_qpoint_mesh ), allocatable :: qp type ( lo_phonon_dispersions ) :: dr type ( lo_forceconstant_secondorder ) :: fc type ( lo_loto ) :: loto ! read the unitcell call uc % readfromfile ( 'infile.ucposcar' ) ! read the forceconstant call fc % readfromfile ( uc , 'infile.forceconstant' ) ! skip lo-to splitting for now, get an empty one call loto % initempty () ! generate a q-point mesh call lo_generate_qmesh ( qp , uc ,[ 24 , 24 , 24 ], 'monkhorst' ) ! phonon dispersions on this mesh call dr % generate ( qp , fc , uc , loto ) ! get the phonon free energy at 300K write ( * , * ) 'phonon free energy at 300K:' , dr % phonon_free_energy ( 30 0.0_flyt ) end program Lehmann, G., & Taut, M. (1972). On the Numerical Calculation of the Density of States and Related Properties. Physica Status Solidi (B), 54(2), 469–477. ↩","tags":"","loc":"page/workflows/using_the_library.html","title":"Using the library – TDEP"}]}